<!DOCTYPE html>
<html id="docs" lang="fr" class="">
	<head>
	

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>
<meta charset="utf-8">
<title>Service - Kubernetes</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#326ce5">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">









<link rel="stylesheet" href="/css/style.b7b8403eb5b1fddd0a2da2a8383d5b53e6ef81c23e4b0e292e6103bd91f9502d.css" integrity="sha256-t7hAPrWx/d0KLaKoOD1bU&#43;bvgcI&#43;Sw4pLmEDvZH5UC0=">


<link rel="stylesheet" href="/css/base_fonts.css">
<link rel="stylesheet" href="/css/jquery-ui.min.css">
<link rel="stylesheet" href="/css/callouts.css">
<link rel="stylesheet" href="/css/custom-jekyll/tags.css">



<meta name="description" content="">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:url" content="https://kubernetes.io/fr/docs/concepts/services-networking/service/">
<meta property="og:title" content="Service">
<meta name="twitter:title" content="Service">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">
<script src="/js/anchor-4.1.1.min.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>
<script src="/js/jquery-ui-1.12.1.min.js"></script>
<script src="/js/bootstrap-4.3.1.min.js"></script>
<script src="/js/sweetalert-2.1.2.min.js"></script>

<script src="/js/script.js"></script>
<script src="/js/custom-jekyll/tags.js"></script>


	</head>
	<body>
		<div id="cellophane" onclick="kub.toggleMenu()"></div>

<header>
    <a href="/fr/" class="logo" title="Solution professionnelle d’orchestration de conteneurs - Kubernetes" aria-label="Kubernetes website"></a>

    <div class="nav-buttons" data-auto-burger="primary">
        <ul class="global-nav">
            
            
            <li><a href="/fr/docs/" class="active">Documentation</a></li>
            
            <li><a href="/fr/blog/">Blog</a></li>
            
            
            
            <li><a href="/fr/partners/">Partenaires</a></li>
            
            <li><a href="/fr/community/">Communauté</a></li>
            
            <li><a href="/fr/case-studies/">Études de cas</a></li>
            
            
            
             <li>
                <a href="#">
                    Français <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="/docs/concepts/services-networking/service/">English</a></li>
                
                    <li><a href="/zh/docs/concepts/services-networking/service/">中文 Chinese</a></li>
                
                    <li><a href="/ko/docs/concepts/services-networking/service/">한국어 Korean</a></li>
                
                    <li><a href="/ja/docs/concepts/services-networking/service/">日本語 Japanese</a></li>
                
                    <li><a href="/id/docs/concepts/services-networking/service/">Bahasa Indonesia</a></li>
                
                </ul>
            </li>

            <li>
                <a href="#">
                    v1.17 <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="https://kubernetes.io/fr/docs/concepts/services-networking/service/">v1.21</a></li>
                
                    <li><a href="https://v1-20.docs.kubernetes.io/fr/docs/concepts/services-networking/service/">v1.20</a></li>
                
                    <li><a href="https://v1-19.docs.kubernetes.io/fr/docs/concepts/services-networking/service/">v1.19</a></li>
                
                    <li><a href="https://v1-18.docs.kubernetes.io/fr/docs/concepts/services-networking/service/">v1.18</a></li>
                
                    <li><a href="https://v1-17.docs.kubernetes.io/fr/docs/concepts/services-networking/service/">v1.17</a></li>
                
                </ul>
            </li>
        </ul>
        
        <a href="/fr/docs/tutorials/kubernetes-basics/" class="button" id="tryKubernetes" data-auto-burger-exclude>Apprendre les bases de Kubernetes</a>
        

        <button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
    </div>

    <nav id="mainNav">
        <div class="main-section" data-auto-burger="primary">
         
           <div class="nav-box">
            <h3><a href="/fr/docs/tutorials/hello-minikube/">Démarrer</a></h3>
           <p>Prêt à mettre les mains dans le cambouis ? Créez un cluster Kubernetes simple qui exécute "Hello World" avec Node.js.</p>>.

            </div>
         
           <div class="nav-box">
            <h3><a href="/fr/docs/home/">Documentation</a></h3>
           <p>Apprenez à utiliser Kubernetes à l'aide d'une documentation conceptuelle, didactique et de référence. Vous pouvez même <a href="/editdocs/" data-auto-burger-exclude>aider en contribuant à la documentation</a>!</p>

            </div>
         
           <div class="nav-box">
            <h3><a href="/fr/blog/">Blog</a></h3>
           <p>Lisez les dernières nouvelles à propos de Kubernetes et des conteneurs en général. Obtenez les derniers tutoriels techniques.</p>

            </div>
         
        </div>
        <div class="main-section" data-auto-burger="primary">
            <div class="left">
                <h5 class="github-invite">Souhaitez vous contribuer au code de Kubernetes ?</h5>
                <a href="https://github.com/kubernetes/kubernetes" class="button" data-auto-burger-exclude>Voir sur GitHub</a>
            </div>

            <div class="right">
                <h5 class="github-invite">Explorez la communauté</h5>
                <div class="social">
                    <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                    <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                    <a href="http://slack.k8s.io/" class="slack"><span>Slack Slack</span></a>
                    <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                    <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                    <a href="https://discuss.kubernetes.io" class="mailing-list"><span>Forum</span></a>
                    <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>Calendrier</span></a>
                </div>
            </div>
            <div class="clear" style="clear: both"></div>
        </div>
    </nav>
</header>

		
		
		<section id="hero" class="light-text no-sub">
			









<h1>Concepts</h1>
<h5></h5>










<div id="vendorStrip" class="light-text">
	<ul>
		
		
		<li><a href="/fr/docs/home/">ACCUEIL</a></li>
		
		
		<li><a href="/fr/docs/setup/">INSTALLATION</a></li>
		
		
		<li><a href="/fr/docs/concepts/" class="YAH">CONCEPTS</a></li>
		
		
		<li><a href="/fr/docs/tasks/">TÂCHES</a></li>
		
		
		<li><a href="/fr/docs/tutorials/">TUTORIELS</a></li>
		
		
		<li><a href="/fr/docs/reference/">RÉFÉRENCE</a></li>
		
		
		<li><a href="/fr/docs/contribute/">CONTRIBUER</a></li>
		
	</ul>
	<form id="searchBox" action="/docs/search/" role="search">
		<input type="text" id="search" name="q" placeholder="Recherche" aria-label="Search">
	</form>
</div>

		</section>
		
    
		
<section id="deprecationWarning">
  <main>
    <div class="content deprecation-warning">
      <h3>
	 Kubernetes v1.17
	  documentation non maintenue. Vous consultez une version statique. Pour une documentation à jour, veuillez consulter: 
	 <a href="https://kubernetes.io/docs/home/">dernière version.</a>
      </h3>
    </div>
  </main>
</section>


    <main>
        <section id="encyclopedia">
          
<div id="docsToc">
     <div class="pi-accordion">
    	
        
        
        
        
        
         
             
                 
             
         
             
                 
             
         
             
                 
                          
                          
                 
             
         
             
         
             
         
             
         
             
         
             
         
         
        
        <a class="item" data-title="Concepts" href="/fr/docs/concepts/"></a>

	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="Vue d&#39;ensemble">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Qu&#39;est-ce-que Kubernetes ?" href="/fr/docs/concepts/overview/what-is-kubernetes/"></a>

		
	
		
			

<a class="item" data-title="Composants de Kubernetes" href="/fr/docs/concepts/overview/components/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="The Kubernetes API <small>(EN)</small>" href="/docs/concepts/overview/kubernetes-api/"></a>

		
	
		
			
<div class="item" data-title="Utilisation des objets Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Understanding Kubernetes Objects <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/kubernetes-objects/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Kubernetes Object Management <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/object-management/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Object Names and IDs <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/names/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Namespaces <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/namespaces/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Labels and Selectors <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/labels/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Annotations <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/annotations/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Field Selectors <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/field-selectors/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Recommended Labels <small>(EN)</small>" href="/docs/concepts/overview/working-with-objects/common-labels/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Architecture de Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Noeuds" href="/fr/docs/concepts/architecture/nodes/"></a>

		
	
		
			

<a class="item" data-title="Communication Master-Node" href="/fr/docs/concepts/architecture/master-node-communication/"></a>

		
	
		
			

<a class="item" data-title="Concepts sous-jacents au Cloud Controller Manager" href="/fr/docs/concepts/architecture/cloud-controller/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Controllers <small>(EN)</small>" href="/docs/concepts/architecture/controller/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Les conteneurs">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Containers overview <small>(EN)</small>" href="/docs/concepts/containers/overview/"></a>

		
	
		
			

<a class="item" data-title="Images" href="/fr/docs/concepts/containers/images/"></a>

		
	
		
			

<a class="item" data-title="Classe d&#39;exécution (Runtime Class)" href="/fr/docs/concepts/containers/runtime-class/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Container Environment <small>(EN)</small>" href="/docs/concepts/containers/container-environment/"></a>

		
	
		
			

<a class="item" data-title="Les variables d’environnement du conteneur" href="/fr/docs/concepts/containers/container-environment-variables/"></a>

		
	
		
			

<a class="item" data-title="Hooks de cycle de vie de conteneurs" href="/fr/docs/concepts/containers/container-lifecycle-hooks/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Workloads">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="Pods">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Aperçu du Pod" href="/fr/docs/concepts/workloads/pods/pod-overview/"></a>

		
	
		
			

<a class="item" data-title="Pods" href="/fr/docs/concepts/workloads/pods/pod/"></a>

		
	
		
			

<a class="item" data-title="Cycle de vie d&#39;un Pod" href="/fr/docs/concepts/workloads/pods/pod-lifecycle/"></a>

		
	
		
			

<a class="item" data-title="Init Containers" href="/fr/docs/concepts/workloads/pods/init-containers/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Preset <small>(EN)</small>" href="/docs/concepts/workloads/pods/podpreset/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Topology Spread Constraints <small>(EN)</small>" href="/docs/concepts/workloads/pods/pod-topology-spread-constraints/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Disruptions <small>(EN)</small>" href="/docs/concepts/workloads/pods/disruptions/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Ephemeral Containers <small>(EN)</small>" href="/docs/concepts/workloads/pods/ephemeral-containers/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Contrôleurs">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="ReplicaSet" href="/fr/docs/concepts/workloads/controllers/replicaset/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="ReplicationController <small>(EN)</small>" href="/docs/concepts/workloads/controllers/replicationcontroller/"></a>

		
	
		
			

<a class="item" data-title="Déploiements" href="/fr/docs/concepts/workloads/controllers/deployment/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="StatefulSets <small>(EN)</small>" href="/docs/concepts/workloads/controllers/statefulset/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="DaemonSet <small>(EN)</small>" href="/docs/concepts/workloads/controllers/daemonset/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Garbage Collection <small>(EN)</small>" href="/docs/concepts/workloads/controllers/garbage-collection/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="TTL Controller for Finished Resources <small>(EN)</small>" href="/docs/concepts/workloads/controllers/ttlafterfinished/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Jobs - Run to Completion <small>(EN)</small>" href="/docs/concepts/workloads/controllers/jobs-run-to-completion/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="CronJob <small>(EN)</small>" href="/docs/concepts/workloads/controllers/cron-jobs/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Services, Equilibreur de charge, et Réseau">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="EndpointSlices <small>(EN)</small>" href="/docs/concepts/services-networking/endpoint-slices/"></a>

		
	
		
			

<a class="item" data-title="Service" href="/fr/docs/concepts/services-networking/service/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Service Topology <small>(EN)</small>" href="/docs/concepts/services-networking/service-topology/"></a>

		
	
		
			

<a class="item" data-title="DNS pour les services et les pods" href="/fr/docs/concepts/services-networking/dns-pod-service/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Connecting Applications with Services <small>(EN)</small>" href="/docs/concepts/services-networking/connect-applications-service/"></a>

		
	
		
			

<a class="item" data-title="Ingress" href="/fr/docs/concepts/services-networking/ingress/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Ingress Controllers <small>(EN)</small>" href="/docs/concepts/services-networking/ingress-controllers/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Network Policies <small>(EN)</small>" href="/docs/concepts/services-networking/network-policies/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Adding entries to Pod /etc/hosts with HostAliases <small>(EN)</small>" href="/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="IPv4/IPv6 dual-stack <small>(EN)</small>" href="/docs/concepts/services-networking/dual-stack/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Stockage">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Volumes" href="/fr/docs/concepts/storage/volumes/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Volume Snapshots <small>(EN)</small>" href="/docs/concepts/storage/volume-snapshots/"></a>

		
	
		
			

<a class="item" data-title="Volumes persistants" href="/fr/docs/concepts/storage/persistent-volumes/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="CSI Volume Cloning <small>(EN)</small>" href="/docs/concepts/storage/volume-pvc-datasource/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Storage Classes <small>(EN)</small>" href="/docs/concepts/storage/storage-classes/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Volume Snapshot Classes <small>(EN)</small>" href="/docs/concepts/storage/volume-snapshot-classes/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Dynamic Volume Provisioning <small>(EN)</small>" href="/docs/concepts/storage/dynamic-provisioning/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Node-specific Volume Limits <small>(EN)</small>" href="/docs/concepts/storage/storage-limits/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Configuration">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Configuration Best Practices <small>(EN)</small>" href="/docs/concepts/configuration/overview/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Resource Bin Packing for Extended Resources <small>(EN)</small>" href="/docs/concepts/configuration/resource-bin-packing/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Managing Compute Resources for Containers <small>(EN)</small>" href="/docs/concepts/configuration/manage-compute-resources-container/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Overhead <small>(EN)</small>" href="/docs/concepts/configuration/pod-overhead/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Assigning Pods to Nodes <small>(EN)</small>" href="/docs/concepts/configuration/assign-pod-node/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Taints and Tolerations <small>(EN)</small>" href="/docs/concepts/configuration/taint-and-toleration/"></a>

		
	
		
			

<a class="item" data-title="Secrets" href="/fr/docs/concepts/configuration/secret/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Organizing Cluster Access Using kubeconfig Files <small>(EN)</small>" href="/docs/concepts/configuration/organize-cluster-access-kubeconfig/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Priority and Preemption <small>(EN)</small>" href="/docs/concepts/configuration/pod-priority-preemption/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Scheduling Framework <small>(EN)</small>" href="/docs/concepts/configuration/scheduling-framework/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Sécurité">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Overview of Cloud Native Security <small>(EN)</small>" href="/docs/concepts/security/overview/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Politiques">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Limit Ranges <small>(EN)</small>" href="/docs/concepts/policy/limit-range/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Resource Quotas <small>(EN)</small>" href="/docs/concepts/policy/resource-quotas/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Security Policies <small>(EN)</small>" href="/docs/concepts/policy/pod-security-policy/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Scheduling">
	<div class="container">
		
		
	
	
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Kubernetes Scheduler <small>(EN)</small>" href="/docs/concepts/scheduling/kube-scheduler/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Scheduler Performance Tuning <small>(EN)</small>" href="/docs/concepts/scheduling/scheduler-perf-tuning/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Administration d&#39;un cluster">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Vue d&#39;ensemble de l&#39;administration d&#39;un cluster" href="/fr/docs/concepts/cluster-administration/cluster-administration-overview/"></a>

		
	
		
			

<a class="item" data-title="Certificats" href="/fr/docs/concepts/cluster-administration/certificates/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Cloud Providers <small>(EN)</small>" href="/docs/concepts/cluster-administration/cloud-providers/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Managing Resources <small>(EN)</small>" href="/docs/concepts/cluster-administration/manage-deployment/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Cluster Networking <small>(EN)</small>" href="/docs/concepts/cluster-administration/networking/"></a>

		
	
		
			

<a class="item" data-title="Architecture de Journalisation d&#39;évènements (logging)" href="/fr/docs/concepts/cluster-administration/logging/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Metrics For The Kubernetes Control Plane <small>(EN)</small>" href="/docs/concepts/cluster-administration/monitoring/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Configuring kubelet Garbage Collection <small>(EN)</small>" href="/docs/concepts/cluster-administration/kubelet-garbage-collection/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Proxies in Kubernetes <small>(EN)</small>" href="/docs/concepts/cluster-administration/proxies/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Installing Addons <small>(EN)</small>" href="/docs/concepts/cluster-administration/addons/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Extensions Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Extending your Kubernetes Cluster <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/extend-cluster/"></a>

		
	
		
			
<div class="item" data-title="Extensions de l&#39;API Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Custom Resources <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/api-extension/custom-resources/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Extending the Kubernetes API with the aggregation layer <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Extensions compute, stockage et réseau">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Network Plugins <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Device Plugins <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/"></a>

		
	

	</div>
</div>

		
	
		
			

<a class="item" target="_blank" data-title="Operator pattern <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/operator/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Service Catalog <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/service-catalog/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Poseidon-Firmament Scheduler <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/poseidon-firmament-alternate-scheduler/"></a>

		
	

	</div>
</div>

		
	





     </div> 
    <button class="push-menu-close-button" onclick="kub.toggleToc()"></button>
</div> 


          <div id="docsContent">
            

<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/fr/docs/concepts/services-networking/service.md" id="editPageButton" target="_blank">
    Edit This Page
  </a>
</p>

<h1>Service</h1>



<p>Une manière abstraite d&rsquo;exposer une application s&rsquo;exécutant sur un ensemble de <a class='glossary-tooltip' href='/fr/docs/concepts/workloads/pods/pod-overview/' target='_blank'>Pods<span class='tooltip-text'>Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.</span>
</a> en tant que service réseau.</p>

<p>Avec Kubernetes, vous n&rsquo;avez pas besoin de modifier votre application pour utiliser un mécanisme de découverte de services inconnu.
Kubernetes donne aux pods leurs propres adresses IP et un nom DNS unique pour un ensemble de pods, et peut équilibrer la charge entre eux.</p>









<ul id="markdown-toc">










<li><a href="#motivation">Motivation</a></li>




<li><a href="#service-resource">La ressource Service</a></li>




<li><a href="#d%c3%a9finition-d-un-service">Définition d’un service</a></li>




<li><a href="#ip-virtuelles-et-proxy-de-service">IP virtuelles et proxy de service</a></li>




<li><a href="#services-multi-ports">Services multi-ports</a></li>




<li><a href="#choisir-sa-propre-adresse-ip">Choisir sa propre adresse IP</a></li>




<li><a href="#d%c3%a9couvrir-les-services">Découvrir les services</a></li>




<li><a href="#headless-services">Headless Services</a></li>




<li><a href="#publishing-services-service-types">Services de publication (ServiceTypes)</a></li>




<li><a href="#lacunes">Lacunes</a></li>




<li><a href="#the-gory-details-of-virtual-ips">Implémentation IP virtuelle</a></li>




<li><a href="#objet-api">Objet API</a></li>




<li><a href="#protocol-support">Protocoles pris en charge</a></li>




<li><a href="#futurs-d%c3%a9veloppements">Futurs développements</a></li>




















<li><a href="#a-suivre">A suivre</a></li>



</ul>


<h2 id="motivation">Motivation</h2>

<p>Les <a class='glossary-tooltip' href='/fr/docs/concepts/workloads/pods/pod-overview/' target='_blank'>Pods<span class='tooltip-text'>Le plus petit et le plus simple des objets Kubernetes. Un Pod est un ensemble de conteneurs fonctionnant sur votre cluster.</span>
</a> Kubernetes sont mortels.
Ils naissent et lorsqu&rsquo;ils meurent, ils ne ressuscitent pas.
Si vous utilisez un <a class='glossary-tooltip' href='/docs/concepts/workloads/controllers/deployment/' target='_blank'>Déploiement<span class='tooltip-text'>Objet API gérant une application répliquée.</span>
</a> pour exécuter votre application, il peut créer et détruire dynamiquement des pods.</p>

<p>Chaque pod obtient sa propre adresse IP, mais dans un déploiement, l&rsquo;ensemble de pods s&rsquo;exécutant en un instant peut être différent de l&rsquo;ensemble de pods exécutant cette application un instant plus tard.</p>

<p>Cela conduit à un problème: si un ensemble de pods (appelez-les «backends») fournit des fonctionnalités à d&rsquo;autres pods (appelez-les «frontends») à l&rsquo;intérieur de votre cluster, comment les frontends peuvent-ils trouver et suivre l&rsquo;adresse IP à laquelle se connecter, afin que le frontend puisse utiliser la partie backend de la charge de travail?</p>

<p>C&rsquo;est là où les <em>Services</em> rentrent en jeu.</p>

<h2 id="service-resource">La ressource Service</h2>

<p>Dans Kubernetes, un service est une abstraction qui définit un ensemble logique de pods et une politique permettant d&rsquo;y accéder (parfois ce modèle est appelé un micro-service).
L&rsquo;ensemble des pods ciblés par un service est généralement déterminé par un <a class='glossary-tooltip' href='/docs/concepts/overview/working-with-objects/labels/' target='_blank'>selector<span class='tooltip-text'>Allows users to filter a list of resources based on labels.</span>
</a> (voir <a href="#services-without-selectors">ci-dessous</a> pourquoi vous voudrez peut-être un service <em>sans</em> un sélecteur).</p>

<p>Par exemple, considérons un backend de traitement d&rsquo;image sans état qui s&rsquo;exécute avec 3 replicas.
Ces réplicas sont fongibles et les frontends ne se soucient pas du backend qu&rsquo;ils utilisent.
Bien que les pods réels qui composent l&rsquo;ensemble backend puissent changer, les clients frontends ne devraient pas avoir besoin de le savoir, pas plus qu&rsquo;ils ne doivent suivre eux-mêmes l&rsquo;ensemble des backends.</p>

<p>L&rsquo;abstraction du service permet ce découplage.</p>

<h3 id="découverte-de-services-native-du-cloud">Découverte de services native du cloud</h3>

<p>Si vous pouvez utiliser les API Kubernetes pour la découverte de services dans votre application, vous pouvez interroger l&rsquo;<a class='glossary-tooltip' href='/docs/reference/generated/kube-apiserver/' target='_blank'>API server<span class='tooltip-text'>Composant sur le master qui expose l&rsquo;API Kubernetes. Il s&rsquo;agit du front-end pour le plan de contrôle Kubernetes.</span>
</a> pour les Endpoints, qui sont mis à jour chaque fois que l&rsquo;ensemble des pods d&rsquo;un service change.</p>

<p>Pour les applications non natives, Kubernetes propose des moyens de placer un port réseau ou un load balancer entre votre application et les modules backend.</p>

<h2 id="définition-d-un-service">Définition d&rsquo;un service</h2>

<p>Un service dans Kubernetes est un objet REST, semblable à un pod.
Comme tous les objets REST, vous pouvez effectuer un <code>POST</code> d&rsquo;une définition de service sur le serveur API pour créer une nouvelle instance.</p>

<p>Par exemple, supposons que vous ayez un ensemble de pods qui écoutent chacun sur le port TCP 9376 et portent une étiquette <code>app=MyApp</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre></div>
<p>Cette spécification crée un nouvel objet Service nommé «my-service», qui cible le port TCP 9376 sur n&rsquo;importe quel pod avec l&rsquo;étiquette «app=MyApp».</p>

<p>Kubernetes attribue à ce service une adresse IP (parfois appelé l&rsquo;&ldquo;IP cluster&rdquo;), qui est utilisé par les proxies Service (voir <a href="#virtual-ips-and-service-proxies">IP virtuelles et proxy de service</a>).</p>

<p>Le contrôleur de service recherche en continu les pods qui correspondent à son sélecteur, puis POST toutes les mises à jour d&rsquo;un objet Endpoint également appelé &ldquo;my-service&rdquo;.</p>

<blockquote class="note">
  <div><strong>Note:</strong> Un service peut mapper <em>n&rsquo;importe quel</em> <code>port</code> entrant vers un <code>targetPort</code>.
Par défaut et pour plus de commodité, le <code>targetPort</code> a la même valeur que le champ <code>port</code>.</div>
</blockquote>

<p>Les définitions de port dans les pods ont des noms, et vous pouvez référencer ces noms dans l&rsquo;attribut <code>targetPort</code> d&rsquo;un service.
Cela fonctionne même s&rsquo;il existe un mélange de pods dans le service utilisant un seul nom configuré, avec le même protocole réseau disponible via différents numéros de port.
Cela offre beaucoup de flexibilité pour déployer et faire évoluer vos services.
Par exemple, vous pouvez modifier les numéros de port que les pods exposent dans la prochaine version de votre logiciel principal, sans casser les clients.</p>

<p>Le protocole par défaut pour les services est TCP; vous pouvez également utiliser tout autre <a href="#protocol-support">protocole pris en charge</a>.</p>

<p>Comme de nombreux services doivent exposer plus d&rsquo;un port, Kubernetes prend en charge plusieurs définitions de port sur un objet Service.
Chaque définition de port peut avoir le même protocole, ou un autre.</p>

<h3 id="services-sans-sélecteurs">Services sans sélecteurs</h3>

<p>Les services abritent le plus souvent l&rsquo;accès aux pods Kubernetes, mais ils peuvent également abstraire d&rsquo;autres types de backends.
Par exemple:</p>

<ul>
<li>Vous voulez avoir un cluster de base de données externe en production, mais dans votre environnement de test, vous utilisez vos propres bases de données.</li>
<li>Vous souhaitez pointer votre service vers un service dans un autre <a class='glossary-tooltip' href='/docs/concepts/overview/working-with-objects/namespaces' target='_blank'>Namespace<span class='tooltip-text'>An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster.</span>
</a> ou sur un autre cluster.</li>
<li>Vous migrez une charge de travail vers Kubernetes.
Lors de l&rsquo;évaluation de l&rsquo;approche, vous exécutez uniquement une partie de vos backends dans Kubernetes.</li>
</ul>

<p>Dans n&rsquo;importe lequel de ces scénarios, vous pouvez définir un service <em>sans</em> un sélecteur de pod.
Par exemple:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre></div>
<p>Étant donné que ce service n&rsquo;a pas de sélecteur, l&rsquo;objet Endpoint correspondant n&rsquo;est <em>pas</em> créé automatiquement.
Vous pouvez mapper manuellement le service à l&rsquo;adresse réseau et au port où il s&rsquo;exécute, en ajoutant manuellement un objet Endpoint:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Endpoints<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>subsets:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>addresses:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>ip:<span style="color:#bbb"> </span><span style="color:#666">192.0.2.42</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>port:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre></div>
<blockquote class="note">
  <div><strong>Note:</strong> <p>Les IP de noeud final ne doivent pas être: loopback (127.0.0.0/8 pour IPv4, ::1/128 pour IPv6), ou link-local (169.254.0.0/16 et 224.0.0.0/24 pour IPv4, fe80::/64 pour IPv6).</p>

<p>Les adresses IP de noeud final ne peuvent pas être les adresses IP de cluster d&rsquo;autres services Kubernetes, car <a class='glossary-tooltip' href='/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank'>kube-proxy<span class='tooltip-text'>kube-proxy est un proxy réseau qui s&rsquo;exécute sur chaque nœud du cluster.</span>
</a> ne prend pas en charge les adresses IP virtuelles en tant que destination.</p>
</div>
</blockquote>

<p>L&rsquo;accès à un service sans sélecteur fonctionne de la même manière que s&rsquo;il avait un sélecteur.
Dans l&rsquo;exemple ci-dessus, le trafic est routé vers le Endpoint unique défini dans le YAML: <code>192.0.2.42:9376</code> (TCP).</p>

<p>Un service ExternalName est un cas spécial de service qui n&rsquo;a pas de sélecteurs et utilise des noms DNS à la place.
Pour plus d&rsquo;informations, consultez la section <a href="#externalname">ExternalName</a> plus loin dans ce document.</p>

<h3 id="endpoint-slices">Endpoint Slices</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.17</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>beta</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="beta">
Cette fonctionnalité est actuellement dans un état <em>beta</em>, c&rsquo;est-à-dire :</p>

<ul>
<li>Les noms de version contiennent: beta (par ex. v2beta3).</li>
<li>Le code est bien testé. L&rsquo;activation de cette fonctionnalité est considérée comme sûre. Elle est activée par défaut.</li>
<li>La prise en charge de l&rsquo;ensemble de la fonctionnalité ne sera pas supprimée, bien que des détails puissent changer.</li>
<li>Le schéma et/ou la sémantique des objets peuvent changer de manière incompatible dans une version bêta ou stable ultérieure. Lorsque cela se produira, nous vous fournirons des instructions pour migrer vers la prochaine version. Cela peut nécessiter la suppression, l&rsquo;édition et la recréation d&rsquo;objets API. Le processus de changement de version peut nécessiter une certaine réflexion. Cela peut aussi nécessiter une interruption de service pour les applications qui s&rsquo;appuient sur cette fonctionnalité.</li>
<li>Recommandé uniquement pour les utilisations non critiques en raison du risque de changements incompatibles dans les versions ultérieures. Si vous avez plusieurs clusters qui peuvent être mis à niveau indépendamment, vous pouvez assouplir cette restriction.</li>
<li>Donnez votre avis sur cette fonctionnalité bêta ! Une fois qu&rsquo;elle aura quitté la version bêta, ce sera probablement moins évident pour nous d&rsquo;apporter d&rsquo;autres changements.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Un Endpoint Slices est une ressource API qui peut fournir une alternative plus évolutive au Endpoints.
Bien que conceptuellement assez similaire aux Endpoints, les Endpoint Slices permettent la distribution des  endpoints réseau sur plusieurs ressources.
Par défaut, un Endpoint Slice est considéré comme &ldquo;plein&rdquo; une fois qu&rsquo;il atteint 100 endpoints, au delà, des Endpoint Slices addtionnels seront crées pour stocker tout autre endpoints.</p>

<p>Les Endpoint Slices fournissent des attributs et des fonctionnalités supplémentaires qui sont décrits en détail dans <a href="/docs/concepts/services-networking/endpoint-slices/">Endpoint Slices</a>.</p>

<h2 id="ip-virtuelles-et-proxy-de-service">IP virtuelles et proxy de service</h2>

<p>Chaque nœud d&rsquo;un cluster Kubernetes exécute un <code>kube-proxy</code>.
<code>kube-proxy</code> est responsable de l&rsquo;implémentation d&rsquo;une forme d&rsquo;IP virtuelle pour les <code>Services</code> qui ne sont pas de type <a href="#externalname"><code>ExternalName</code></a>.</p>

<h3 id="pourquoi-ne-pas-utiliser-le-dns-round-robin">Pourquoi ne pas utiliser le DNS round-robin ?</h3>

<p>Une question qui apparaît de temps en temps est pourquoi Kubernetes s&rsquo;appuie sur le proxy pour transférer le trafic entrant vers les backends.
Et les autres approches?
Par exemple, serait-il possible de configurer des enregistrements DNS qui ont plusieurs valeurs A (ou AAAA pour IPv6), et de s&rsquo;appuyer sur la résolution de nom à tour de rôle (round-robin)?</p>

<p>Il existe plusieurs raisons d&rsquo;utiliser le proxy pour les services:</p>

<ul>
<li>Il existe une longue histoire d&rsquo;implémentations DNS ne respectant pas les TTL d&rsquo;enregistrement et mettant en cache les résultats des recherches de noms après leur expiration.</li>
<li>Certaines applications n&rsquo;effectuent des recherches DNS qu&rsquo;une seule fois et mettent en cache les résultats indéfiniment.</li>
<li>Même si les applications et les bibliothèques ont fait une bonne résolution, les TTL faibles ou nuls sur les enregistrements DNS pourraient imposer une charge élevée sur DNS qui devient alors difficile à gérer.</li>
</ul>

<h3 id="proxy-mode-userspace">User space proxy mode</h3>

<p>Dans ce mode, kube-proxy surveille le maître Kubernetes pour l&rsquo;ajout et la suppression d&rsquo;objets Service et Endpoint.
Pour chaque service, il ouvre un port (choisi au hasard) sur le nœud local.
Toutes les connexions à ce &ldquo;port proxy&rdquo; sont transmises par proxy à l&rsquo;un des modules backend du service (comme indiqué via les Endpoints).
kube-proxy prend en compte le paramètre <code>SessionAffinity</code> du service pour décider quel pod backend utiliser.</p>

<p>Enfin, le proxy de l&rsquo;espace utilisateur installe des règles iptables qui capturent le trafic vers le service <code>clusterIP</code> (qui est virtuel) et <code>port</code>.
Les règles redirigent ce trafic vers le port proxy qui fait office de proxy pour le Pod de backend.</p>

<p>Par défaut, kube-proxy en mode espace utilisateur choisit un backend via un algorithme round-robin.</p>

<p><img src="/images/docs/services-userspace-overview.svg" alt="Diagramme de vue d'ensemble des services pour le proxy de l'espace utilisateur" /></p>

<h3 id="proxy-mode-iptables"><code>iptables</code> proxy mode</h3>

<p>Dans ce mode, kube-proxy surveille le plan de contrôle Kubernetes pour l&rsquo;ajout et la suppression d&rsquo;objets Service et Endpoint.
Pour chaque service, il installe des règles iptables, qui capturent le trafic vers le «clusterIP» et le «port» du service, et redirigent ce trafic vers l&rsquo;un des ensembles principaux du service.
Pour chaque objet Endpoint, il installe des règles iptables qui sélectionnent un Pod de backend.</p>

<p>Par défaut, kube-proxy en mode iptables choisit un backend au hasard.</p>

<p>L&rsquo;utilisation d&rsquo;iptables pour gérer le trafic a un coût système inférieur, car le trafic est géré par Linux netfilter sans avoir besoin de basculer entre l&rsquo;espace utilisateur et l&rsquo;espace noyau.
Cette approche est également susceptible d&rsquo;être plus fiable.</p>

<p>Si kube-proxy s&rsquo;exécute en mode iptables et que le premier pod sélectionné ne répond pas, la connexion échoue.
C&rsquo;est différent du mode espace utilisateur: dans ce scénario, kube-proxy détecterait que la connexion au premier pod avait échoué et réessayerait automatiquement avec un pod backend différent.</p>

<p>Vous pouvez utiliser les <a href="/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">readiness probes</a> d&rsquo;un Pod pour vérifier que les pods backend fonctionnent correctement, de sorte que kube-proxy en mode iptables ne voit que les backends testés comme sains.
Cela signifie que vous évitez d&rsquo;envoyer du trafic via kube-proxy vers un pod connu pour avoir échoué.</p>

<p><img src="/images/docs/services-iptables-overview.svg" alt="Diagramme de présentation des services pour le proxy iptables" /></p>

<h3 id="proxy-mode-ipvs">IPVS proxy mode</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.11</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
Cette fonctionnalité est <em>stable</em>, ce qui signifie :</p>

<ul>
<li>Le nom de version est vX où X est un entier.</li>
<li>Les versions stables des fonctionnalités seront maintenues pour de nombreuses versions ultérieures.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>En mode <code>ipvs</code>, kube-proxy surveille les Services et Endpoints Kubernetes. kube-proxy appelle l&rsquo;interface<code>netlink</code> pour créer les règles IPVS en conséquence et synchronise périodiquement les règles IPVS avec les Services et Endpoints Kubernetes.
Cette boucle de contrôle garantit que l&rsquo;état IPVS correspond à l&rsquo;état souhaité.
Lors de l&rsquo;accès à un service, IPVS dirige le trafic vers l&rsquo;un des pods backend.</p>

<p>Le mode proxy IPVS est basé sur des fonctions hooks de netfilter qui est similaire au mode iptables, mais utilise la table de hachage comme structure de données sous-jacente et fonctionne dans l&rsquo;espace du noyau.
Cela signifie que kube-proxy en mode IPVS redirige le trafic avec une latence plus faible que kube-proxy en mode iptables, avec de bien meilleures performances lors de la synchronisation des règles de proxy.
Par rapport aux autres modes proxy, le mode IPVS prend également en charge un débit plus élevé de trafic réseau.</p>

<p>IPVS offre plus d&rsquo;options pour équilibrer le trafic vers les pods d&rsquo;arrière-plan; ceux-ci sont:</p>

<ul>
<li><code>rr</code>: round-robin</li>
<li><code>lc</code>: least connection (plus petit nombre de connexions ouvertes)</li>
<li><code>dh</code>: destination hashing</li>
<li><code>sh</code>: source hashing</li>
<li><code>sed</code>: shortest expected delay</li>
<li><code>nq</code>: never queue</li>
</ul>

<blockquote class="note">
  <div><strong>Note:</strong> <p>Pour exécuter kube-proxy en mode IPVS, vous devez rendre IPVS Linux disponible sur le nœud avant de démarrer kube-proxy.</p>

<p>Lorsque kube-proxy démarre en mode proxy IPVS, il vérifie si les modules du noyau IPVS sont disponibles.
Si les modules du noyau IPVS ne sont pas détectés, alors kube-proxy revient à fonctionner en mode proxy iptables.</p>
</div>
</blockquote>

<p><img src="/images/docs/services-ipvs-overview.svg" alt="Diagramme de vue d'ensemble des services pour le proxy IPVS" /></p>

<p>Dans ces modèles de proxy, le trafic lié à l&rsquo;IP: Port du service est dirigé vers un backend approprié sans que les clients ne sachent quoi que ce soit sur Kubernetes, les services ou les pods.</p>

<p>Si vous souhaitez vous assurer que les connexions d&rsquo;un client particulier sont transmises à chaque fois au même pod, vous pouvez sélectionner l&rsquo;affinité de session en fonction des adresses IP du client en définissant <code>service.spec.sessionAffinity</code> sur&rdquo; ClientIP &ldquo;(la valeur par défaut est&rdquo; None&rdquo;).
Vous pouvez également définir la durée maximale de session persistante en définissant <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> de manière appropriée (la valeur par défaut est 10800, ce qui correspond à 3 heures).</p>

<h2 id="services-multi-ports">Services multi-ports</h2>

<p>Pour certains services, vous devez exposer plusieurs ports.
Kubernetes vous permet de configurer plusieurs définitions de port sur un objet Service.
Lorsque vous utilisez plusieurs ports pour un service, vous devez donner tous vos noms de ports afin qu&rsquo;ils ne soient pas ambigus.
Par exemple:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">      </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>https<span style="color:#bbb">
</span><span style="color:#bbb">      </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span>port:<span style="color:#bbb"> </span><span style="color:#666">443</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9377</span></code></pre></div>
<blockquote class="note">
  <div><strong>Note:</strong> <p>Comme pour tous les <a class='glossary-tooltip' href='/docs/concepts/overview/working-with-objects/names' target='_blank'>names<span class='tooltip-text'>A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name.</span>
</a> Kubernetes en général, les noms de ports ne doivent contenir que des caractères alphanumériques en minuscules et <code>-</code>.
Les noms de port doivent également commencer et se terminer par un caractère alphanumérique.</p>

<p>Par exemple, les noms <code>123-abc</code> et <code>web</code> sont valides, mais <code>123_abc</code> et <code>-web</code> ne le sont pas.</p>
</div>
</blockquote>

<h2 id="choisir-sa-propre-adresse-ip">Choisir sa propre adresse IP</h2>

<p>Vous pouvez spécifier votre propre adresse IP de cluster dans le cadre d&rsquo;une demande de création de Service.
Pour ce faire, définissez le champ <code>.spec.clusterIP</code>.
Par exemple, si vous avez déjà une entrée DNS existante que vous souhaitez réutiliser, ou des systèmes existants qui sont configurés pour une adresse IP spécifique et difficiles à reconfigurer.</p>

<p>L&rsquo;adresse IP que vous choisissez doit être une adresse IPv4 ou IPv6 valide dans la plage CIDR <code>service-cluster-ip-range</code> configurée pour le serveur API.
Si vous essayez de créer un service avec une valeur d&rsquo;adresse de clusterIP non valide, le serveur API retournera un code d&rsquo;état HTTP 422 pour indiquer qu&rsquo;il y a un problème.</p>

<h2 id="découvrir-les-services">Découvrir les services</h2>

<p>Kubernetes prend en charge 2 modes principaux de recherche d&rsquo;un service: les variables d&rsquo;environnement et DNS.</p>

<h3 id="variables-d-environnement">Variables d&rsquo;environnement</h3>

<p>Lorsqu&rsquo;un pod est exécuté sur un nœud, le kubelet ajoute un ensemble de variables d&rsquo;environnement pour chaque service actif.
Il prend en charge à la fois les variables <a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank">Docker links</a> (voir <a href="http://releases.k8s.io/v1.17.17/pkg/kubelet/envvars/envvars.go#L49" target="_blank">makeLinkVariables</a>) et plus simplement les variables <code>{SVCNAME}_SERVICE_HOST</code> et <code>{SVCNAME}_SERVICE_PORT</code>, où le nom du service est en majuscules et les tirets sont convertis en underscore.</p>

<p>Par exemple, le service <code>redis-master</code> qui expose le port TCP 6379 et a reçu l&rsquo;adresse IP de cluster 10.0.0.11, produit les variables d&rsquo;environnement suivantes:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">REDIS_MASTER_SERVICE_HOST</span><span style="color:#666">=</span><span style="color:#666">10</span>.0.0.11
<span style="color:#b8860b">REDIS_MASTER_SERVICE_PORT</span><span style="color:#666">=</span><span style="color:#666">6379</span>
<span style="color:#b8860b">REDIS_MASTER_PORT</span><span style="color:#666">=</span>tcp://10.0.0.11:6379
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP</span><span style="color:#666">=</span>tcp://10.0.0.11:6379
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style="color:#666">=</span>tcp
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_PORT</span><span style="color:#666">=</span><span style="color:#666">6379</span>
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style="color:#666">=</span><span style="color:#666">10</span>.0.0.11</code></pre></div>
<blockquote class="note">
  <div><strong>Note:</strong> <p>Lorsque vous avez un pod qui doit accéder à un service et que vous utilisez la méthode des variables d&rsquo;environnement pour publier le port et l&rsquo;IP du cluster sur les pods clients, vous devez créer le service <em>avant</em> que les pods clients n&rsquo;existent.
Sinon, ces pods clients n&rsquo;auront pas leurs variables d&rsquo;environnement remplies.</p>

<p>Si vous utilisez uniquement DNS pour découvrir l&rsquo;IP du cluster pour un service, vous n&rsquo;avez pas à vous soucier de ce problème de commande.</p>
</div>
</blockquote>

<h3 id="dns">DNS</h3>

<p>Vous pouvez (et devrait presque toujours) configurer un service DNS pour votre cluster Kubernetes à l&rsquo;aide d&rsquo;un <a href="/docs/concepts/cluster-administration/addons/">add-on</a>.</p>

<p>Un serveur DNS prenant en charge les clusters, tel que CoreDNS, surveille l&rsquo;API Kubernetes pour les nouveaux services et crée un ensemble d&rsquo;enregistrements DNS pour chacun.
Si le DNS a été activé dans votre cluster, tous les pods devraient automatiquement être en mesure de résoudre les services par leur nom DNS.</p>

<p>Par exemple, si vous avez un service appelé <code>&quot;my-service&quot;</code> dans un namespace Kubernetes <code>&quot;my-ns&quot;</code>, le plan de contrôle et le service DNS agissant ensemble et créent un enregistrement DNS pour <code>&quot;my-service.my-ns&quot;</code>.
Les Pods dans le Namespace <code>&quot;my-ns&quot;</code> devrait être en mesure de le trouver en faisant simplement une recherche de nom pour <code>my-service</code> (<code>&quot;my-service.my-ns&quot;</code> fonctionnerait également).</p>

<p>Les pods dans d&rsquo;autres namespaces doivent utiliser le nom de <code>my-service.my-ns</code>.
Ces noms seront résolus en IP de cluster attribuée pour le service.</p>

<p>Kubernetes prend également en charge les enregistrements DNS SRV (Service) pour les ports nommés.
Si le service <code>&quot;my-service.my-ns&quot;</code> a un port nommé <code>http</code> avec un protocole défini sur <code>TCP</code>, vous pouvez effectuer une requête DNS SRV pour <code>_http._tcp.my-service.my-ns</code> pour découvrir le numéro de port de <code>http</code>, ainsi que l&rsquo;adresse IP.</p>

<p>Le serveur DNS Kubernetes est le seul moyen d&rsquo;accéder aux services <code>ExternalName</code>.
Vous pouvez trouver plus d&rsquo;informations sur la résolution de <code>ExternalName</code> dans <a href="/docs/concepts/services-networking/dns-pod-service/">DNS Pods et Services</a>.</p>

<h2 id="headless-services">Headless Services</h2>

<p>Parfois, vous n&rsquo;avez pas besoin de load-balancing et d&rsquo;une seule IP de Service.
Dans ce cas, vous pouvez créer ce que l&rsquo;on appelle des services &ldquo;headless&rdquo;, en spécifiant explicitement &ldquo;None&rdquo; pour l&rsquo;IP du cluster (<code>.spec.clusterIP</code>).</p>

<p>Vous pouvez utiliser un service headless pour interfacer avec d&rsquo;autres mécanismes de découverte de service, sans être lié à l&rsquo;implémentation de Kubernetes.</p>

<p>Pour les services headless, une IP de cluster n&rsquo;est pas allouée, kube-proxy ne gère pas ces services et aucun load-balancing ou proxy n&rsquo;est effectué par la plateforme pour eux.
La configuration automatique de DNS dépend de la définition ou non de sélecteurs par le service:</p>

<h3 id="avec-sélecteurs">Avec sélecteurs</h3>

<p>Pour les services headless qui définissent des sélecteurs, le controlleur des Endpoints crée des enregistrements <code>Endpoints</code> dans l&rsquo;API, et modifie la configuration DNS pour renvoyer des enregistrements (adresses) qui pointent directement vers les <code>Pods</code> visés par le <code>Service</code>.</p>

<h3 id="sans-sélecteurs">Sans sélecteurs</h3>

<p>Pour les services headless qui ne définissent pas de sélecteurs, le contrôleur des Endpoints ne crée pas d&rsquo;enregistrements <code>Endpoints</code>.
Cependant, le système DNS recherche et configure soit:</p>

<ul>
<li>Enregistrements CNAME pour les services de type <a href="#externalname"><code>ExternalName</code></a>.</li>
<li>Un enregistrement pour tous les «Endpoints» qui partagent un nom avec le Service, pour tous les autres types.</li>
</ul>

<h2 id="publishing-services-service-types">Services de publication (ServiceTypes)</h2>

<p>Pour certaines parties de votre application (par exemple, les frontaux), vous souhaiterez peut-être exposer un service sur une adresse IP externe, qui est en dehors de votre cluster.</p>

<p>Les «ServiceTypes» de Kubernetes vous permettent de spécifier le type de service que vous souhaitez.
La valeur par défaut est «ClusterIP».</p>

<p>Les valeurs de <code>Type</code> et leurs comportements sont:</p>

<ul>
<li><code>ClusterIP</code>: Expose le service sur une IP interne au cluster.
 Le choix de cette valeur rend le service uniquement accessible à partir du cluster.
 Il s&rsquo;agit du <code>ServiceType</code> par défaut.</li>
<li><a href="#nodeport"><code>NodePort</code></a>: Expose le service sur l&rsquo;IP de chaque nœud sur un port statique (le <code>NodePort</code>).
 Un service <code>ClusterIP</code>, vers lequel le service<code>NodePort</code> est automatiquement créé.
 Vous pourrez contacter le service <code>NodePort</code>, depuis l&rsquo;extérieur du cluster, en demandant <code>&lt;NodeIP&gt;: &lt;NodePort&gt;</code>.</li>
<li><a href="#loadbalancer"><code>LoadBalancer</code></a>: Expose le service en externe à l&rsquo;aide de l&rsquo;équilibreur de charge d&rsquo;un fournisseur de cloud.
 Les services <code>NodePort</code> et <code>ClusterIP</code>, vers lesquels les itinéraires de l&rsquo;équilibreur de charge externe, sont automatiquement créés.</li>
<li><a href="#externalname"><code>ExternalName</code></a>: Mappe le service au contenu du champ <code>externalName</code> (par exemple<code>foo.bar.example.com</code>), en renvoyant un enregistrement <code>CNAME</code> avec sa valeur.
 Aucun proxy d&rsquo;aucune sorte n&rsquo;est mis en place.
 <blockquote class="note">
<div><strong>Note:</strong> Vous avez besoin de CoreDNS version 1.7 ou supérieure pour utiliser le type <code>ExternalName</code>.</div>
</blockquote></li>
</ul>

<p>Vous pouvez également utiliser <a href="/fr/docs/concepts/services-networking/ingress">Ingress</a> pour exposer votre service.
Ingress n&rsquo;est pas un type de service, mais il sert de point d&rsquo;entrée pour votre cluster.
Il vous permet de consolider vos règles de routage en une seule ressource car il peut exposer plusieurs services sous la même adresse IP.</p>

<h3 id="nodeport">Type NodePort</h3>

<p>Si vous définissez le champ <code>type</code> sur<code>NodePort</code>, le plan de contrôle Kubernetes alloue un port à partir d&rsquo;une plage spécifiée par l&rsquo;indicateur <code>--service-node-port-range</code> (par défaut: 30000-32767).
Chaque nœud assure le proxy de ce port (le même numéro de port sur chaque nœud) vers votre service.
Votre service signale le port alloué dans son champ <code>.spec.ports[*].nodePort</code>.</p>

<p>Si vous souhaitez spécifier une ou des adresses IP particulières pour proxyer le port, vous pouvez définir l&rsquo;indicateur <code>--nodeport-addresses</code> dans kube-proxy sur des blocs IP particuliers; cela est pris en charge depuis Kubernetes v1.10.
Cet indicateur prend une liste délimitée par des virgules de blocs IP (par exemple 10.0.0.0/8, 192.0.2.0/25) pour spécifier les plages d&rsquo;adresses IP que kube-proxy doit considérer comme locales pour ce nœud.</p>

<p>Par exemple, si vous démarrez kube-proxy avec l&rsquo;indicateur <code>--nodeport-addresses=127.0.0.0/8</code>, kube-proxy sélectionne uniquement l&rsquo;interface de boucle locale pour les services NodePort.
La valeur par défaut pour <code>--nodeport-addresses</code> est une liste vide.
Cela signifie que kube-proxy doit prendre en compte toutes les interfaces réseau disponibles pour NodePort (qui est également compatible avec les versions antérieures de Kubernetes).</p>

<p>Si vous voulez un numéro de port spécifique, vous pouvez spécifier une valeur dans le champ <code>nodePort</code>.
Le plan de contrôle vous attribuera ce port ou signalera l&rsquo;échec de la transaction API.
Cela signifie que vous devez vous occuper vous-même des éventuelles collisions de ports.
Vous devez également utiliser un numéro de port valide, celui qui se trouve dans la plage configurée pour l&rsquo;utilisation de NodePort.</p>

<p>L&rsquo;utilisation d&rsquo;un NodePort vous donne la liberté de configurer votre propre solution d&rsquo;équilibrage de charge, de configurer des environnements qui ne sont pas entièrement pris en charge par Kubernetes, ou même d&rsquo;exposer directement les adresses IP d&rsquo;un ou plusieurs nœuds.</p>

<p>Notez que ce service est visible en tant que <code>&lt;NodeIP&gt;: spec.ports[*].nodePort</code> et <code>.spec.clusterIP: spec.ports[*].Port</code>.
(Si l&rsquo;indicateur <code>--nodeport-addresses</code> dans kube-proxy est défini, <NodeIP> serait filtré NodeIP(s).)</p>

<h3 id="loadbalancer">Type LoadBalancer</h3>

<p>Sur les fournisseurs de cloud qui prennent en charge les load balancers externes, la définition du champ <code>type</code> sur<code>LoadBalancer</code> provisionne un load balancer pour votre service.
La création réelle du load balancer se produit de manière asynchrone et les informations sur le load balancer provisionné sont publiées dans le champ <code>.status.loadBalancer</code>.
Par exemple:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>clusterIP:<span style="color:#bbb"> </span><span style="color:#666">10.0.171.239</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>type:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span><span style="color:#bbb"></span>status:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>loadBalancer:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>ingress:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>ip:<span style="color:#bbb"> </span><span style="color:#666">192.0.2.127</span></code></pre></div>
<p>Le trafic provenant du load balancer externe est dirigé vers les Pods backend.
Le fournisseur de cloud décide de la répartition de la charge.</p>

<p>Certains fournisseurs de cloud vous permettent de spécifier le <code>loadBalancerIP</code>.
Dans ces cas, le load balancer est créé avec le <code>loadBalancerIP</code> spécifié par l&rsquo;utilisateur.
Si le champ <code>loadBalancerIP</code> n&rsquo;est pas spécifié, le loadBalancer est configuré avec une adresse IP éphémère.
Si vous spécifiez un <code>loadBalancerIP</code> mais que votre fournisseur de cloud ne prend pas en charge la fonctionnalité, le champ <code>loadBalancerIP</code> que vous définissez est ignoré.</p>

<blockquote class="note">
  <div><strong>Note:</strong> Si vous utilisez SCTP, voir le <a href="#caveat-sctp-loadbalancer-service-type">caveat</a> ci-dessous sur le type de service <code>LoadBalancer</code>.</div>
</blockquote>

<blockquote class="note">
  <div><strong>Note:</strong> <p>Sur <strong>Azure</strong>, si vous souhaitez utiliser un type public spécifié par l&rsquo;utilisateur <code>loadBalancerIP</code>, vous devez d&rsquo;abord créer une ressource d&rsquo;adresse IP publique de type statique.
Cette ressource d&rsquo;adresse IP publique doit se trouver dans le même groupe de ressources que les autres ressources créées automatiquement du cluster.
Par exemple, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.</p>

<p>Spécifiez l&rsquo;adresse IP attribuée en tant que loadBalancerIP.
Assurez-vous d&rsquo;avoir mis à jour le securityGroupName dans le fichier de configuration du fournisseur de cloud.
Pour plus d&rsquo;informations sur le dépannage <code>CreatingLoadBalancerFailed</code> relatif aux permissions consultez: <a href="https://docs.microsoft.com/en-us/azure/aks/static-ip" target="_blank">Use a static IP address with the Azure Kubernetes Service (AKS) load balancer</a> ou <a href="https://github.com/Azure/AKS/issues/357" target="_blank">CreatingLoadBalancerFailed on AKS cluster with advanced networking</a>.</p>
</div>
</blockquote>

<h4 id="load-balancer-interne">Load Balancer interne</h4>

<p>Dans un environnement mixte, il est parfois nécessaire d&rsquo;acheminer le trafic des services à l&rsquo;intérieur du même bloc d&rsquo;adresse réseau (virtuel).</p>

<p>Dans un environnement DNS à horizon divisé, vous auriez besoin de deux services pour pouvoir acheminer le trafic externe et interne vers vos endpoints.</p>

<p>Vous pouvez y parvenir en ajoutant une des annotations suivantes à un service.
L&rsquo;annotation à ajouter dépend du fournisseur de services cloud que vous utilisez.</p>

<div id="service-tabs">
<ul>
    
      
  <li><a href="#service-tabs-0">Default</a></li>

      
  <li><a href="#service-tabs-1">GCP</a></li>

      
  <li><a href="#service-tabs-2">AWS</a></li>

      
  <li><a href="#service-tabs-3">Azure</a></li>

      
  <li><a href="#service-tabs-4">OpenStack</a></li>

      
  <li><a href="#service-tabs-5">Baidu Cloud</a></li>

      
  <li><a href="#service-tabs-6">Tencent Cloud</a></li>

</ul>


<div id="service-tabs-0">
    
        <p>Sélectionnez l&rsquo;un des onglets.</p>

    
</div>

<div id="service-tabs-1">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>cloud.google.com/load-balancer-type:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Internal&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-2">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-internal:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-3">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/azure-load-balancer-internal:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-4">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/openstack-internal-load-balancer:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-5">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/cce-load-balancer-internal-vpc:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-6">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>annotations:<span style="color:#bbb">  
</span><span style="color:#bbb">    </span>service.kubernetes.io/qcloud-loadbalancer-internal-subnetid:<span style="color:#bbb"> </span>subnet-xxxxx<span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<p></div></p>

<script>$(function(){$("#service-tabs").tabs();});</script>

<h4 id="ssl-support-on-aws">Prise en charge TLS sur AWS</h4>

<p>Pour une prise en charge partielle de TLS / SSL sur des clusters exécutés sur AWS, vous pouvez ajouter trois annotations à un service <code>LoadBalancer</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>service.beta.kubernetes.io/aws-load-balancer-ssl-cert:<span style="color:#bbb"> </span>arn:aws:acm:us-east<span style="color:#666">-1</span>:<span style="color:#666">123456789012</span>:certificate/<span style="color:#666">12345678-1234-1234-1234-123456789012</span></code></pre></div>
<p>Le premier spécifie l&rsquo;ARN du certificat à utiliser.
Il peut s&rsquo;agir soit d&rsquo;un certificat d&rsquo;un émetteur tiers qui a été téléchargé sur IAM, soit d&rsquo;un certificat créé dans AWS Certificate Manager.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>service.beta.kubernetes.io/aws-load-balancer-backend-protocol:<span style="color:#bbb"> </span>(https|http|ssl|tcp)</code></pre></div>
<p>La deuxième annotation spécifie le protocole utilisé par un pod.
Pour HTTPS et SSL, l&rsquo;ELB s&rsquo;attend à ce que le pod s&rsquo;authentifie sur la connexion chiffrée, à l&rsquo;aide d&rsquo;un certificat.</p>

<p>HTTP et HTTPS sélectionnent le proxy de couche 7: l&rsquo;ELB met fin à la connexion avec l&rsquo;utilisateur, analyse les en-têtes et injecte l&rsquo;en-tête <code>X-Forwarded-For</code> avec l&rsquo;adresse IP de l&rsquo;utilisateur (les pods ne voient que l&rsquo;adresse IP de l&rsquo;ELB à l&rsquo;autre extrémité de sa connexion) lors du transfert des demandes.</p>

<p>TCP et SSL sélectionnent le proxy de couche 4: l&rsquo;ELB transfère le trafic sans modifier les en-têtes.</p>

<p>Dans un environnement à usage mixte où certains ports sont sécurisés et d&rsquo;autres non chiffrés, vous pouvez utiliser les annotations suivantes:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-backend-protocol:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-ssl-ports:<span style="color:#bbb"> </span><span style="color:#b44">&#34;443,8443&#34;</span></code></pre></div>
<p>Dans l&rsquo;exemple ci-dessus, si le service contenait trois ports, «80», «443» et «8443», alors «443» et «8443» utiliseraient le certificat SSL, mais «80» serait simplement un proxy HTTP.</p>

<p>A partir de Kubernetes v1.9, vous pouvez utiliser des <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html" target="_blank">stratégies SSL AWS prédéfinies</a> avec des écouteurs HTTPS ou SSL pour vos services.
Pour voir quelles politiques sont disponibles, vous pouvez utiliser l&rsquo;outil de ligne de commande <code>aws</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aws elb describe-load-balancer-policies --query <span style="color:#b44">&#39;PolicyDescriptions[].PolicyName&#39;</span></code></pre></div>
<p>Vous pouvez ensuite spécifier l&rsquo;une de ces stratégies à l&rsquo;aide de l&rsquo;annotation &ldquo;<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>&rdquo;; par exemple:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy:<span style="color:#bbb"> </span><span style="color:#b44">&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span></code></pre></div>
<h4 id="prise-en-charge-du-protocole-proxy-sur-aws">Prise en charge du protocole PROXY sur AWS</h4>

<p>Pour activer <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" target="_blank">protocole PROXY</a> prise en charge des clusters exécutés sur AWS, vous pouvez utiliser l&rsquo;annotation de service suivante:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span></code></pre></div>
<p>Depuis la version 1.3.0, l&rsquo;utilisation de cette annotation s&rsquo;applique à tous les ports mandatés par l&rsquo;ELB et ne peut pas être configurée autrement.</p>

<h4 id="journaux-d-accès-elb-sur-aws">Journaux d&rsquo;accès ELB sur AWS</h4>

<p>Il existe plusieurs annotations pour gérer les journaux d&rsquo;accès aux services ELB sur AWS.</p>

<p>L&rsquo;annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code> contrôle si les journaux d&rsquo;accès sont activés.</p>

<p>L&rsquo;annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code> contrôle l&rsquo;intervalle en minutes pour la publication des journaux d&rsquo;accès.
Vous pouvez spécifier un intervalle de 5 ou 60 minutes.</p>

<p>L&rsquo;annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code> contrôle le nom du bucket Amazon S3 où les journaux d&rsquo;accès au load balancer sont stockés.</p>

<p>L&rsquo;annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code> spécifie la hiérarchie logique que vous avez créée pour votre bucket Amazon S3.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Spécifie si les journaux d&#39;accès sont activés pour le load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># L&#39;intervalle de publication des journaux d&#39;accès.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Vous pouvez spécifier un intervalle de 5 ou 60 (minutes).</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name:<span style="color:#bbb"> </span><span style="color:#b44">&#34;my-bucket&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Le nom du bucket Amazon S3 où les journaux d&#39;accès sont stockés</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix:<span style="color:#bbb"> </span><span style="color:#b44">&#34;my-bucket-prefix/prod&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># La hiérarchie logique que vous avez créée pour votre bucket Amazon S3, par exemple `my-bucket-prefix/prod`</span></code></pre></div>
<h4 id="drainage-de-connexion-sur-aws">Drainage de connexion sur AWS</h4>

<p>Le drainage des connexions pour les ELB classiques peut être géré avec l&rsquo;annotation <code>service.beta.kubernetes.io / aws-load-balancer-connection-draining-enabled</code> définie sur la valeur <code>true</code>.
L&rsquo;annotation <code>service.beta.kubernetes.io / aws-load-balancer-connection-draining-timeout</code> peut également être utilisée pour définir la durée maximale, en secondes, pour garder les connexions existantes ouvertes avant de désenregistrer les instances.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span></code></pre></div>
<h4 id="autres-annotations-elb">Autres annotations ELB</h4>

<p>Il existe d&rsquo;autres annotations pour gérer les Elastic Load Balancers décrits ci-dessous.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Délai, en secondes, pendant lequel la connexion peut être inactive (aucune donnée n&#39;a été envoyée via la connexion) avant d&#39;être fermée par le load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Spécifie si le load balancing inter-zones est activé pour le load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags:<span style="color:#bbb"> </span><span style="color:#b44">&#34;environment=prod,owner=devops&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Une liste de paires clé-valeur séparées par des virgules qui seront enregistrées en tant que balises supplémentaires dans l&#39;ELB.</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Nombre de contrôles de santé successifs réussis requis pour qu&#39;un backend soit considéré comme sain pour le trafic.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># La valeur par défaut est 2, doit être comprise entre 2 et 10</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold:<span style="color:#bbb"> </span><span style="color:#b44">&#34;3&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Nombre de contrôles de santé infructueux requis pour qu&#39;un backend soit considéré comme inapte pour le trafic.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># La valeur par défaut est 6, doit être comprise entre 2 et 10</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval:<span style="color:#bbb"> </span><span style="color:#b44">&#34;20&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Intervalle approximatif, en secondes, entre les contrôles d&#39;intégrité d&#39;une instance individuelle.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># La valeur par défaut est 10, doit être comprise entre 5 et 300</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Durée, en secondes, pendant laquelle aucune réponse ne signifie l&#39;échec d&#39;un contrôle de santé.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Cette valeur doit être inférieure à la valeur service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># La valeur par défaut est 5, doit être comprise entre 2 et 60</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups:<span style="color:#bbb"> </span><span style="color:#b44">&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Une liste de groupes de sécurité supplémentaires à ajouter à l&#39;ELB</span></code></pre></div>
<h4 id="aws-nlb-support">Prise en charge du load balancer réseau sur AWS</h4>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.15</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>beta</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="beta">
Cette fonctionnalité est actuellement dans un état <em>beta</em>, c&rsquo;est-à-dire :</p>

<ul>
<li>Les noms de version contiennent: beta (par ex. v2beta3).</li>
<li>Le code est bien testé. L&rsquo;activation de cette fonctionnalité est considérée comme sûre. Elle est activée par défaut.</li>
<li>La prise en charge de l&rsquo;ensemble de la fonctionnalité ne sera pas supprimée, bien que des détails puissent changer.</li>
<li>Le schéma et/ou la sémantique des objets peuvent changer de manière incompatible dans une version bêta ou stable ultérieure. Lorsque cela se produira, nous vous fournirons des instructions pour migrer vers la prochaine version. Cela peut nécessiter la suppression, l&rsquo;édition et la recréation d&rsquo;objets API. Le processus de changement de version peut nécessiter une certaine réflexion. Cela peut aussi nécessiter une interruption de service pour les applications qui s&rsquo;appuient sur cette fonctionnalité.</li>
<li>Recommandé uniquement pour les utilisations non critiques en raison du risque de changements incompatibles dans les versions ultérieures. Si vous avez plusieurs clusters qui peuvent être mis à niveau indépendamment, vous pouvez assouplir cette restriction.</li>
<li>Donnez votre avis sur cette fonctionnalité bêta ! Une fois qu&rsquo;elle aura quitté la version bêta, ce sera probablement moins évident pour nous d&rsquo;apporter d&rsquo;autres changements.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Pour utiliser un load balancer réseau sur AWS, utilisez l&rsquo;annotation <code>service.beta.kubernetes.io/aws-load-balancer-type</code> avec la valeur définie sur <code>nlb</code>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-type:<span style="color:#bbb"> </span><span style="color:#b44">&#34;nlb&#34;</span></code></pre></div>
<blockquote class="note">
  <div><strong>Note:</strong> NLB ne fonctionne qu&rsquo;avec certaines classes d&rsquo;instance; voir la <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets" target="_blank">documentation AWS</a> sur Elastic Load Balancing pour une liste des types d&rsquo;instances pris en charge.</div>
</blockquote>

<p>Contrairement aux équilibreurs de charge élastiques classiques, les équilibreurs de charge réseau (NLB) transfèrent l&rsquo;adresse IP du client jusqu&rsquo;au nœud.
Si un service est <code>.spec.externalTrafficPolicy</code> est réglé sur <code>Cluster</code>, l&rsquo;adresse IP du client n&rsquo;est pas propagée aux pods finaux.</p>

<p>En définissant <code>.spec.externalTrafficPolicy</code> à <code>Local</code>, les adresses IP des clients sont propagées aux pods finaux, mais cela peut entraîner une répartition inégale du trafic.
Les nœuds sans pods pour un service LoadBalancer particulier échoueront au contrôle de santé du groupe cible NLB sur le <code>.spec.healthCheckNodePort</code> attribué automatiquement et ne recevront aucun trafic.</p>

<p>Pour obtenir un trafic uniforme, utilisez un DaemonSet ou spécifiez un <a href="/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity">pod anti-affinity</a> pour ne pas localiser sur le même noeud.</p>

<p>Vous pouvez également utiliser les services NLB avec l&rsquo;annotation <a href="/docs/concepts/services-networking/service/#internal-load-balancer">load balancer internal</a>.</p>

<p>Pour que le trafic client atteigne des instances derrière un NLB, les groupes de sécurité du nœud sont modifiés avec les règles IP suivantes:</p>

<table>
<thead>
<tr>
<th>Rule</th>
<th>Protocol</th>
<th>Port(s)</th>
<th>IpRange(s)</th>
<th>IpRange Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Health Check</td>
<td>TCP</td>
<td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td>
<td>VPC CIDR</td>
<td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName&gt;</td>
</tr>

<tr>
<td>Client Traffic</td>
<td>TCP</td>
<td>NodePort(s)</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName&gt;</td>
</tr>

<tr>
<td>MTU Discovery</td>
<td>ICMP</td>
<td>3,4</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName&gt;</td>
</tr>
</tbody>
</table>

<p>Afin de limiter les IP clientes pouvant accéder à l&rsquo;équilibreur de charge réseau, spécifiez <code>loadBalancerSourceRanges</code>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>loadBalancerSourceRanges:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span><span style="color:#b44">&#34;143.231.0.0/16&#34;</span></code></pre></div>
<blockquote class="note">
  <div><strong>Note:</strong> Si <code>.spec.loadBalancerSourceRanges</code> n&rsquo;est pas défini, Kubernetes autorise le trafic de <code>0.0.0.0/0</code> vers les groupes de sécurité des nœuds.
Si les nœuds ont des adresses IP publiques, sachez que le trafic non NLB peut également atteindre toutes les instances de ces groupes de sécurité modifiés.</div>
</blockquote>

<h4 id="autres-annotations-clb-sur-tencent-kubernetes-engine-tke">Autres annotations CLB sur Tencent Kubernetes Engine (TKE)</h4>

<p>Il existe d&rsquo;autres annotations pour la gestion des équilibreurs de charge cloud sur TKE, comme indiqué ci-dessous.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Lier des load balancers avec des nœuds spécifiques</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/qcloud-loadbalancer-backends-label:<span style="color:#bbb"> </span>key<span style="color:#bbb"> </span>in<span style="color:#bbb"> </span>(value1,<span style="color:#bbb"> </span>value2)<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># ID d&#39;un load balancer existant</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx<span style="color:#bbb">
</span><span style="color:#bbb">        
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Paramètres personnalisés pour le load balancer (LB), ne prend pas encore en charge la modification du type LB</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/service.extensiveParameters:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Paramètres personnalisés pour le listener LB </span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/service.listenerParameters:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Spécifie le type de Load balancer;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># valeurs valides: classic (Classic Cloud Load Balancer) ou application (Application Cloud Load Balancer)</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/loadbalance-type:<span style="color:#bbb"> </span>xxxxx<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Spécifie la méthode de facturation de la bande passante du réseau public;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># valid values: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) and BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/qcloud-loadbalancer-internet-charge-type:<span style="color:#bbb"> </span>xxxxxx<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Spécifie la valeur de bande passante (plage de valeurs: [1,2000] Mbps).</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out:<span style="color:#bbb"> </span><span style="color:#b44">&#34;10&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Lorsque cette annotation est définie, les équilibreurs de charge n&#39;enregistrent que les nœuds sur lesquels le pod s&#39;exécute, sinon tous les nœuds seront enregistrés.</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.kubernetes.io/local-svc-only-bind-node-with-pod:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span></code></pre></div>
<h3 id="externalname">Type ExternalName</h3>

<p>Les services de type ExternalName mappent un service à un nom DNS, et non à un sélecteur standard tel que <code>my-service</code> ou <code>cassandra</code>.
Vous spécifiez ces services avec le paramètre <code>spec.externalName</code>.</p>

<p>Cette définition de service, par exemple, mappe le service <code>my-service</code> dans l&rsquo;espace de noms<code>prod</code> à <code>my.database.example.com</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span>namespace:<span style="color:#bbb"> </span>prod<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>type:<span style="color:#bbb"> </span>ExternalName<span style="color:#bbb">
</span><span style="color:#bbb">  </span>externalName:<span style="color:#bbb"> </span>my.database.example.com</code></pre></div>
<blockquote class="note">
  <div><strong>Note:</strong> ExternalName accepte une chaîne d&rsquo;adresse IPv4, mais en tant que noms DNS composés de chiffres, et non en tant qu&rsquo;adresse IP.
Les noms externes qui ressemblent aux adresses IPv4 ne sont pas résolus par CoreDNS ou ingress-nginx car ExternalName est destiné à spécifier un nom DNS canonique.
Pour coder en dur une adresse IP, pensez à utiliser des <a href="#headless-services">Services headless</a>.</div>
</blockquote>

<p>Lors de la recherche de l&rsquo;hôte <code>my-service.prod.svc.cluster.local</code>, le service DNS du cluster renvoie un enregistrement<code>CNAME</code> avec la valeur <code>my.database.example.com</code>.
L&rsquo;accès à «mon-service» fonctionne de la même manière que les autres services, mais avec la différence cruciale que la redirection se produit au niveau DNS plutôt que via un proxy ou un transfert.
Si vous décidez ultérieurement de déplacer votre base de données dans votre cluster, vous pouvez démarrer ses pods, ajouter des sélecteurs ou des Endpoints appropriés et modifier le <code>type</code> du service.</p>

<blockquote class="warning">
  <div><strong>Attention:</strong> <p>Vous pouvez rencontrer des difficultés à utiliser ExternalName pour certains protocoles courants, notamment HTTP et HTTPS.
Si vous utilisez ExternalName, le nom d&rsquo;hôte utilisé par les clients à l&rsquo;intérieur de votre cluster est différent du nom référencé par ExternalName.</p>

<p>Pour les protocoles qui utilisent des noms d&rsquo;hôtes, cette différence peut entraîner des erreurs ou des réponses inattendues.
Les requêtes HTTP auront un en-tête <code>Host:</code> que le serveur d&rsquo;origine ne reconnaît pas; Les serveurs TLS ne pourront pas fournir de certificat correspondant au nom d&rsquo;hôte auquel le client s&rsquo;est connecté.</p>
</div>
</blockquote>

<blockquote class="note">
  <div><strong>Note:</strong> Cette section est redevable à l&rsquo;article <a href="https://akomljen.com/kubernetes-tips-part-1/" target="_blank">Kubernetes Tips - Part 1</a> d&rsquo;<a href="https://akomljen.com/" target="_blank">Alen Komljen</a>.</div>
</blockquote>

<h3 id="ip-externes">IP externes</h3>

<p>S&rsquo;il existe des adresses IP externes qui acheminent vers un ou plusieurs nœuds de cluster, les services Kubernetes peuvent être exposés sur ces &ldquo;IP externes&rdquo;.
Le trafic qui pénètre dans le cluster avec l&rsquo;IP externe (en tant qu&rsquo;IP de destination), sur le port de service, sera routé vers l&rsquo;un des Endpoints de service.
Les <code>externalIPs</code> ne sont pas gérées par Kubernetes et relèvent de la responsabilité de l&rsquo;administrateur du cluster.</p>

<p>Dans la spécification de service, «externalIPs» peut être spécifié avec n&rsquo;importe lequel des «ServiceTypes».
Dans l&rsquo;exemple ci-dessous, &ldquo;<code>my-service</code>&rdquo; peut être consulté par les clients sur &ldquo;<code>80.11.12.10:80</code>&rdquo; (<code>externalIP:port</code>)</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">      </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">      </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>externalIPs:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span><span style="color:#666">80.11.12.10</span></code></pre></div>
<h2 id="lacunes">Lacunes</h2>

<p>Le proxy fonctionnant dans l&rsquo;espace utilisateur pour les VIP peut fonctionner à petite ou moyenne échelle, mais montrera ses limites dans de très grands clusters avec des milliers de services.
La <a href="http://issue.k8s.io/1107" target="_blank">proposition de conception originale pour les portails</a> a plus de détails à ce sujet.</p>

<p>L&rsquo;utilisation du proxy de l&rsquo;espace utilisateur masque l&rsquo;adresse IP source d&rsquo;un paquet accédant à un service.
Cela rend certains types de filtrage réseau (pare-feu) impossibles.
Le mode proxy iptables n&rsquo;obscurcit pas les adresses IP source dans le cluster, mais il affecte toujours les clients passant par un <code>LoadBalancer</code> ou un <code>NodePort</code>.</p>

<p>Le champ <code>Type</code> est conçu comme une fonctionnalité imbriquée - chaque niveau s&rsquo;ajoute au précédent.
Cela n&rsquo;est pas strictement requis sur tous les fournisseurs de cloud (par exemple, Google Compute Engine n&rsquo;a pas besoin d&rsquo;allouer un <code>NodePort</code> pour faire fonctionner <code>LoadBalancer</code>, mais AWS le fait) mais l&rsquo;API actuelle le requiert.</p>

<h2 id="the-gory-details-of-virtual-ips">Implémentation IP virtuelle</h2>

<p>Les informations précédentes devraient être suffisantes pour de nombreuses personnes qui souhaitent simplement utiliser les Services.
Cependant, il se passe beaucoup de choses dans les coulisses qui méritent d&rsquo;être comprises.</p>

<h3 id="éviter-les-collisions">Éviter les collisions</h3>

<p>L&rsquo;une des principales philosophies de Kubernetes est que vous ne devez pas être exposé à des situations qui pourraient entraîner l&rsquo;échec de vos actions sans aucune faute de votre part.
Pour la conception de la ressource Service, cela signifie de ne pas vous faire choisir votre propre numéro de port si ce choix pourrait entrer en collision avec le choix de quelqu&rsquo;un d&rsquo;autre.
C&rsquo;est un échec d&rsquo;isolement.</p>

<p>Afin de vous permettre de choisir un numéro de port pour vos Services, nous devons nous assurer qu&rsquo;aucun deux Services ne peuvent entrer en collision.
Kubernetes le fait en attribuant à chaque service sa propre adresse IP.</p>

<p>Pour garantir que chaque service reçoit une adresse IP unique, un allocateur interne met à jour atomiquement une carte d&rsquo;allocation globale dans <a class='glossary-tooltip' href='/docs/tasks/administer-cluster/configure-upgrade-etcd/' target='_blank'>etcd<span class='tooltip-text'>Base de données clé-valeur consistante et hautement disponible utilisée comme mémoire de sauvegarde pour toutes les données du cluster.</span>
</a> avant de créer chaque service.
L&rsquo;objet de mappage doit exister dans le registre pour que les services obtiennent des affectations d&rsquo;adresse IP, sinon les créations échoueront avec un message indiquant qu&rsquo;une adresse IP n&rsquo;a pas pu être allouée.</p>

<p>Dans le plan de contrôle, un contrôleur d&rsquo;arrière-plan est responsable de la création de cette carte (nécessaire pour prendre en charge la migration à partir d&rsquo;anciennes versions de Kubernetes qui utilisaient le verrouillage en mémoire).
Kubernetes utilise également des contrôleurs pour vérifier les affectations non valides (par exemple en raison d&rsquo;une intervention de l&rsquo;administrateur) et pour nettoyer les adresses IP allouées qui ne sont plus utilisées par aucun service.</p>

<h3 id="ips-and-vips">Service IP addresses</h3>

<p>Contrairement aux adresses IP des pods, qui acheminent réellement vers une destination fixe, les adresses IP des services ne sont pas réellement répondues par un seul hôte.
Au lieu de cela, kube-proxy utilise iptables (logique de traitement des paquets sous Linux) pour définir les adresses IP <em>virtual</em> qui sont redirigées de manière transparente selon les besoins.
Lorsque les clients se connectent au VIP, leur trafic est automatiquement transporté vers un Endpoint approprié.
Les variables d&rsquo;environnement et DNS pour les services sont en fait remplis en termes d&rsquo;adresse IP virtuelle (et de port) du service.</p>

<p>kube-proxy prend en charge trois modes proxy &mdash; espace utilisateur, iptables et IPVS &mdash; qui fonctionnent chacun légèrement différemment.</p>

<h4 id="userspace">Userspace</h4>

<p>À titre d&rsquo;exemple, considérons l&rsquo;application de traitement d&rsquo;image décrite ci-dessus.
Lorsque le service backend est créé, le maître Kubernetes attribue une adresse IP virtuelle, par exemple 10.0.0.1.
En supposant que le port de service est 1234, le service est observé par toutes les instances kube-proxy dans le cluster.
Lorsqu&rsquo;un proxy voit un nouveau service, il ouvre un nouveau port aléatoire, établit une redirection iptables de l&rsquo;adresse IP virtuelle vers ce nouveau port et commence à accepter les connexions sur celui-ci.</p>

<p>Lorsqu&rsquo;un client se connecte à l&rsquo;adresse IP virtuelle du service, la règle iptables entre en jeu et redirige les paquets vers le propre port du proxy.
Le “Service proxy” choisit un backend, et commence le proxy du trafic du client vers le backend.</p>

<p>Cela signifie que les propriétaires de services peuvent choisir le port de leur choix sans risque de collision.
Les clients peuvent simplement se connecter à une adresse IP et à un port, sans savoir à quels pods ils accèdent réellement.</p>

<h4 id="iptables">iptables</h4>

<p>Considérons à nouveau l&rsquo;application de traitement d&rsquo;image décrite ci-dessus.
Lorsque le service backend est créé, le plan de contrôle Kubernetes attribue une adresse IP virtuelle, par exemple 10.0.0.1.
En supposant que le port de service est 1234, le service est observé par toutes les instances de kube-proxy dans le cluster.
Lorsqu&rsquo;un proxy voit un nouveau service, il installe une série de règles iptables qui redirigent de l&rsquo;adresse IP virtuelle vers des règles par service.
Les règles par service sont liées aux règles des Endpoints qui redirigent le trafic (à l&rsquo;aide du NAT de destination) vers les backends.</p>

<p>Lorsqu&rsquo;un client se connecte à l&rsquo;adresse IP virtuelle du service, la règle iptables entre en jeu.
Un backend est choisi (soit en fonction de l&rsquo;affinité de la session, soit au hasard) et les paquets sont redirigés vers le backend.
Contrairement au proxy de l&rsquo;espace utilisateur, les paquets ne sont jamais copiés dans l&rsquo;espace utilisateur, le proxy de kube n&rsquo;a pas besoin d&rsquo;être exécuté pour que l&rsquo;adresse IP virtuelle fonctionne et les nœuds voient le trafic provenant de l&rsquo;adresse IP du client non modifiée.</p>

<p>Ce même flux de base s&rsquo;exécute lorsque le trafic arrive via un port de nœud ou via un load balancer, bien que dans ces cas, l&rsquo;adresse IP du client soit modifiée.</p>

<h4 id="ipvs">IPVS</h4>

<p>Les opérations iptables ralentissent considérablement dans un cluster à grande échelle, par exemple 10000 services.
IPVS est conçu pour l&rsquo;équilibrage de charge et basé sur des tables de hachage dans le noyau.
Ainsi, vous pouvez obtenir une cohérence des performances dans un grand nombre de services à partir d&rsquo;un kube-proxy basé sur IPVS.
De plus, kube-proxy basé sur IPVS a des algorithmes d&rsquo;équilibrage de charge plus sophistiqués (le moins de connexions, localité, pondéré, persistance).</p>

<h2 id="objet-api">Objet API</h2>

<p>Le service est une ressource de niveau supérieur dans l&rsquo;API REST Kubernetes.
Vous pouvez trouver plus de détails sur l&rsquo;objet API sur: <a href="/docs/reference/generated/kubernetes-api/v1.17/#service-v1-core">Service API object</a>.</p>

<h2 id="protocol-support">Protocoles pris en charge</h2>

<h3 id="tcp">TCP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.0</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
Cette fonctionnalité est <em>stable</em>, ce qui signifie :</p>

<ul>
<li>Le nom de version est vX où X est un entier.</li>
<li>Les versions stables des fonctionnalités seront maintenues pour de nombreuses versions ultérieures.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Vous pouvez utiliser TCP pour tout type de service, et c&rsquo;est le protocole réseau par défaut.</p>

<h3 id="udp">UDP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.0</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
Cette fonctionnalité est <em>stable</em>, ce qui signifie :</p>

<ul>
<li>Le nom de version est vX où X est un entier.</li>
<li>Les versions stables des fonctionnalités seront maintenues pour de nombreuses versions ultérieures.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Vous pouvez utiliser UDP pour la plupart des services.
Pour Services de type LoadBalancer, la prise en charge UDP dépend du fournisseur de cloud offrant cette fonctionnalité.</p>

<h3 id="http">HTTP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.1</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
Cette fonctionnalité est <em>stable</em>, ce qui signifie :</p>

<ul>
<li>Le nom de version est vX où X est un entier.</li>
<li>Les versions stables des fonctionnalités seront maintenues pour de nombreuses versions ultérieures.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Si votre fournisseur de cloud le prend en charge, vous pouvez utiliser un service dans le mode LoadBalancer pour configurer le proxy inverse HTTP / HTTPS externe, transmis au Endpoints du Service.</p>

<blockquote class="note">
  <div><strong>Note:</strong> Vous pouvez aussi utiliser <a class='glossary-tooltip' href='/docs/concepts/services-networking/ingress/' target='_blank'>Ingress<span class='tooltip-text'>Un objet API qui gère l&rsquo;accès externe aux services d&rsquo;un cluster, typiquement HTTP.</span>
</a> à la place du service pour exposer les services HTTP/HTTPS.</div>
</blockquote>

<h3 id="protocole-proxy">Protocole PROXY</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.1</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
Cette fonctionnalité est <em>stable</em>, ce qui signifie :</p>

<ul>
<li>Le nom de version est vX où X est un entier.</li>
<li>Les versions stables des fonctionnalités seront maintenues pour de nombreuses versions ultérieures.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Si votre fournisseur de cloud le prend en charge(eg, <a href="/docs/concepts/cluster-administration/cloud-providers/#aws">AWS</a>), vous pouvez utiliser un service en mode LoadBalancer pour configurer un load balancer en dehors de Kubernetes lui-même, qui transmettra les connexions préfixées par <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" target="_blank">PROXY protocol</a>.</p>

<p>Le load balancer enverra une première série d&rsquo;octets décrivant la connexion entrante, similaire à cet exemple</p>

<pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre>

<p>suivi des données du client.</p>

<h3 id="sctp">SCTP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.12</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>alpha</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="alpha">
Cette fonctionnalité est actuellement dans un état <em>alpha</em>, ce qui signifie :</p>

<ul>
<li>Les noms de version contiennent: alpha (par ex. v1alpha1).</li>
<li>La fonctionnalité peut contenir des bugs. L&rsquo;activation de cette fonctionnalité peut donc vous exposer aux effets de ces bugs. La fonctionnalité est désactivée par défaut.</li>
<li>La prise en charge de cette fonctionnalité peut être supprimée à tout moment sans préavis.</li>
<li>La retro-compatibilité n&rsquo;est pas assurée pour les prochaines versions.</li>
<li>Recommandé pour une utilisation uniquement dans les clusters de test de courte durée, en raison d&rsquo;un risque accru de bugs et d&rsquo;un manque de support à long terme.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Kubernetes prend en charge SCTP en tant que valeur de «protocole» dans les définitions de Service, Endpoint, NetworkPolicy et Pod en tant que fonctionnalité alpha.
Pour activer cette fonction, l&rsquo;administrateur du cluster doit activer le flag <code>SCTPSupport</code> sur l&rsquo;apiserver, par exemple, <code>--feature-gates=SCTPSupport=true,…</code>.</p>

<p>When the feature gate is enabled, you can set the <code>protocol</code> field of a Service, Endpoint, NetworkPolicy or Pod to <code>SCTP</code>.
Kubernetes sets up the network accordingly for the SCTP associations, just like it does for TCP connections.</p>

<h4 id="caveat-sctp-overview">Avertissements</h4>

<h5 id="caveat-sctp-multihomed">Prise en charge des associations SCTP multi-hôtes</h5>

<blockquote class="warning">
  <div><strong>Attention:</strong> <p>La prise en charge des associations SCTP multi-hôtes nécessite que le plug-in CNI puisse prendre en charge l&rsquo;attribution de plusieurs interfaces et adresses IP à un pod.</p>

<p>Le NAT pour les associations SCTP multi-hôtes nécessite une logique spéciale dans les modules de noyau correspondants.</p>
</div>
</blockquote>

<h5 id="caveat-sctp-loadbalancer-service-type">Service avec type=LoadBalancer</h5>

<blockquote class="warning">
  <div><strong>Attention:</strong> Vous ne pouvez créer un service de type LoadBalancer avec SCTP que si le fournisseur de load balancer  supporte SCTP comme protocole.
Sinon, la demande de création de service est rejetée.
L&rsquo;ensemble actuel de fournisseurs de load balancer cloud (Azure, AWS, CloudStack, GCE, OpenStack) ne prennent pas en charge SCTP.</div>
</blockquote>

<h5 id="caveat-sctp-windows-os">Windows</h5>

<blockquote class="warning">
  <div><strong>Attention:</strong> SCTP n&rsquo;est pas pris en charge sur les nœuds Windows.</div>
</blockquote>

<h5 id="caveat-sctp-kube-proxy-userspace">Userspace kube-proxy</h5>

<blockquote class="warning">
  <div><strong>Attention:</strong> Le kube-proxy ne prend pas en charge la gestion des associations SCTP lorsqu&rsquo;il est en mode userspace.</div>
</blockquote>

<h2 id="futurs-développements">Futurs développements</h2>

<p>À l&rsquo;avenir, la stratégie de proxy pour les services peut devenir plus nuancée que le simple équilibrage alterné, par exemple master-elected ou sharded.
Nous prévoyons également que certains services auront des load balancer «réels», auquel cas l&rsquo;adresse IP virtuelle y transportera simplement les paquets.</p>

<p>Le projet Kubernetes vise à améliorer la prise en charge des services L7 (HTTP).</p>

<p>Le projet Kubernetes prévoit d&rsquo;avoir des modes d&rsquo;entrée plus flexibles pour les services, qui englobent les modes ClusterIP, NodePort et LoadBalancer actuels et plus encore.</p>












<h2 id="a-suivre">A suivre</h2>
<ul>
<li>Voir <a href="/docs/concepts/services-networking/connect-applications-service/">Connecting Applications with Services</a></li>
<li>Voir <a href="/docs/concepts/services-networking/ingress/">Ingress</a></li>
<li>Voir <a href="/docs/concepts/services-networking/endpoint-slices/">Endpoint Slices</a></li>
</ul>







    
            
  <h2>Feedback</h2>
  <p class="feedback--prompt">Cette page est elle utile ? </p>
  <button class="button feedback--yes">Oui</button>
  <button class="button feedback--no">Non</button>
  <p class="feedback--response feedback--response__hidden">
    Thanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on
    <a target="_blank" rel="noopener"
      href="https://stackoverflow.com/questions/tagged/kubernetes">
      Stack Overflow</a>.
    Open an issue in the GitHub repo if you want to 
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Issue%20with%20k8s.io">
      report a problem</a>
    or
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Improvement%20for%20k8s.io">
      suggest an improvement</a>.
  </p>
  <script>
    const yes = document.querySelector('.feedback--yes');
    const no = document.querySelector('.feedback--no');
    document.querySelectorAll('.feedback--link').forEach(link => {
      link.href = link.href + window.location.pathname;
    });
    const sendFeedback = (value) => {
      if (!gtag) { console.log('!gtag'); }
      gtag('event', 'click', {
        'event_category': 'Helpful',
        'event_label': window.location.pathname,
        value
      });
    };
    const disableButtons = () => {
      yes.disabled = true;
      yes.classList.add('feedback--button__disabled');
      no.disabled = true;
      no.classList.add('feedback--button__disabled');
    };
    yes.addEventListener('click', () => {
      sendFeedback(1);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
    no.addEventListener('click', () => {
      sendFeedback(0);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
  </script>


    
            <div id="pre-footer"> 
  <hr />

  <div class="issue-button-container">
    <p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/concepts/services-networking/service.md?pixel" alt="Analytics" /></a></p>
    
    
    <script type="text/javascript">
    PDRTJS_settings_8345992 = {
    "id" : "8345992",
    "unique_id" : "\/fr\/docs\/concepts\/services-networking\/service\/",
    "title" : "Service",
    "permalink" : "https:\/\/kubernetes.io\/fr\/docs\/concepts\/services-networking\/service\/"
    };
    (function(d,c,j){if(!document.getElementById(j)){var pd=d.createElement(c),s;pd.id=j;pd.src=('https:'==document.location.protocol)?'https://polldaddy.com/js/rating/rating.js':'http://i0.poll.fm/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd,s);}}(document,'script','pd-rating-js'));
    </script>
    <a href="" onclick="window.open('https://github.com/kubernetes/website/issues/new?template=bug-report.md&title=Issue%20with%20' +
    'k8s.io'+window.location.pathname)" class="button issue">Ouvrez un ticket</a>
    
    
    
    <a href="https://github.com/kubernetes/website/edit/master/content/fr/docs/concepts/services-networking/service.md" class="button issue">Editez cette page</a>
    
  </div>
  

  <div id="lastedit" class="lastedit issue-button-container">
    Dernière modification le January 08, 2020 at 10:13 AM PST de
    <a href="https://github.com/kubernetes/website/commit/a2b023c468dfca72139be2e17c51649668f4123d/">Add French version of Service concept page (#18495)</a> (<a href="https://github.com/kubernetes/website/commits/master/content/en/docs/concepts/services-networking/service.md">Historique</a>)
  </div>
  
</div>

          </div>
        </section>
    </main>
		<footer>
    <div class="light-text main-section">
        <nav>
            
            
            
            <a href="/fr/docs/home/">Accueil</a>
            
            <a href="/fr/blog/">Blog</a>
            
            
            
            <a href="/fr/partners/">Partenaires</a>
            
            <a href="/fr/community/">Communauté</a>
            
            <a href="/fr/case-studies/">Études de cas</a>
            
        </nav>
        <div class="social" role="region" aria-label="Social hyperlinks">
            <div>
                <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                <a href="https://slack.k8s.io/" class="slack"><span>Slack</span></a>
            </div>
            <div>
                <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                <a href="https://discuss.kubernetes.io" class="mailing-list"><span>Forum</span></a>
                <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>Calendrier</span></a>
            </div>
            <div>
                
                <a href="https://git.k8s.io/community/contributors/guide" class="button">Contribuer</a>
            </div>
        </div>
        <div class="miceType center">
            &copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></a>
        </div>
        <div class="miceType center">
            Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a>
        </div>
        <div class="miceType center">
            ICP license: 京ICP备17074266号-3
        </div>
    </div>
</footer>

		<button class="flyout-button" onclick="kub.toggleToc()" aria-label="Toggle table of contents visibility"></button>

<script>

(function () {
    window.addEventListener('DOMContentLoaded', init)

        
        function init() {
            window.removeEventListener('DOMContentLoaded', init)
                hideNav()
        }

    function hideNav(toc){
        if (!toc) toc = document.querySelector('#docsToc')
        if (!toc) return
            var container = toc.querySelector('.container')

                
                if (container) {
                    if (container.childElementCount === 0 || toc.querySelectorAll('a.item').length === 1) {
                        toc.style.display = 'none'
                            document.getElementById('docsContent').style.width = '100%'
                    }
                } else {
                    requestAnimationFrame(function () {
                        hideNav(toc)
                    })
                }
    }
})();
</script>



    <script language="application/javascript">
      
      (function addHeadingLinks(){
        var article = document.getElementById('docsContent');
        var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(function(heading){
          if(heading.id){
            var a = document.createElement('a');
            a.innerHTML = heading.innerHTML;
            a.href = '#'+heading.id;
            a.classList.add('inpage_heading');
            heading.innerHTML = '';
            heading.appendChild(a);
          }
        });
      })();
    </script>
	</body>
</html>
