<!DOCTYPE html>
<html id="docs" lang="zh" class="">
	<head>
	

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>
<meta charset="utf-8">
<title>StatefulSet 基础 - Kubernetes</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#326ce5">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">









<link rel="stylesheet" href="/css/style.b7b8403eb5b1fddd0a2da2a8383d5b53e6ef81c23e4b0e292e6103bd91f9502d.css" integrity="sha256-t7hAPrWx/d0KLaKoOD1bU&#43;bvgcI&#43;Sw4pLmEDvZH5UC0=">


<link rel="stylesheet" href="/css/base_fonts.css">
<link rel="stylesheet" href="/css/jquery-ui.min.css">
<link rel="stylesheet" href="/css/callouts.css">
<link rel="stylesheet" href="/css/custom-jekyll/tags.css">



<meta name="description" content="">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">
<meta property="og:title" content="StatefulSet 基础">
<meta name="twitter:title" content="StatefulSet 基础">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">
<script src="/js/anchor-4.1.1.min.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>
<script src="/js/jquery-ui-1.12.1.min.js"></script>
<script src="/js/bootstrap-4.3.1.min.js"></script>
<script src="/js/sweetalert-2.1.2.min.js"></script>

<script src="/js/script.js"></script>
<script src="/js/custom-jekyll/tags.js"></script>


	</head>
	<body>
		<div id="cellophane" onclick="kub.toggleMenu()"></div>

<header>
    <a href="/zh/" class="logo" title="生产级别的容器编排系统 - Kubernetes" aria-label="Kubernetes website"></a>

    <div class="nav-buttons" data-auto-burger="primary">
        <ul class="global-nav">
            
            
            <li><a href="/zh/docs/" class="active">文档</a></li>
            
            <li><a href="/zh/blog/">博客</a></li>
            
            
            
            <li><a href="/zh/partners/">合作伙伴</a></li>
            
            <li><a href="/zh/community/">社区</a></li>
            
            <li><a href="/zh/case-studies/">案例分析</a></li>
            
            
            
             <li>
                <a href="#">
                    中文 Chinese <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="/docs/tutorials/stateful-application/basic-stateful-set/">English</a></li>
                
                    <li><a href="/ko/docs/tutorials/stateful-application/basic-stateful-set/">한국어 Korean</a></li>
                
                </ul>
            </li>

            <li>
                <a href="#">
                    v1.17 <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">v1.21</a></li>
                
                    <li><a href="https://v1-20.docs.kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">v1.20</a></li>
                
                    <li><a href="https://v1-19.docs.kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">v1.19</a></li>
                
                    <li><a href="https://v1-18.docs.kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">v1.18</a></li>
                
                    <li><a href="https://v1-17.docs.kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">v1.17</a></li>
                
                </ul>
            </li>
        </ul>
        
        <a href="/zh/docs/tutorials/kubernetes-basics/" class="button" id="tryKubernetes" data-auto-burger-exclude>学习 Kubernetes 基础知识</a>
        

        <button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
    </div>

    <nav id="mainNav">
        <div class="main-section" data-auto-burger="primary">
         
           <div class="nav-box">
            <h3><a href="/zh/docs/tutorials/hello-minikube/">Get Started</a></h3>
           <p>Ready to get your hands dirty? Build a simple Kubernetes cluster that runs "Hello World" for Node.js.</p>

            </div>
         
           <div class="nav-box">
            <h3><a href="/zh/docs/home/">文档</a></h3>
           <p>通过演练，示例和参考文档了解如何使用 Kubernetes。你甚至可以<a href="/editdocs/" data-auto-burger-exclude>帮助贡献文档</a>！</p>

            </div>
         
           <div class="nav-box">
            <h3><a href="/zh/blog/">博客</a></h3>
           <p>阅读关于 kubernetes 和容器规范的最新信息,以及获取最新的技术。</p>

            </div>
         
        </div>
        <div class="main-section" data-auto-burger="primary">
            <div class="left">
                <h5 class="github-invite">想要修改 Kubernetes 的核心源代码？</h5>
                <a href="https://github.com/kubernetes/kubernetes" class="button" data-auto-burger-exclude>在 GitHub 上查看</a>
            </div>

            <div class="right">
                <h5 class="github-invite">了解社区</h5>
                <div class="social">
                    <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                    <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                    <a href="http://slack.k8s.io/" class="slack"><span>Slack Slack</span></a>
                    <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                    <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                    <a href="https://discuss.kubernetes.io" class="mailing-list"><span>论坛</span></a>
                    <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>事件日历</span></a>
                </div>
            </div>
            <div class="clear" style="clear: both"></div>
        </div>
    </nav>
</header>

		
		
		<section id="hero" class="light-text no-sub">
			













<h1>教程</h1>
<h5></h5>






<div id="vendorStrip" class="light-text">
	<ul>
		
		
		<li><a href="/zh/docs/home/">主页</a></li>
		
		
		<li><a href="/zh/docs/setup/">入门</a></li>
		
		
		<li><a href="/zh/docs/concepts/">概念</a></li>
		
		
		<li><a href="/zh/docs/tasks/">任务</a></li>
		
		
		<li><a href="/zh/docs/tutorials/" class="YAH">教程</a></li>
		
		
		<li><a href="/zh/docs/reference/">参考</a></li>
		
		
		<li><a href="/zh/docs/contribute/">贡献</a></li>
		
	</ul>
	<form id="searchBox" action="/docs/search/" role="search">
		<input type="text" id="search" name="q" placeholder="搜索" aria-label="Search">
	</form>
</div>

		</section>
		
    
		
<section id="deprecationWarning">
  <main>
    <div class="content deprecation-warning">
      <h3>
	 Kubernetes v1.17
	  版本的文档已不再维护。您现在看到的版本来自于一份静态的快照。如需查阅最新文档，请点击
	 <a href="https://kubernetes.io/docs/home/">最新版本。</a>
      </h3>
    </div>
  </main>
</section>


    <main>
        <section id="encyclopedia">
          
<div id="docsToc">
     <div class="pi-accordion">
    	
        
        
        
        
        
         
             
                 
             
         
             
                 
             
         
             
                 
             
         
             
                 
             
         
             
                 
                          
                          
                 
             
         
             
         
             
         
         
        
        <a class="item" data-title="教程" href="/zh/docs/tutorials/"></a>

	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="你好 Minikube" href="/zh/docs/tutorials/hello-minikube/"></a>

		
	
		
			
<div class="item" data-title="学习 Kubernetes 基础知识">
	<div class="container">
		
		
		
		<a class="item" data-title="学习 Kubernetes 基础知识" href="/zh/docs/tutorials/kubernetes-basics/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="创建集群">
	<div class="container">
		
		
		
		<a class="item" data-title="创建集群" href="/zh/docs/tutorials/kubernetes-basics/create-cluster/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Using Minikube to Create a Cluster" href="/zh/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/"></a>

		
	
		
			

<a class="item" data-title="交互式教程 - 创建集群" href="/zh/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="部署应用">
	<div class="container">
		
		
		
		<a class="item" data-title="部署应用" href="/zh/docs/tutorials/kubernetes-basics/deploy-app/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="使用 kubectl 创建 Deployment" href="/zh/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/"></a>

		
	
		
			

<a class="item" data-title="交互式教程 - 部署应用程序" href="/zh/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="了解你的应用">
	<div class="container">
		
		
		
		<a class="item" data-title="了解你的应用" href="/zh/docs/tutorials/kubernetes-basics/explore/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="查看 pod 和工作节点" href="/zh/docs/tutorials/kubernetes-basics/explore/explore-intro/"></a>

		
	
		
			

<a class="item" data-title="交互式教程-探索您的应用程序" href="/zh/docs/tutorials/kubernetes-basics/explore/explore-interactive/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="公开地暴露你的应用">
	<div class="container">
		
		
		
		<a class="item" data-title="公开地暴露你的应用" href="/zh/docs/tutorials/kubernetes-basics/expose/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Using a Service to Expose Your App" href="/zh/docs/tutorials/kubernetes-basics/expose/expose-intro/"></a>

		
	
		
			

<a class="item" data-title="交互式教程 - 发布您的应用程序" href="/zh/docs/tutorials/kubernetes-basics/expose/expose-interactive/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="伸缩您的应用">
	<div class="container">
		
		
		
		<a class="item" data-title="伸缩您的应用" href="/zh/docs/tutorials/kubernetes-basics/scale/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="运行应用程序的多个实例" href="/zh/docs/tutorials/kubernetes-basics/scale/scale-intro/"></a>

		
	
		
			

<a class="item" data-title="交互教程 - 缩放你的应用程序" href="/zh/docs/tutorials/kubernetes-basics/scale/scale-interactive/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="更新你的应用">
	<div class="container">
		
		
		
		<a class="item" data-title="更新你的应用" href="/zh/docs/tutorials/kubernetes-basics/update/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="执行滚动更新" href="/zh/docs/tutorials/kubernetes-basics/update/update-intro/"></a>

		
	
		
			

<a class="item" data-title="交互式教程 - 更新应用" href="/zh/docs/tutorials/kubernetes-basics/update/update-interactive/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="在线培训课程">
	<div class="container">
		
		
		
		<a class="item" data-title="在线培训课程" href="/zh/docs/tutorials/online-training/"></a>
		
		
	
	
			
			
		
	
	
	
		
			

<a class="item" data-title="Kubernetes 在线培训概述" href="/zh/docs/tutorials/online-training/overview/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="配置">
	<div class="container">
		
		
		
		<a class="item" data-title="配置" href="/zh/docs/tutorials/configuration/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="使用 ConfigMap 来配置 Redis" href="/zh/docs/tutorials/configuration/configure-redis-using-configmap/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="无状态应用程序">
	<div class="container">
		
		
		
		<a class="item" data-title="无状态应用程序" href="/zh/docs/tutorials/stateless-application/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="公开外部 IP 地址以访问集群中应用程序" href="/zh/docs/tutorials/stateless-application/expose-external-ip-address/"></a>

		
	
		
			

<a class="item" data-title="示例：使用 Redis 部署 PHP 留言板应用程序" href="/zh/docs/tutorials/stateless-application/guestbook/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Example: Add logging and metrics to the PHP / Redis Guestbook example <small>(EN)</small>" href="/docs/tutorials/stateless-application/guestbook-logs-metrics-with-elk/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="有状态的应用">
	<div class="container">
		
		
		
		<a class="item" data-title="有状态的应用" href="/zh/docs/tutorials/stateful-application/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="示例：使用 Persistent Volumes 部署 WordPress 和 MySQL" href="/zh/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/"></a>

		
	
		
			

<a class="item" data-title="StatefulSet 基础" href="/zh/docs/tutorials/stateful-application/basic-stateful-set/"></a>

		
	
		
			

<a class="item" data-title="示例：使用 Stateful Sets 部署 Cassandra" href="/zh/docs/tutorials/stateful-application/cassandra/"></a>

		
	
		
			

<a class="item" data-title="运行 ZooKeeper， 一个 CP 分布式系统" href="/zh/docs/tutorials/stateful-application/zookeeper/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="集群">
	<div class="container">
		
		
		
		<a class="item" data-title="集群" href="/zh/docs/tutorials/clusters/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="AppArmor" href="/zh/docs/tutorials/clusters/apparmor/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Services">
	<div class="container">
		
		
		
		<a class="item" data-title="Services" href="/zh/docs/tutorials/services/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="使用 Source IP" href="/zh/docs/tutorials/services/source-ip/"></a>

		
	

	</div>
</div>

		
	





     </div> 
    <button class="push-menu-close-button" onclick="kub.toggleToc()"></button>
</div> 


          <div id="docsContent">
            

<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/zh/docs/tutorials/stateful-application/basic-stateful-set.md" id="editPageButton" target="_blank">
    Edit This Page
  </a>
</p>

<h1>StatefulSet 基础</h1>



<!-- 
This tutorial provides an introduction to managing applications with
[StatefulSets](/docs/concepts/workloads/controllers/statefulset/). It 
demonstrates how to create, delete, scale, and update the Pods of StatefulSets.
-->

<p>本教程介绍如何了使用 <a href="/docs/concepts/abstractions/controllers/statefulsets/">StatefulSets</a> 来管理应用。演示了如何创建、删除、扩容/缩容和更新 StatefulSets 的 Pods。</p>












<ul id="markdown-toc">










<li><a href="#%e6%95%99%e7%a8%8b%e7%9b%ae%e6%a0%87">教程目标</a></li>












<li><a href="#%e5%87%86%e5%a4%87%e5%bc%80%e5%a7%8b">准备开始</a></li>












<li><a href="#%e5%88%9b%e5%bb%ba-statefulset">创建 StatefulSet</a></li>




<li><a href="#statefulset-%e4%b8%ad%e7%9a%84-pod">StatefulSet 中的 Pod</a></li>




<li><a href="#%e6%89%a9%e5%ae%b9-%e7%bc%a9%e5%ae%b9-statefulset">扩容/缩容 StatefulSet</a></li>




<li><a href="#%e6%9b%b4%e6%96%b0-statefulset">更新 StatefulSet</a></li>




<li><a href="#%e5%88%a0%e9%99%a4-statefulset">删除 StatefulSet</a></li>




<li><a href="#pod-%e7%ae%a1%e7%90%86%e7%ad%96%e7%95%a5">Pod 管理策略</a></li>




















<li><a href="#%e6%b8%85%e7%90%86%e7%8e%b0%e5%9c%ba">清理现场</a></li>











</ul>



<h2 id="教程目标">教程目标</h2>
<!-- 
StatefulSets are intended to be used with stateful applications and distributed 
systems. However, the administration of stateful applications and 
distributed systems on Kubernetes is a broad, complex topic. In order to 
demonstrate the basic features of a StatefulSet, and not to conflate the former 
topic with the latter, you will deploy a simple web application using a StatefulSet.

After this tutorial, you will be familiar with the following.

* How to create a StatefulSet
* How a StatefulSet manages its Pods
* How to delete a StatefulSet
* How to scale a StatefulSet
* How to update a StatefulSet's Pods
-->

<p>StatefulSets 旨在与有状态的应用及分布式系统一起使用。然而在 Kubernetes 上管理有状态应用和分布式系统是一个宽泛而复杂的话题。为了演示 StatefulSet 的基本特性，并且不使前后的主题混淆，你将会使用 StatefulSet 部署一个简单的 web 应用。</p>

<p>在阅读本教程后，你将熟悉以下内容：</p>

<ul>
<li>如何创建 StatefulSet</li>
<li>StatefulSet 怎样管理它的 Pods</li>
<li>如何删除 StatefulSet</li>
<li>如何对 StatefulSet 进行扩容/缩容</li>
<li>如何更新一个 StatefulSet 的 Pods</li>
</ul>





<h2 id="准备开始">准备开始</h2>
<!-- 
Before you begin this tutorial, you should familiarize yourself with the 
following Kubernetes concepts.
-->

<p>在开始本教程之前，你应该熟悉以下 Kubernetes 的概念：</p>

<ul>
<li><a href="/docs/user-guide/pods/single-container/">Pods</a></li>
<li><a href="/docs/concepts/services-networking/dns-pod-service/">Cluster DNS</a></li>
<li><a href="/docs/concepts/services-networking/service/#headless-services">Headless Services</a></li>
<li><a href="/docs/concepts/storage/persistent-volumes/">PersistentVolumes</a></li>
<li><a href="https://github.com/kubernetes/examples/tree/v1.17.17/staging/persistent-volume-provisioning/" target="_blank">PersistentVolume Provisioning</a></li>
<li><a href="/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a></li>
<li><a href="/docs/user-guide/kubectl/">kubectl CLI</a></li>
</ul>

<!-- 
This tutorial assumes that your cluster is configured to dynamically provision 
PersistentVolumes. If your cluster is not configured to do so, you
will have to manually provision two 1 GiB volumes prior to starting this 
tutorial.
-->

<p>本教程假设你的集群被配置为动态的提供 PersistentVolumes。如果没有这样配置，在开始本教程之前，你需要手动准备 2 个 1 GiB 的存储卷。</p>




<h2 id="创建-statefulset">创建 StatefulSet</h2>

<p>作为开始，使用如下示例创建一个 StatefulSet。它和 <a href="/docs/concepts/abstractions/controllers/statefulsets/">StatefulSets</a> 概念中的示例相似。它创建了一个 <a href="/docs/user-guide/services/#headless-services">Headless Service</a> <code>nginx</code> 用来发布 StatefulSet <code>web</code> 中的 Pod 的 IP 地址。</p>

<table class="includecode" id="application-web-web-yaml">
    <thead>
        <tr>
            <th>
                <a href="https://raw.githubusercontent.com/kubernetes/website/master/content/zh/examples/application/web/web.yaml" download="application/web/web.yaml">
                    <code>application/web/web.yaml</code>
                </a>
                <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-web-web-yaml')" title="Copy application/web/web.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span>labels:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb">  </span>clusterIP:<span style="color:#bbb"> </span>None<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span>---<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>StatefulSet<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>serviceName:<span style="color:#bbb"> </span><span style="color:#b44">&#34;nginx&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>replicas:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>matchLabels:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span>template:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>labels:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>containers:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span>image:<span style="color:#bbb"> </span>k8s.gcr.io/nginx-slim:<span style="color:#666">0.8</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>-<span style="color:#bbb"> </span>containerPort:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">          </span>name:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb">        </span>volumeMounts:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>www<span style="color:#bbb">
</span><span style="color:#bbb">          </span>mountPath:<span style="color:#bbb"> </span>/usr/share/nginx/html<span style="color:#bbb">
</span><span style="color:#bbb">  </span>volumeClaimTemplates:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>www<span style="color:#bbb">
</span><span style="color:#bbb">    </span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>accessModes:<span style="color:#bbb"> </span>[<span style="color:#bbb"> </span><span style="color:#b44">&#34;ReadWriteOnce&#34;</span><span style="color:#bbb"> </span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span>resources:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>requests:<span style="color:#bbb">
</span><span style="color:#bbb">          </span>storage:<span style="color:#bbb"> </span>1Gi<span style="color:#bbb">
</span><span style="color:#bbb">
</span></code></pre></div>  </td>
        </tr>
    </tbody>
</table>

<!-- 
Download the example above, and save it to a file named `web.yaml`

You will need to use two terminal windows. In the first terminal, use 
[`kubectl get`](/docs/reference/generated/kubectl/kubectl-commands/#get) to watch the creation 
of the StatefulSet's Pods.
-->

<p>下载上面的例子并保存为文件 <code>web.yaml</code>。</p>

<p>你需要使用两个终端窗口。在第一个终端中，使用 <a href="/docs/user-guide/kubectl/v1.17/#get"><code>kubectl get</code></a>  来查看 StatefulSet 的 Pods 的创建情况。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<!--
In the second terminal, use 
[`kubectl apply`](/docs/reference/generated/kubectl/kubectl-commands/#apply) to create the
Headless Service and StatefulSet defined in `web.yaml`.
-->

<p>在另一个终端中，使用 <a href="/docs/reference/generated/kubectl/kubectl-commands/#apply"><code>kubectl apply</code></a>来创建定义在 <code>web.yaml</code> 中的 Headless Service 和 StatefulSet。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f web.yaml
service/nginx created
statefulset.apps/web created</code></pre></div>
<!--
The command above creates two Pods, each running an 
[NGINX](https://www.nginx.com) webserver. Get the `nginx` Service and the 
`web` StatefulSet to verify that they were created successfully.
-->

<p>上面的命令创建了两个 Pod，每个都运行了一个 <a href="https://www.nginx.com" target="_blank">NGINX</a> web 服务器。获取 <code>nginx</code> Service 和 <code>web</code> StatefulSet 来验证是否成功的创建了它们。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get service nginx
NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT<span style="color:#666">(</span>S<span style="color:#666">)</span>   AGE
nginx     ClusterIP    None         &lt;none&gt;        <span style="color:#666">80</span>/TCP    12s

kubectl get statefulset web
NAME      DESIRED   CURRENT   AGE
web       <span style="color:#666">2</span>         <span style="color:#666">1</span>         20s</code></pre></div>
<!--

### Ordered Pod Creation

For a StatefulSet with N replicas, when Pods are being deployed, they are 
created sequentially, in order from {0..N-1}. Examine the output of the 
`kubectl get` command in the first terminal. Eventually, the output will 
look like the example below.
-->

<h3 id="顺序创建-pod">顺序创建 Pod</h3>

<p>对于一个拥有 N 个副本的 StatefulSet，Pod 被部署时是按照 {0 …… N-1} 的序号顺序创建的。在第一个终端中使用 <code>kubectl get</code> 检查输出。这个输出最终将看起来像下面的样子。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>          0s
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         19s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s </code></pre></div>
<!--
Notice that the `web-1` Pod is not launched until the `web-0` Pod is 
[Running and Ready](/docs/user-guide/pod-states). 
-->

<p>请注意在 <code>web-0</code> Pod 处于 <a href="/docs/user-guide/pod-states">Running和Ready</a> 状态后 <code>web-1</code> Pod 才会被启动。</p>

<!--
## Pods in a StatefulSet


Pods in a StatefulSet have a unique ordinal index and a stable network identity.

### Examining the Pod's Ordinal Index

Get the StatefulSet's Pods.
-->

<h2 id="statefulset-中的-pod">StatefulSet 中的 Pod</h2>

<p>StatefulSet 中的 Pod 拥有一个唯一的顺序索引和稳定的网络身份标识。</p>

<h3 id="检查-pod-的顺序索引">检查 Pod 的顺序索引</h3>

<p>获取 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          1m
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          1m</code></pre></div>
<!--
As mentioned in the [StatefulSets](/docs/concepts/workloads/controllers/statefulset/) 
concept, the Pods in a StatefulSet have a sticky, unique identity. This identity 
is based on a unique ordinal index that is assigned to each Pod by the 
StatefulSet controller. The Pods' names take the form 
`<statefulset name>-<ordinal index>`. Since the `web` StatefulSet has two 
replicas, it creates two Pods, `web-0` and `web-1`.

### Using Stable Network Identities

Each Pod has a stable hostname based on its ordinal index. Use
[`kubectl exec`](/docs/reference/generated/kubectl/kubectl-commands/#exec) to execute the 
`hostname` command in each Pod. 
-->

<p>如同 <a href="/docs/concepts/abstractions/controllers/statefulsets/">StatefulSets</a> 概念中所提到的，StatefulSet 中的 Pod 拥有一个具有黏性的、独一无二的身份标志。这个标志基于 StatefulSet 控制器分配给每个 Pod 的唯一顺序索引。Pod 的名称的形式为<code>&lt;statefulset name&gt;-&lt;ordinal index&gt;</code>。<code>web</code>StatefulSet 拥有两个副本，所以它创建了两个 Pod：<code>web-0</code>和<code>web-1</code>。</p>

<h3 id="使用稳定的网络身份标识">使用稳定的网络身份标识</h3>

<p>每个 Pod 都拥有一个基于其顺序索引的稳定的主机名。使用<a href="/docs/reference/generated/kubectl/kubectl-commands/#exec"><code>kubectl exec</code></a>在每个 Pod 中执行<code>hostname</code>。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> web-<span style="color:#b8860b">$i</span> -- sh -c <span style="color:#b44">&#39;hostname&#39;</span>; <span style="color:#a2f;font-weight:bold">done</span>
web-0
web-1</code></pre></div>
<!-- 
Use [`kubectl run`](/docs/reference/generated/kubectl/kubectl-commands/#run) to execute 
a container that provides the `nslookup` command from the `dnsutils` package. 
Using `nslookup` on the Pods' hostnames, you can examine their in-cluster DNS 
addresses.
-->

<p>使用 <a href="/docs/reference/generated/kubectl/kubectl-commands/#run"><code>kubectl run</code></a> 运行一个提供 <code>nslookup</code> 命令的容器，该命令来自于 <code>dnsutils</code> 包。通过对 Pod 的主机名执行 <code>nslookup</code>，你可以检查他们在集群内部的 DNS 地址。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run -i --tty --image busybox:1.28 dns-test --restart<span style="color:#666">=</span>Never --rm   
nslookup web-0.nginx
Server:    <span style="color:#666">10</span>.0.0.10
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.244.1.6

nslookup web-1.nginx
Server:    <span style="color:#666">10</span>.0.0.10
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.244.2.6</code></pre></div>
<!--
The CNAME of the headless service points to SRV records (one for each Pod that 
is Running and Ready). The SRV records point to A record entries that 
contain the Pods' IP addresses. 

In one terminal, watch the StatefulSet's Pods.  
-->

<p>headless service 的 CNAME 指向 SRV 记录（记录每个 Running 和 Ready 状态的 Pod）。SRV 记录指向一个包含 Pod IP 地址的记录表项。</p>

<p>在一个终端中查看 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<!--
In a second terminal, use
[`kubectl delete`](/docs/reference/generated/kubectl/kubectl-commands/#delete) to delete all 
the Pods in the StatefulSet.
-->

<p>在另一个终端中使用 <a href="/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> 删除 StatefulSet 中所有的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
pod <span style="color:#b44">&#34;web-0&#34;</span> deleted
pod <span style="color:#b44">&#34;web-1&#34;</span> deleted</code></pre></div>
<!--
Wait for the StatefulSet to restart them, and for both Pods to transition to 
Running and Ready.
-->

<p>等待 StatefulSet 重启它们，并且两个 Pod 都变成 Running 和 Ready 状态。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS              RESTARTS   AGE
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          2s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         34s</code></pre></div>
<!--
Use `kubectl exec` and `kubectl run` to view the Pods hostnames and in-cluster 
DNS entries.
-->

<p>使用 <code>kubectl exec</code> 和 <code>kubectl run</code> 查看 Pod 的主机名和集群内部的 DNS 表项。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> web-<span style="color:#b8860b">$i</span> -- sh -c <span style="color:#b44">&#39;hostname&#39;</span>; <span style="color:#a2f;font-weight:bold">done</span>
web-0
web-1

kubectl run -i --tty --image busybox:1.28 dns-test --restart<span style="color:#666">=</span>Never --rm /bin/sh 
nslookup web-0.nginx
Server:    <span style="color:#666">10</span>.0.0.10
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.244.1.7

nslookup web-1.nginx
Server:    <span style="color:#666">10</span>.0.0.10
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address <span style="color:#666">1</span>: <span style="color:#666">10</span>.244.2.8</code></pre></div>
<!--
The Pods' ordinals, hostnames, SRV records, and A record names have not changed, 
but the IP addresses associated with the Pods may have changed. In the cluster 
used for this tutorial, they have. This is why it is important not to configure 
other applications to connect to Pods in a StatefulSet by IP address.


If you need to find and connect to the active members of a StatefulSet, you 
should query the CNAME of the Headless Service 
(`nginx.default.svc.cluster.local`). The SRV records associated with the 
CNAME will contain only the Pods in the StatefulSet that are Running and 
Ready.

If your application already implements connection logic that tests for 
liveness and readiness, you can use the SRV records of the Pods ( 
`web-0.nginx.default.svc.cluster.local`,
`web-1.nginx.default.svc.cluster.local`), as they are stable, and your 
application will be able to discover the Pods' addresses when they transition 
to Running and Ready.
-->

<p>Pod 的序号、主机名、SRV 条目和记录名称没有改变，但和 Pod 相关联的 IP 地址可能发生了改变。在本教程中使用的集群中它们就改变了。这就是为什么不要在其他应用中使用 StatefulSet 中的 Pod 的 IP 地址进行连接，这点很重要。</p>

<p>如果你需要查找并连接一个 StatefulSet 的活动成员，你应该查询 Headless Service 的 CNAME。和 CNAME 相关联的 SRV 记录只会包含 StatefulSet 中处于 Running 和 Ready 状态的 Pod。</p>

<p>如果你的应用已经实现了用于测试 liveness 和 readiness 的连接逻辑，你可以使用 Pod 的 SRV 记录（<code>web-0.nginx.default.svc.cluster.local</code>，
<code>web-1.nginx.default.svc.cluster.local</code>）。因为他们是稳定的，并且当你的 Pod 的状态变为 Running 和 Ready 时，你的应用就能够发现它们的地址。</p>

<!--
### Writing to Stable Storage

Get the PersistentVolumeClaims for `web-0` and `web-1`.
-->

<h3 id="写入稳定的存储">写入稳定的存储</h3>

<p>获取 <code>web-0</code> 和 <code>web-1</code> 的 PersistentVolumeClaims。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pvc -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s</code></pre></div>
<!--
The StatefulSet controller created two PersistentVolumeClaims that are 
bound to two [PersistentVolumes](/docs/concepts/storage/persistent-volumes/). As the cluster used in this tutorial is configured to dynamically provision 
PersistentVolumes, the PersistentVolumes were created and bound automatically.

The NGINX webservers, by default, will serve an index file at 
`/usr/share/nginx/html/index.html`. The `volumeMounts` field in the 
StatefulSets `spec` ensures that the `/usr/share/nginx/html` directory is 
backed by a PersistentVolume.

Write the Pods' hostnames to their `index.html` files and verify that the NGINX 
webservers serve the hostnames.
-->

<p>StatefulSet 控制器创建了两个 PersistentVolumeClaims，绑定到两个 <a href="/docs/concepts/storage/volumes/">PersistentVolumes</a>。由于本教程使用的集群配置为动态提供 PersistentVolume，所有的 PersistentVolume 都是自动创建和绑定的。</p>

<p>NGINX web 服务器默认会加载位于 <code>/usr/share/nginx/html/index.html</code> 的 index 文件。StatefulSets <code>spec</code> 中的 <code>volumeMounts</code> 字段保证了 <code>/usr/share/nginx/html</code> 文件夹由一个 PersistentVolume 支持。</p>

<p>将 Pod 的主机名写入它们的<code>index.html</code>文件并验证 NGINX web 服务器使用该主机名提供服务。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> web-<span style="color:#b8860b">$i</span> -- sh -c <span style="color:#b44">&#39;echo $(hostname) &gt; /usr/share/nginx/html/index.html&#39;</span>; <span style="color:#a2f;font-weight:bold">done</span>

<span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> -it web-<span style="color:#b8860b">$i</span> -- curl localhost; <span style="color:#a2f;font-weight:bold">done</span>
web-0
web-1</code></pre></div>
<blockquote class="note">
  <div><strong>注意：</strong> <!--
If you instead see 403 Forbidden responses for the above curl command,
you will need to fix the permissions of the directory mounted by the `volumeMounts`
(due to a [bug when using hostPath volumes](https://github.com/kubernetes/kubernetes/issues/2630)) with:
-->

<p>请注意，如果你看见上面的 curl 命令返回了 403 Forbidden 的响应，你需要像这样修复使用 <code>volumeMounts</code>（due to a <a href="https://github.com/kubernetes/kubernetes/issues/2630" target="_blank">bug when using hostPath volumes</a>）挂载的目录的权限：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> web-<span style="color:#b8860b">$i</span> -- chmod <span style="color:#666">755</span> /usr/share/nginx/html; <span style="color:#a2f;font-weight:bold">done</span></code></pre></div>
<!--
before retrying the curl command above.
-->

<p>在你重新尝试上面的 curl 命令之前。</p>
</div>
</blockquote>

<!--
In one terminal, watch the StatefulSet's Pods.
-->

<p>在一个终端查看 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<!--
In a second terminal, delete all of the StatefulSet's Pods.
-->

<p>在另一个终端删除 StatefulSet 所有的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
pod <span style="color:#b44">&#34;web-0&#34;</span> deleted
pod <span style="color:#b44">&#34;web-1&#34;</span> deleted</code></pre></div>
<!--
Examine the output of the `kubectl get` command in the first terminal, and wait 
for all of the Pods to transition to Running and Ready.
-->

<p>在第一个终端里检查 <code>kubectl get</code> 命令的输出，等待所有 Pod 变成 Running 和 Ready 状态。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS              RESTARTS   AGE
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          2s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         34s</code></pre></div>
<!--
Verify the web servers continue to serve their hostnames.
-->

<p>验证所有 web 服务器在继续使用它们的主机名提供服务。</p>

<pre><code>for i in 0 1; do kubectl exec -it web-$i -- curl localhost; done
web-0
web-1
</code></pre>

<!--
Even though `web-0` and `web-1` were rescheduled, they continue to serve their 
hostnames because the PersistentVolumes associated with their 
PersistentVolumeClaims are remounted to their `volumeMounts`. No matter what 
node `web-0`and `web-1` are scheduled on, their PersistentVolumes will be 
mounted to the appropriate mount points.

## Scaling a StatefulSet
Scaling a StatefulSet refers to increasing or decreasing the number of replicas. 
This is accomplished by updating the `replicas` field. You can use either
[`kubectl scale`](/docs/reference/generated/kubectl/kubectl-commands/#scale) or
[`kubectl patch`](/docs/reference/generated/kubectl/kubectl-commands/#patch) to scale a StatefulSet.

### Scaling Up

In one terminal window, watch the Pods in the StatefulSet.
-->

<p>虽然 <code>web-0</code> 和 <code>web-1</code> 被重新调度了，但它们仍然继续监听各自的主机名，因为和它们的 PersistentVolumeClaim 相关联的 PersistentVolume 被重新挂载到了各自的 <code>volumeMount</code> 上。不管 <code>web-0</code> 和 <code>web-1</code> 被调度到了哪个节点上，它们的 PersistentVolumes 将会被挂载到合适的挂载点上。</p>

<h2 id="扩容-缩容-statefulset">扩容/缩容 StatefulSet</h2>

<p>扩容/缩容 StatefulSet 指增加或减少它的副本数。这通过更新 <code>replicas</code> 字段完成。你可以使用<a href="/docs/user-guide/kubectl/v1.17/#scale"><code>kubectl scale</code></a> 或者<a href="/docs/user-guide/kubectl/v1.17/#patch"><code>kubectl patch</code></a>来扩容/缩容一个 StatefulSet。</p>

<h3 id="扩容">扩容</h3>

<p>在一个终端窗口观察 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<!--
In another terminal window, use `kubectl scale` to scale the number of replicas 
to 5.-->

<p>在另一个终端窗口使用 <code>kubectl scale</code> 扩展副本数为 5。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl scale sts web --replicas<span style="color:#666">=</span><span style="color:#666">5</span>
statefulset.apps/web scaled</code></pre></div>
<!--
Examine the output of the `kubectl get` command in the first terminal, and wait 
for the three additional Pods to transition to Running and Ready.
-->

<p>在第一个 终端中检查 <code>kubectl get</code> 命令的输出，等待增加的 3 个 Pod 的状态变为 Running 和 Ready。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          2h
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          2h
NAME      READY     STATUS    RESTARTS   AGE
web-2     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>          0s
web-2     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-2     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         19s
web-3     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-3     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-3     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-3     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s
web-4     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-4     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-4     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-4     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         19s</code></pre></div>
<!--
The StatefulSet controller scaled the number of replicas. As with
[StatefulSet creation](#ordered-pod-creation), the StatefulSet controller
created each Pod sequentially with respect to its ordinal index, and it 
waited for each Pod's predecessor to be Running and Ready before launching the 
subsequent Pod.

### Scaling Down

In one terminal, watch the StatefulSet's Pods.
-->

<p>StatefulSet 控制器扩展了副本的数量。如同<a href="#顺序创建pod">创建 StatefulSet</a> 所述，StatefulSet 按序号索引顺序的创建每个 Pod，并且会等待前一个 Pod 变为 Running 和 Ready 才会启动下一个 Pod。</p>

<h3 id="缩容">缩容</h3>

<p>在一个终端观察 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<!--
In another terminal, use `kubectl patch` to scale the StatefulSet back down to 
three replicas. 
-->

<p>在另一个终端使用 <code>kubectl patch</code> 将 StatefulSet 缩容回三个副本。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch sts web -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;replicas&#34;:3}}&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
Wait for `web-4` and `web-3` to transition to Terminating.
-->

<p>等待 <code>web-4</code> 和 <code>web-3</code> 状态变为 Terminating。</p>

<pre><code>kubectl get pods -w -l app=nginx
NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3h
web-1     1/1       Running             0          3h
web-2     1/1       Running             0          55s
web-3     1/1       Running             0          36s
web-4     0/1       ContainerCreating   0          18s
NAME      READY     STATUS    RESTARTS   AGE
web-4     1/1       Running   0          19s
web-4     1/1       Terminating   0         24s
web-4     1/1       Terminating   0         24s
web-3     1/1       Terminating   0         42s
web-3     1/1       Terminating   0         42s
</code></pre>

<!--
### Ordered Pod Termination

The controller deleted one Pod at a time, in reverse order with respect to its 
ordinal index, and it waited for each to be completely shutdown before 
deleting the next.

Get the StatefulSet's PersistentVolumeClaims. 
-->

<h3 id="顺序终止-pod">顺序终止 Pod</h3>

<p>控制器会按照与 Pod 序号索引相反的顺序每次删除一个 Pod。在删除下一个 Pod 前会等待上一个被完全关闭。</p>

<p>获取 StatefulSet 的 PersistentVolumeClaims。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pvc -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-2   Bound     pvc-e1125b27-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-3   Bound     pvc-e1176df6-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-4   Bound     pvc-e11bb5f8-b508-11e6-932f-42010a800002   1Gi        RWO           13h</code></pre></div>
<!--
There are still five PersistentVolumeClaims and five PersistentVolumes. 
When exploring a Pod's [stable storage](#writing-to-stable-storage), we saw that the PersistentVolumes mounted to the Pods of a StatefulSet are not deleted when the StatefulSet's Pods are deleted. This is still true when Pod deletion is caused by scaling the StatefulSet down. 

## Updating StatefulSets

In Kubernetes 1.7 and later, the StatefulSet controller supports automated updates.  The 
strategy used is determined by the `spec.updateStrategy` field of the 
StatefulSet API Object. This feature can be used to upgrade the container 
images, resource requests and/or limits, labels, and annotations of the Pods in a 
StatefulSet. There are two valid update strategies, `RollingUpdate` and 
`OnDelete`.

`RollingUpdate` update strategy is the default for StatefulSets.
-->

<p>五个 PersistentVolumeClaims 和五个 PersistentVolumes 仍然存在。查看 Pod 的 <a href="#stable-storage">稳定存储</a>，我们发现当删除 StatefulSet 的 Pod 时，挂载到 StatefulSet 的 Pod 的 PersistentVolumes 不会被删除。当这种删除行为是由 StatefulSet 缩容引起时也是一样的。</p>

<h2 id="更新-statefulset">更新 StatefulSet</h2>

<p>Kubernetes 1.7 版本的 StatefulSet 控制器支持自动更新。更新策略由 StatefulSet API Object 的<code>spec.updateStrategy</code> 字段决定。这个特性能够用来更新一个 StatefulSet 中的 Pod 的 container images，resource requests，以及 limits，labels 和 annotations。<code>RollingUpdate</code>滚动更新是 StatefulSets 默认策略。</p>

<!--
The `RollingUpdate` update strategy will update all Pods in a StatefulSet, in 
reverse ordinal order, while respecting the StatefulSet guarantees.

Patch the `web` StatefulSet to apply the `RollingUpdate` update strategy.
-->

<h3 id="rolling-update-策略">Rolling Update 策略</h3>

<p><code>RollingUpdate</code> 更新策略会更新一个 StatefulSet 中所有的 Pod，采用与序号索引相反的顺序并遵循 StatefulSet 的保证。</p>

<p>Patch <code>web</code> StatefulSet 来执行 <code>RollingUpdate</code> 更新策略。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch statefulset web -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;}}}&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
In one terminal window, patch the `web` StatefulSet to change the container 
image again.
-->

<p>在一个终端窗口中 patch <code>web</code> StatefulSet 来再次的改变容器镜像。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch statefulset web --type<span style="color:#666">=</span><span style="color:#b44">&#39;json&#39;</span> -p<span style="color:#666">=</span><span style="color:#b44">&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;gcr.io/google_containers/nginx-slim:0.8&#34;}]&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
In another terminal, watch the Pods in the StatefulSet.
-->

<p>在另一个终端监控 StatefulSet 中的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx -w
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          7m
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          7m
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          8m
web-2     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-2     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-2     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-2     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-2     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         19s
web-1     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         8m
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         6s
web-0     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         7m
web-0     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         7m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         7m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         7m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         7m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         7m
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         10s</code></pre></div>
<!--
The Pods in the StatefulSet are updated in reverse ordinal order. The 
StatefulSet controller terminates each Pod, and waits for it to transition to Running and 
Ready prior to updating the next Pod. Note that, even though the StatefulSet 
controller will not proceed to update the next Pod until its ordinal successor 
is Running and Ready, it will restore any Pod that fails during the update to 
its current version. Pods that have already received the update will be 
restored to the updated version, and Pods that have not yet received the 
update will be restored to the previous version. In this way, the controller 
attempts to continue to keep the application healthy and the update consistent 
in the presence of intermittent failures.

Get the Pods to view their container images.
-->

<p>StatefulSet 里的 Pod 采用和序号相反的顺序更新。在更新下一个 Pod 前，StatefulSet 控制器终止每个 Pod 并等待它们变成 Running 和 Ready。请注意，虽然在顺序后继者变成 Running 和 Ready 之前 StatefulSet 控制器不会更新下一个 Pod，但它仍然会重建任何在更新过程中发生故障的 Pod，使用的是它们当前的版本。已经接收到更新请求的 Pod 将会被恢复为更新的版本，没有收到请求的 Pod 则会被恢复为之前的版本。像这样，控制器尝试继续使应用保持健康并在出现间歇性故障时保持更新的一致性。</p>

<p>获取 Pod 来查看他们的容器镜像。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> p in <span style="color:#666">0</span> <span style="color:#666">1</span> <span style="color:#666">2</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl get po web-<span style="color:#b8860b">$p</span> --template <span style="color:#b44">&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>; echo; <span style="color:#a2f;font-weight:bold">done</span>
k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8</code></pre></div>
<!--
All the Pods in the StatefulSet are now running the previous container image.

**Tip** You can also use `kubectl rollout status sts/<name>` to view 
the status of a rolling update.

#### Staging an Update
You can stage an update to a StatefulSet by using the `partition` parameter of 
the `RollingUpdate` update strategy. A staged update will keep all of the Pods 
in the StatefulSet at the current version while allowing mutations to the 
StatefulSet's `.spec.template`.

Patch the `web` StatefulSet to add a partition to the `updateStrategy` field.
-->

<p>StatefulSet 中的所有 Pod 现在都在运行之前的容器镜像。</p>

<p><strong>小窍门</strong>：你还可以使用 <code>kubectl rollout status sts/&lt;name&gt;</code> 来查看 rolling update 的状态。</p>

<h4 id="分段更新">分段更新</h4>

<p>你可以使用 <code>RollingUpdate</code> 更新策略的 <code>partition</code> 参数来分段更新一个 StatefulSet。分段的更新将会使 StatefulSet 中的其余所有 Pod 保持当前版本的同时仅允许改变 StatefulSet 的  <code>.spec.template</code>。</p>

<p>Patch <code>web</code> StatefulSet 来对 <code>updateStrategy</code> 字段添加一个分区。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch statefulset web -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:3}}}}&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
Patch the StatefulSet again to change the container's image.
-->

<p>再次 Patch StatefulSet 来改变容器镜像。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch statefulset web --type<span style="color:#666">=</span><span style="color:#b44">&#39;json&#39;</span> -p<span style="color:#666">=</span><span style="color:#b44">&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;k8s.gcr.io/nginx-slim:0.7&#34;}]&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
Delete a Pod in the StatefulSet.
-->

<p>删除 StatefulSet 中的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete po web-2
pod <span style="color:#b44">&#34;web-2&#34;</span> deleted</code></pre></div>
<!--
Wait for the Pod to be Running and Ready.
-->

<p>等待 Pod 变成 Running 和 Ready。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -lapp<span style="color:#666">=</span>nginx -w
NAME      READY     STATUS              RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running             <span style="color:#666">0</span>          4m
web-1     <span style="color:#666">1</span>/1       Running             <span style="color:#666">0</span>          4m
web-2     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>          11s
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s</code></pre></div>
<!--
Get the Pod's container.
-->

<p>获取 Pod 的容器。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po web-2 --template <span style="color:#b44">&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
k8s.gcr.io/nginx-slim:0.8</code></pre></div>
<!--
Notice that, even though the update strategy is `RollingUpdate` the StatefulSet 
controller restored the Pod with its original container. This is because the 
ordinal of the Pod is less than the `partition` specified by the 
`updateStrategy`.

#### Rolling Out a Canary
You can roll out a canary to test a modification by decrementing the `partition` 
you specified [above](#staging-an-update).

Patch the StatefulSet to decrement the partition.
-->

<p>请注意，虽然更新策略是 <code>RollingUpdate</code>，StatefulSet 控制器还是会使用原始的容器恢复 Pod。这是因为 Pod 的序号比 <code>updateStrategy</code> 指定的 <code>partition</code> 更小。</p>

<h4 id="灰度扩容">灰度扩容</h4>

<p>你可以通过减少 <a href="#分段更新">上文</a>指定的 <code>partition</code> 来进行灰度扩容，以此来测试你的程序的改动。</p>

<p>Patch StatefulSet 来减少分区。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch statefulset web -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:2}}}}&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
Wait for `web-2` to be Running and Ready.
-->

<p>等待 <code>web-2</code> 变成 Running 和 Ready。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -lapp<span style="color:#666">=</span>nginx -w
NAME      READY     STATUS              RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running             <span style="color:#666">0</span>          4m
web-1     <span style="color:#666">1</span>/1       Running             <span style="color:#666">0</span>          4m
web-2     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>          11s
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s</code></pre></div>
<!--
Get the Pod's container.
-->

<p>获取 Pod 的容器。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po web-2 --template <span style="color:#b44">&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
k8s.gcr.io/nginx-slim:0.7</code></pre></div>
<!--
When you changed the `partition`, the StatefulSet controller automatically 
updated the `web-2` Pod because the Pod's ordinal was greater than or equal to 
the `partition`.

Delete the `web-1` Pod.
-->

<p>当你改变 <code>partition</code> 时，StatefulSet 会自动的更新 <code>web-2</code> Pod，这是因为 Pod 的序号小于或等于 <code>partition</code>。</p>

<p>删除 <code>web-1</code> Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete po web-1
pod <span style="color:#b44">&#34;web-1&#34;</span> deleted</code></pre></div>
<!--
Wait for the `web-1` Pod to be Running and Ready.
-->

<p>等待 <code>web-1</code> 变成 Running 和 Ready。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -lapp<span style="color:#666">=</span>nginx -w
NAME      READY     STATUS        RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running       <span style="color:#666">0</span>          6m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>          6m
web-2     <span style="color:#666">1</span>/1       Running       <span style="color:#666">0</span>          2m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         6m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         6m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         6m
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s</code></pre></div>
<!--
Get the `web-1` Pods container.
-->

<p>获取 <code>web-1</code> Pod 的容器。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po web-1 --template <span style="color:#b44">&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
k8s.gcr.io/nginx-slim:0.8</code></pre></div>
<!--
`web-1` was restored to its original configuration because the Pod's ordinal 
was less than the partition. When a partition is specified, all Pods with an 
ordinal that is greater than or equal to the partition will be updated when the 
StatefulSet's `.spec.template` is updated. If a Pod that has an ordinal less 
than the partition is deleted or otherwise terminated, it will be restored to 
its original configuration.

#### Phased Roll Outs
You can perform a phased roll out (e.g. a linear, geometric, or exponential
roll out) using a partitioned rolling update in a similar manner to how you 
rolled out a [canary](#rolling-out-a-canary). To perform a phased roll out, set 
the `partition` to the ordinal at which you want the controller to pause the 
update. 

The partition is currently set to `2`. Set the partition to `0`.
-->

<p><code>web-1</code> 被按照原来的配置恢复，因为 Pod 的序号小于分区。当指定了分区时，如果更新了 StatefulSet 的 <code>.spec.template</code>，则所有序号大于或等于分区的 Pod 都将被更新。如果一个序号小于分区的 Pod 被删除或者终止，它将被按照原来的配置恢复。</p>

<h4 id="分阶段的扩容">分阶段的扩容</h4>

<p>你可以使用类似<a href="#灰度扩容">灰度扩容</a>的方法执行一次分阶段的扩容（例如一次线性的、等比的或者指数形式的扩容）。要执行一次分阶段的扩容，你需要设置 <code>partition</code> 为希望控制器暂停更新的序号。</p>

<p>分区当前为<code>2</code>。请将分区设置为<code>0</code>。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl patch statefulset web -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:0}}}}&#39;</span>
statefulset.apps/web patched</code></pre></div>
<!--
Wait for all of the Pods in the StatefulSet to become Running and Ready.
-->

<p>等待 StatefulSet 中的所有 Pod 变成 Running 和 Ready。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -lapp<span style="color:#666">=</span>nginx -w
NAME      READY     STATUS              RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running             <span style="color:#666">0</span>          3m
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>          11s
web-2     <span style="color:#666">1</span>/1       Running             <span style="color:#666">0</span>          2m
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s
web-0     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-0     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         3s</code></pre></div>
<!--
Get the Pod's containers.
-->

<p>获取 Pod 的容器。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> p in <span style="color:#666">0</span> <span style="color:#666">1</span> <span style="color:#666">2</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl get po web-<span style="color:#b8860b">$p</span> --template <span style="color:#b44">&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>; echo; <span style="color:#a2f;font-weight:bold">done</span>
k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7</code></pre></div>
<!--
By moving the `partition` to `0`, you allowed the StatefulSet controller to 
continue the update process.

### On Delete

The `OnDelete` update strategy implements the legacy (1.6 and prior) behavior, 
When you select this update strategy, the StatefulSet controller will not 
automatically update Pods when a modification is made to the StatefulSet's 
`.spec.template` field. This strategy can be selected by setting the 
`.spec.template.updateStrategy.type` to `OnDelete`.


## Deleting StatefulSets

StatefulSet supports both Non-Cascading and Cascading deletion. In a 
Non-Cascading Delete, the StatefulSet's Pods are not deleted when the StatefulSet is deleted. In a Cascading Delete, both the StatefulSet and its Pods are 
deleted.

### Non-Cascading Delete

In one terminal window, watch the Pods in the StatefulSet.
-->

<p>将 <code>partition</code> 改变为 <code>0</code> 以允许 StatefulSet 控制器继续更新过程。</p>

<h3 id="on-delete-策略">On Delete 策略</h3>

<p><code>OnDelete</code> 更新策略实现了传统（1.7 之前）行为，它也是默认的更新策略。当你选择这个更新策略并修改 StatefulSet 的 <code>.spec.template</code> 字段时，StatefulSet 控制器将不会自动的更新 Pod。</p>

<h2 id="删除-statefulset">删除 StatefulSet</h2>

<p>StatefulSet 同时支持级联和非级联删除。使用非级联方式删除 StatefulSet 时，StatefulSet 的 Pod 不会被删除。使用级联删除时，StatefulSet 和它的 Pod 都会被删除。</p>

<h3 id="非级联删除">非级联删除</h3>

<p>在一个终端窗口查看 StatefulSet 中的 Pod。</p>

<pre><code>kubectl get pods -w -l app=nginx
</code></pre>

<!--
Use [`kubectl delete`](/docs/reference/generated/kubectl/kubectl-commands/#delete) to delete the 
StatefulSet. Make sure to supply the `--cascade=false` parameter to the 
command. This parameter tells Kubernetes to only delete the StatefulSet, and to 
not delete any of its Pods.
-->

<p>使用 <a href="/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> 删除 StatefulSet。请确保提供了 <code>--cascade=false</code> 参数给命令。这个参数告诉 Kubernetes 只删除 StatefulSet 而不要删除它的任何 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete statefulset web --cascade<span style="color:#666">=</span><span style="color:#a2f">false</span>
statefulset.apps <span style="color:#b44">&#34;web&#34;</span> deleted</code></pre></div>
<!--
Get the Pods to examine their status.
-->

<p>获取 Pod 来检查他们的状态。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          6m
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          7m
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          5m</code></pre></div>
<!--
Even though `web` has been deleted, all of the Pods are still Running and Ready.
Delete `web-0`.
-->

<p>虽然 <code>web</code>  已经被删除了，但所有 Pod 仍然处于 Running 和 Ready 状态。
删除 <code>web-0</code>。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod web-0
pod <span style="color:#b44">&#34;web-0&#34;</span> deleted</code></pre></div>
<!--
Get the StatefulSet's Pods.
-->

<p>获取 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          10m
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          7m</code></pre></div>
<!--
As the `web` StatefulSet has been deleted, `web-0` has not been relaunched.

In one terminal, watch the StatefulSet's Pods.
-->

<p>由于 <code>web</code> StatefulSet 已经被删除，<code>web-0</code>没有被重新启动。</p>

<p>在一个终端监控 StatefulSet 的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<!--
In a second terminal, recreate the StatefulSet. Note that, unless
you deleted the `nginx` Service ( which you should not have ), you will see 
an error indicating that the Service already exists.
-->

<p>在另一个终端里重新创建 StatefulSet。请注意，除非你删除了 <code>nginx</code> Service （你不应该这样做），你将会看到一个错误，提示 Service 已经存在。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f web.yaml
statefulset.apps/web created
service/nginx unchanged</code></pre></div>
<!--
Ignore the error. It only indicates that an attempt was made to create the nginx
Headless Service even though that Service already exists. 

Examine the output of the `kubectl get` command running in the first terminal.
-->

<p>请忽略这个错误。它仅表示 kubernetes 进行了一次创建 nginx Headless Service 的尝试，尽管那个 Service 已经存在。</p>

<p>在第一个终端中运行并检查 <code>kubectl get</code> 命令的输出。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          16m
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          2m
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>          0s
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         18s
web-2     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         3m</code></pre></div>
<!--
When the `web` StatefulSet was recreated, it first relaunched `web-0`. 
Since `web-1` was already Running and Ready, when `web-0` transitioned to
 Running and Ready, it simply adopted this Pod. Since you recreated the StatefulSet 
 with `replicas` equal to 2, once `web-0` had been recreated, and once 
 `web-1` had been determined to already be Running and Ready, `web-2` was 
 terminated. 

Let's take another look at the contents of the `index.html` file served by the 
Pods' webservers.
-->

<p>当重新创建 <code>web</code> StatefulSet 时，<code>web-0</code>被第一个重新启动。由于 <code>web-1</code> 已经处于 Running 和 Ready 状态，当 <code>web-0</code> 变成 Running 和 Ready 时，StatefulSet 会直接接收这个 Pod。由于你重新创建的 StatefulSet 的 <code>replicas</code> 等于 2，一旦 <code>web-0</code> 被重新创建并且 <code>web-1</code> 被认为已经处于 Running 和 Ready 状态时，<code>web-2</code>将会被终止。</p>

<p>让我们再看看被 Pod 的 web 服务器加载的 <code>index.html</code> 的内容。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> -it web-<span style="color:#b8860b">$i</span> -- curl localhost; <span style="color:#a2f;font-weight:bold">done</span>
web-0
web-1</code></pre></div>
<!--
Even though you deleted both the StatefulSet and the `web-0` Pod, it still 
serves the hostname originally entered into its `index.html` file. This is 
because the StatefulSet never deletes the PersistentVolumes associated with a 
Pod. When you recreated the StatefulSet and it relaunched `web-0`, its original 
PersistentVolume was remounted.

### Cascading Delete

In one terminal window, watch the Pods in the StatefulSet.
-->

<p>尽管你同时删除了 StatefulSet 和 <code>web-0</code> Pod，但它仍然使用最初写入 <code>index.html</code> 文件的主机名进行服务。这是因为 StatefulSet 永远不会删除和一个 Pod 相关联的 PersistentVolumes。当你重建这个 StatefulSet 并且重新启动了 <code>web-0</code> 时，它原本的 PersistentVolume 会被重新挂载。</p>

<h3 id="级联删除">级联删除</h3>

<p>在一个终端窗口观察 StatefulSet 里的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx</code></pre></div>
<p>在另一个窗口中再次删除这个 StatefulSet。这次省略 <code>--cascade=false</code> 参数。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete statefulset web
statefulset.apps <span style="color:#b44">&#34;web&#34;</span> deleted</code></pre></div>
<!--
Examine the output of the `kubectl get` command running in the first terminal, 
and wait for all of the Pods to transition to Terminating.
-->

<p>在第一个终端检查 <code>kubectl get</code> 命令的输出，并等待所有的 Pod 变成 Terminating 状态。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -w -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          11m
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>          27m
NAME      READY     STATUS        RESTARTS   AGE
web-0     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>          12m
web-1     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         29m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         12m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         12m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         12m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         29m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         29m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         29m</code></pre></div>
<!--
As you saw in the [Scaling Down](#scaling-down) section, the Pods 
are terminated one at a time, with respect to the reverse order of their ordinal 
indices. Before terminating a Pod, the StatefulSet controller waits for 
the Pod's successor to be completely terminated.

Note that, while a cascading delete will delete the StatefulSet and its Pods, 
it will not delete the Headless Service associated with the StatefulSet. You
must delete the `nginx` Service manually.
-->

<p>如同你在<a href="#ordered-pod-termination">缩容</a>一节看到的，Pod 按照和他们序号索引相反的顺序每次终止一个。在终止一个 Pod 前，StatefulSet 控制器会等待 Pod 后继者被完全终止。</p>

<p>请注意，虽然级联删除会删除 StatefulSet 和它的 Pod，但它并不会删除和 StatefulSet 关联的 Headless Service。你必须手动删除<code>nginx</code> Service。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete service nginx
service <span style="color:#b44">&#34;nginx&#34;</span> deleted</code></pre></div>
<!--
Recreate the StatefulSet and Headless Service one more time.
-->

<p>再一次重新创建 StatefulSet 和 Headless Service。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f web.yaml
service/nginx created
statefulset.apps/web created</code></pre></div>
<!--
When all of the StatefulSet's Pods transition to Running and Ready, retrieve 
the contents of their `index.html` files.
-->

<p>当 StatefulSet 所有的 Pod 变成 Running 和 Ready 时，获取它们的 <code>index.html</code> 文件的内容。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> i in <span style="color:#666">0</span> <span style="color:#666">1</span>; <span style="color:#a2f;font-weight:bold">do</span> kubectl <span style="color:#a2f">exec</span> -it web-<span style="color:#b8860b">$i</span> -- curl localhost; <span style="color:#a2f;font-weight:bold">done</span>
web-0
web-1</code></pre></div>
<!--
Even though you completely deleted the StatefulSet, and all of its Pods, the 
Pods are recreated with their PersistentVolumes mounted, and `web-0` and 
`web-1` will still serve their hostnames.

Finally delete the `web` StatefulSet and the `nginx` service.
-->

<p>即使你已经删除了 StatefulSet 和它的全部 Pod，这些 Pod 将会被重新创建并挂载它们的 PersistentVolumes，并且 <code>web-0</code> 和 <code>web-1</code> 将仍然使用它们的主机名提供服务。</p>

<p>最后删除 <code>web</code> StatefulSet 和 <code>nginx</code> service。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete service nginx
service <span style="color:#b44">&#34;nginx&#34;</span> deleted

kubectl delete statefulset web
statefulset <span style="color:#b44">&#34;web&#34;</span> deleted</code></pre></div>
<!--
## Pod Management Policy

For some distributed systems, the StatefulSet ordering guarantees are 
unnecessary and/or undesirable. These systems require only uniqueness and 
identity. To address this, in Kubernetes 1.7, we introduced 
`.spec.podManagementPolicy` to the StatefulSet API Object. 

### OrderedReady Pod Management

`OrderedReady` pod management is the default for StatefulSets. It tells the 
StatefulSet controller to respect the ordering guarantees demonstrated 
above.

### Parallel Pod Management

`Parallel` pod management tells the StatefulSet controller to launch or 
terminate all Pods in parallel, and not to wait for Pods to become Running 
and Ready or completely terminated prior to launching or terminating another 
Pod.
-->

<h2 id="pod-管理策略">Pod 管理策略</h2>

<p>对于某些分布式系统来说，StatefulSet 的顺序性保证是不必要和/或者不应该的。这些系统仅仅要求唯一性和身份标志。为了解决这个问题，在 Kubernetes 1.7 中我们针对 StatefulSet API Object 引入了 <code>.spec.podManagementPolicy</code>。</p>

<h3 id="orderedready-pod-管理策略">OrderedReady Pod 管理策略</h3>

<p><code>OrderedReady</code> pod 管理策略是 StatefulSets 的默认选项。它告诉 StatefulSet 控制器遵循上文展示的顺序性保证。</p>

<h3 id="parallel-pod-管理策略">Parallel Pod 管理策略</h3>

<p><code>Parallel</code> pod 管理策略告诉 StatefulSet 控制器并行的终止所有 Pod，在启动或终止另一个 Pod 前，不必等待这些 Pod 变成 Running 和 Ready 或者完全终止状态。</p>

<table class="includecode" id="application-web-web-parallel-yaml">
    <thead>
        <tr>
            <th>
                <a href="https://raw.githubusercontent.com/kubernetes/website/master/content/zh/examples/application/web/web-parallel.yaml" download="application/web/web-parallel.yaml">
                    <code>application/web/web-parallel.yaml</code>
                </a>
                <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-web-web-parallel-yaml')" title="Copy application/web/web-parallel.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span>labels:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb">  </span>clusterIP:<span style="color:#bbb"> </span>None<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span>---<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>StatefulSet<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>serviceName:<span style="color:#bbb"> </span><span style="color:#b44">&#34;nginx&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>podManagementPolicy:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Parallel&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>replicas:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>matchLabels:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span>template:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>labels:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>app:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>containers:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span>image:<span style="color:#bbb"> </span>k8s.gcr.io/nginx-slim:<span style="color:#666">0.8</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>-<span style="color:#bbb"> </span>containerPort:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">          </span>name:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb">        </span>volumeMounts:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>www<span style="color:#bbb">
</span><span style="color:#bbb">          </span>mountPath:<span style="color:#bbb"> </span>/usr/share/nginx/html<span style="color:#bbb">
</span><span style="color:#bbb">  </span>volumeClaimTemplates:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>www<span style="color:#bbb">
</span><span style="color:#bbb">    </span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>accessModes:<span style="color:#bbb"> </span>[<span style="color:#bbb"> </span><span style="color:#b44">&#34;ReadWriteOnce&#34;</span><span style="color:#bbb"> </span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span>resources:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>requests:<span style="color:#bbb">
</span><span style="color:#bbb">          </span>storage:<span style="color:#bbb"> </span>1Gi<span style="color:#bbb">
</span></code></pre></div>  </td>
        </tr>
    </tbody>
</table>

<!--
Download the example above, and save it to a file named `web-parallel.yaml`

This manifest is identical to the one you downloaded above except that the `.spec.podManagementPolicy` 
of the `web` StatefulSet is set to `Parallel`.

In one terminal, watch the Pods in the StatefulSet.
-->

<p>下载上面的例子并保存为 <code>web-parallel.yaml</code>。</p>

<p>这份清单和你在上文下载的完全一样，只是 <code>web</code> StatefulSet 的 <code>.spec.podManagementPolicy</code> 设置成了 <code>Parallel</code>。</p>

<p>在一个终端窗口查看 StatefulSet 中的 Pod。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -lapp<span style="color:#666">=</span>nginx -w</code></pre></div>
<!--
In another terminal, create the StatefulSet and Service in the manifest.
-->

<p>在另一个终端窗口创建清单中的 StatefulSet 和 Service。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f web-parallel.yaml
service/nginx created
statefulset.apps/web created</code></pre></div>
<!--
Examine the output of the `kubectl get` command that you executed in the first terminal.
-->

<p>查看你在第一个终端中运行的 <code>kubectl get</code> 命令的输出。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get po -lapp<span style="color:#666">=</span>nginx -w
NAME      READY     STATUS    RESTARTS   AGE
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>          0s
web-0     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-1     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         0s
web-0     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         10s
web-1     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         10s</code></pre></div>
<!--
The StatefulSet controller launched both `web-0` and `web-1` at the same time.

Keep the second terminal open, and, in another terminal window scale the 
StatefulSet.
-->

<p>StatefulSet 控制器同时启动了 <code>web-0</code> 和 <code>web-1</code>。</p>

<p>保持第二个终端打开，并在另一个终端窗口中扩容 StatefulSet。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl scale statefulset/web --replicas<span style="color:#666">=</span><span style="color:#666">4</span>
statefulset.apps/web scaled</code></pre></div>
<!--
Examine the output of the terminal where the `kubectl get` command is running.
-->

<p>在 <code>kubectl get</code> 命令运行的终端里检查它的输出。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">web-3     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-3     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         0s
web-3     <span style="color:#666">0</span>/1       Pending   <span style="color:#666">0</span>         7s
web-3     <span style="color:#666">0</span>/1       ContainerCreating   <span style="color:#666">0</span>         7s
web-2     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         10s
web-3     <span style="color:#666">1</span>/1       Running   <span style="color:#666">0</span>         26s</code></pre></div>
<!--
The StatefulSet controller launched two new Pods, and it did not wait for 
the first to become Running and Ready prior to launching the second.

Keep this terminal open, and in another terminal delete the `web` StatefulSet.
-->

<p>StatefulSet 控制器启动了两个新的 Pod，而且在启动第二个之前并没有等待第一个变成 Running 和 Ready 状态。</p>

<p>保持这个终端打开，并在另一个终端删除 <code>web</code> StatefulSet。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete sts web</code></pre></div>
<!--
Again, examine the output of the `kubectl get` command running in the other terminal.
-->

<p>在另一个终端里再次检查 <code>kubectl get</code> 命令的输出。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">web-3     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-2     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-3     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-2     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-1     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-0     <span style="color:#666">1</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-3     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-2     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-1     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-0     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         44m
web-3     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-3     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m
web-3     <span style="color:#666">0</span>/1       Terminating   <span style="color:#666">0</span>         9m</code></pre></div>
<!--
The StatefulSet controller deletes all Pods concurrently, it does not wait for 
a Pod's ordinal successor to terminate prior to deleting that Pod.

Close the terminal where the `kubectl get` command is running and delete the `nginx` 
Service.
-->

<p>StatefulSet 控制器将并发的删除所有 Pod，在删除一个 Pod 前不会等待它的顺序后继者终止。</p>

<p>关闭 <code>kubectl get</code> 命令运行的终端并删除<code>nginx</code> Service。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete svc nginx</code></pre></div>















<h2 id="清理现场">清理现场</h2>
<!--
You will need to delete the persistent storage media for the PersistentVolumes
used in this tutorial. Follow the necessary steps, based on your environment, 
storage configuration, and provisioning method, to ensure that all storage is 
reclaimed.
-->

<p>你需要删除本教程中用到的 PersistentVolumes 的持久化存储介质。基于你的环境、存储配置和提供方式，按照必须的步骤保证回收所有的存储。</p>











    
            
  <h2>反馈</h2>
  <p class="feedback--prompt">此页是否对您有帮助？ </p>
  <button class="button feedback--yes">是</button>
  <button class="button feedback--no">否</button>
  <p class="feedback--response feedback--response__hidden">
    感谢反馈。如果您有一个关于如何使用 Kubernetes 的特定的、需要答案的问题，可以访问
    <a target="_blank" rel="noopener"
      href="https://stackoverflow.com/questions/tagged/kubernetes">
      Stack Overflow</a>.
    在 GitHub 仓库上登记新的问题
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Issue%20with%20k8s.io">
      报告问题</a>
    或者
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Improvement%20for%20k8s.io">
      提出改进建议</a>.
  </p>
  <script>
    const yes = document.querySelector('.feedback--yes');
    const no = document.querySelector('.feedback--no');
    document.querySelectorAll('.feedback--link').forEach(link => {
      link.href = link.href + window.location.pathname;
    });
    const sendFeedback = (value) => {
      if (!gtag) { console.log('!gtag'); }
      gtag('event', 'click', {
        'event_category': 'Helpful',
        'event_label': window.location.pathname,
        value
      });
    };
    const disableButtons = () => {
      yes.disabled = true;
      yes.classList.add('feedback--button__disabled');
      no.disabled = true;
      no.classList.add('feedback--button__disabled');
    };
    yes.addEventListener('click', () => {
      sendFeedback(1);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
    no.addEventListener('click', () => {
      sendFeedback(0);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
  </script>


    
            <div id="pre-footer"> 
  <hr />

  <div class="issue-button-container">
    <p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/tutorials/stateful-application/basic-stateful-set.md?pixel" alt="Analytics" /></a></p>
    
    
    <script type="text/javascript">
    PDRTJS_settings_8345992 = {
    "id" : "8345992",
    "unique_id" : "\/zh\/docs\/tutorials\/stateful-application\/basic-stateful-set\/",
    "title" : "StatefulSet 基础",
    "permalink" : "https:\/\/kubernetes.io\/zh\/docs\/tutorials\/stateful-application\/basic-stateful-set\/"
    };
    (function(d,c,j){if(!document.getElementById(j)){var pd=d.createElement(c),s;pd.id=j;pd.src=('https:'==document.location.protocol)?'https://polldaddy.com/js/rating/rating.js':'http://i0.poll.fm/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd,s);}}(document,'script','pd-rating-js'));
    </script>
    <a href="" onclick="window.open('https://github.com/kubernetes/website/issues/new?template=bug-report.md&title=Issue%20with%20' +
    'k8s.io'+window.location.pathname)" class="button issue">报告 GitHub 问题</a>
    
    
    
    <a href="https://github.com/kubernetes/website/edit/master/content/zh/docs/tutorials/stateful-application/basic-stateful-set.md" class="button issue">修改本页面</a>
    
  </div>
  

  <div id="lastedit" class="lastedit issue-button-container">
    页面最后一次修改于 March 01, 2020 at 10:26 AM PST 由：
    <a href="https://github.com/kubernetes/website/commit/9fb7a223f8556678fd46338806e691c9d60cf9b9/">Update basic-stateful-set.md (#19402)</a> (<a href="https://github.com/kubernetes/website/commits/master/content/en/docs/tutorials/stateful-application/basic-stateful-set.md">页面历史</a>)
  </div>
  
</div>

          </div>
        </section>
    </main>
		<footer>
    <div class="light-text main-section">
        <nav>
            
            
            
            <a href="/zh/docs/home/">主页</a>
            
            <a href="/zh/blog/">博客</a>
            
            
            
            <a href="/zh/partners/">合作伙伴</a>
            
            <a href="/zh/community/">社区</a>
            
            <a href="/zh/case-studies/">案例分析</a>
            
        </nav>
        <div class="social" role="region" aria-label="Social hyperlinks">
            <div>
                <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                <a href="https://slack.k8s.io/" class="slack"><span>Slack</span></a>
            </div>
            <div>
                <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                <a href="https://discuss.kubernetes.io" class="mailing-list"><span>论坛</span></a>
                <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>事件日历</span></a>
            </div>
            <div>
                
                <a href="https://git.k8s.io/community/contributors/guide" class="button">贡献</a>
            </div>
        </div>
        <div class="miceType center">
            &copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a> 授权许可</a>
        </div>
        <div class="miceType center">
            Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">商标使用页面</a>
        </div>
        <div class="miceType center">
            ICP license: 京ICP备17074266号-3
        </div>
    </div>
</footer>

		<button class="flyout-button" onclick="kub.toggleToc()" aria-label="Toggle table of contents visibility"></button>

<script>

(function () {
    window.addEventListener('DOMContentLoaded', init)

        
        function init() {
            window.removeEventListener('DOMContentLoaded', init)
                hideNav()
        }

    function hideNav(toc){
        if (!toc) toc = document.querySelector('#docsToc')
        if (!toc) return
            var container = toc.querySelector('.container')

                
                if (container) {
                    if (container.childElementCount === 0 || toc.querySelectorAll('a.item').length === 1) {
                        toc.style.display = 'none'
                            document.getElementById('docsContent').style.width = '100%'
                    }
                } else {
                    requestAnimationFrame(function () {
                        hideNav(toc)
                    })
                }
    }
})();
</script>



    <script language="application/javascript">
      
      (function addHeadingLinks(){
        var article = document.getElementById('docsContent');
        var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(function(heading){
          if(heading.id){
            var a = document.createElement('a');
            a.innerHTML = heading.innerHTML;
            a.href = '#'+heading.id;
            a.classList.add('inpage_heading');
            heading.innerHTML = '';
            heading.appendChild(a);
          }
        });
      })();
    </script>
	</body>
</html>
