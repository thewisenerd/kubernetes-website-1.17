<!DOCTYPE html>
<html id="docs" lang="zh" class="">
	<head>
	

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>
<meta charset="utf-8">
<title>镜像 - Kubernetes</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#326ce5">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">









<link rel="stylesheet" href="/css/style.b7b8403eb5b1fddd0a2da2a8383d5b53e6ef81c23e4b0e292e6103bd91f9502d.css" integrity="sha256-t7hAPrWx/d0KLaKoOD1bU&#43;bvgcI&#43;Sw4pLmEDvZH5UC0=">


<link rel="stylesheet" href="/css/base_fonts.css">
<link rel="stylesheet" href="/css/jquery-ui.min.css">
<link rel="stylesheet" href="/css/callouts.css">
<link rel="stylesheet" href="/css/custom-jekyll/tags.css">



<meta name="description" content="如果需要访问多个仓库，则可以为每个仓库创建一个 secret。Kubelet 将任何 imagePullSecrets 合并为单个虚拟 .docker/config.json 文件。">
<meta property="og:description" content="如果需要访问多个仓库，则可以为每个仓库创建一个 secret。Kubelet 将任何 imagePullSecrets 合并为单个虚拟 .docker/config.json 文件。">
<meta name="twitter:description" content="如果需要访问多个仓库，则可以为每个仓库创建一个 secret。Kubelet 将任何 imagePullSecrets 合并为单个虚拟 .docker/config.json 文件。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/containers/images/">
<meta property="og:title" content="镜像">
<meta name="twitter:title" content="镜像">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">
<script src="/js/anchor-4.1.1.min.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>
<script src="/js/jquery-ui-1.12.1.min.js"></script>
<script src="/js/bootstrap-4.3.1.min.js"></script>
<script src="/js/sweetalert-2.1.2.min.js"></script>

<script src="/js/script.js"></script>
<script src="/js/custom-jekyll/tags.js"></script>


	</head>
	<body>
		<div id="cellophane" onclick="kub.toggleMenu()"></div>

<header>
    <a href="/zh/" class="logo" title="生产级别的容器编排系统 - Kubernetes" aria-label="Kubernetes website"></a>

    <div class="nav-buttons" data-auto-burger="primary">
        <ul class="global-nav">
            
            
            <li><a href="/zh/docs/" class="active">文档</a></li>
            
            <li><a href="/zh/blog/">博客</a></li>
            
            
            
            <li><a href="/zh/partners/">合作伙伴</a></li>
            
            <li><a href="/zh/community/">社区</a></li>
            
            <li><a href="/zh/case-studies/">案例分析</a></li>
            
            
            
             <li>
                <a href="#">
                    中文 Chinese <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="/docs/concepts/containers/images/">English</a></li>
                
                    <li><a href="/ko/docs/concepts/containers/images/">한국어 Korean</a></li>
                
                    <li><a href="/fr/docs/concepts/containers/images/">Français</a></li>
                
                    <li><a href="/de/docs/concepts/containers/images/">Deutsch</a></li>
                
                </ul>
            </li>

            <li>
                <a href="#">
                    v1.17 <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="https://kubernetes.io/zh/docs/concepts/containers/images/">v1.21</a></li>
                
                    <li><a href="https://v1-20.docs.kubernetes.io/zh/docs/concepts/containers/images/">v1.20</a></li>
                
                    <li><a href="https://v1-19.docs.kubernetes.io/zh/docs/concepts/containers/images/">v1.19</a></li>
                
                    <li><a href="https://v1-18.docs.kubernetes.io/zh/docs/concepts/containers/images/">v1.18</a></li>
                
                    <li><a href="https://v1-17.docs.kubernetes.io/zh/docs/concepts/containers/images/">v1.17</a></li>
                
                </ul>
            </li>
        </ul>
        
        <a href="/zh/docs/tutorials/kubernetes-basics/" class="button" id="tryKubernetes" data-auto-burger-exclude>学习 Kubernetes 基础知识</a>
        

        <button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
    </div>

    <nav id="mainNav">
        <div class="main-section" data-auto-burger="primary">
         
           <div class="nav-box">
            <h3><a href="/zh/docs/tutorials/hello-minikube/">Get Started</a></h3>
           <p>Ready to get your hands dirty? Build a simple Kubernetes cluster that runs "Hello World" for Node.js.</p>

            </div>
         
           <div class="nav-box">
            <h3><a href="/zh/docs/home/">文档</a></h3>
           <p>通过演练，示例和参考文档了解如何使用 Kubernetes。你甚至可以<a href="/editdocs/" data-auto-burger-exclude>帮助贡献文档</a>！</p>

            </div>
         
           <div class="nav-box">
            <h3><a href="/zh/blog/">博客</a></h3>
           <p>阅读关于 kubernetes 和容器规范的最新信息,以及获取最新的技术。</p>

            </div>
         
        </div>
        <div class="main-section" data-auto-burger="primary">
            <div class="left">
                <h5 class="github-invite">想要修改 Kubernetes 的核心源代码？</h5>
                <a href="https://github.com/kubernetes/kubernetes" class="button" data-auto-burger-exclude>在 GitHub 上查看</a>
            </div>

            <div class="right">
                <h5 class="github-invite">了解社区</h5>
                <div class="social">
                    <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                    <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                    <a href="http://slack.k8s.io/" class="slack"><span>Slack Slack</span></a>
                    <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                    <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                    <a href="https://discuss.kubernetes.io" class="mailing-list"><span>论坛</span></a>
                    <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>事件日历</span></a>
                </div>
            </div>
            <div class="clear" style="clear: both"></div>
        </div>
    </nav>
</header>

		
		
		<section id="hero" class="light-text no-sub">
			









<h1>概念</h1>
<h5></h5>










<div id="vendorStrip" class="light-text">
	<ul>
		
		
		<li><a href="/zh/docs/home/">主页</a></li>
		
		
		<li><a href="/zh/docs/setup/">入门</a></li>
		
		
		<li><a href="/zh/docs/concepts/" class="YAH">概念</a></li>
		
		
		<li><a href="/zh/docs/tasks/">任务</a></li>
		
		
		<li><a href="/zh/docs/tutorials/">教程</a></li>
		
		
		<li><a href="/zh/docs/reference/">参考</a></li>
		
		
		<li><a href="/zh/docs/contribute/">贡献</a></li>
		
	</ul>
	<form id="searchBox" action="/docs/search/" role="search">
		<input type="text" id="search" name="q" placeholder="搜索" aria-label="Search">
	</form>
</div>

		</section>
		
    
		
<section id="deprecationWarning">
  <main>
    <div class="content deprecation-warning">
      <h3>
	 Kubernetes v1.17
	  版本的文档已不再维护。您现在看到的版本来自于一份静态的快照。如需查阅最新文档，请点击
	 <a href="https://kubernetes.io/docs/home/">最新版本。</a>
      </h3>
    </div>
  </main>
</section>


    <main>
        <section id="encyclopedia">
          
<div id="docsToc">
     <div class="pi-accordion">
    	
        
        
        
        
        
         
             
                 
             
         
             
                 
             
         
             
                 
                          
                          
                 
             
         
             
         
             
         
             
         
             
         
         
        
        <a class="item" data-title="概念" href="/zh/docs/concepts/"></a>

	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="概述">
	<div class="container">
		
		
		
		<a class="item" data-title="概述" href="/zh/docs/concepts/overview/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Kubernetes 是什么？" href="/zh/docs/concepts/overview/what-is-kubernetes/"></a>

		
	
		
			

<a class="item" data-title="Kubernetes 组件" href="/zh/docs/concepts/overview/components/"></a>

		
	
		
			

<a class="item" data-title="Kubernetes API" href="/zh/docs/concepts/overview/kubernetes-api/"></a>

		
	
		
			
<div class="item" data-title="使用 Kubernetes 对象">
	<div class="container">
		
		
		
		<a class="item" data-title="使用 Kubernetes 对象" href="/zh/docs/concepts/overview/working-with-objects/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="理解 Kubernetes 对象" href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/"></a>

		
	
		
			

<a class="item" data-title="Kubernetes 对象管理" href="/zh/docs/concepts/overview/working-with-objects/object-management/"></a>

		
	
		
			

<a class="item" data-title="名称" href="/zh/docs/concepts/overview/working-with-objects/names/"></a>

		
	
		
			

<a class="item" data-title="命名空间" href="/zh/docs/concepts/overview/working-with-objects/namespaces/"></a>

		
	
		
			

<a class="item" data-title="标签和选择器" href="/zh/docs/concepts/overview/working-with-objects/labels/"></a>

		
	
		
			

<a class="item" data-title="注解" href="/zh/docs/concepts/overview/working-with-objects/annotations/"></a>

		
	
		
			

<a class="item" data-title="字段选择器" href="/zh/docs/concepts/overview/working-with-objects/field-selectors/"></a>

		
	
		
			

<a class="item" data-title="推荐使用的标签" href="/zh/docs/concepts/overview/working-with-objects/common-labels/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Kubernetes 架构">
	<div class="container">
		
		
		
		<a class="item" data-title="Kubernetes 架构" href="/zh/docs/concepts/architecture/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="节点" href="/zh/docs/concepts/architecture/nodes/"></a>

		
	
		
			

<a class="item" data-title="云控制器管理器的基础概念" href="/zh/docs/concepts/architecture/cloud-controller/"></a>

		
	
		
			

<a class="item" data-title="控制器" href="/zh/docs/concepts/architecture/controller/"></a>

		
	
		
			

<a class="item" data-title="Master 节点通信" href="/zh/docs/concepts/architecture/master-node-communication/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="计算、存储和网络扩展">
	<div class="container">
		
		
		
		<a class="item" data-title="计算、存储和网络扩展" href="/zh/docs/concepts/cluster-administration/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="集群管理概述" href="/zh/docs/concepts/cluster-administration/cluster-administration-overview/"></a>

		
	
		
			

<a class="item" data-title="证书" href="/zh/docs/concepts/cluster-administration/certificates/"></a>

		
	
		
			

<a class="item" data-title="云驱动" href="/zh/docs/concepts/cluster-administration/cloud-providers/"></a>

		
	
		
			

<a class="item" data-title="管理资源" href="/zh/docs/concepts/cluster-administration/manage-deployment/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Cluster Networking <small>(EN)</small>" href="/docs/concepts/cluster-administration/networking/"></a>

		
	
		
			

<a class="item" data-title="Kubernetes 控制面板的指标" href="/zh/docs/concepts/cluster-administration/monitoring/"></a>

		
	
		
			

<a class="item" data-title="日志架构" href="/zh/docs/concepts/cluster-administration/logging/"></a>

		
	
		
			

<a class="item" data-title="配置 kubelet 垃圾回收策略" href="/zh/docs/concepts/cluster-administration/kubelet-garbage-collection/"></a>

		
	
		
			

<a class="item" data-title="控制器管理器指标" href="/zh/docs/concepts/cluster-administration/controller-metrics/"></a>

		
	
		
			

<a class="item" data-title="Kubernetes 中的代理" href="/zh/docs/concepts/cluster-administration/proxies/"></a>

		
	
		
			

<a class="item" data-title="安装扩展（Addons）" href="/zh/docs/concepts/cluster-administration/addons/"></a>

		
	
		
			

<a class="item" data-title="联邦" href="/zh/docs/concepts/cluster-administration/federation/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="扩展 Kubernetes">
	<div class="container">
		
		
		
		<a class="item" data-title="扩展 Kubernetes" href="/zh/docs/concepts/extend-kubernetes/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="扩展 Kubernetes 集群" href="/zh/docs/concepts/extend-kubernetes/extend-cluster/"></a>

		
	
		
			
<div class="item" data-title="扩展 Kubernetes API">
	<div class="container">
		
		
		
		<a class="item" data-title="扩展 Kubernetes API" href="/zh/docs/concepts/extend-kubernetes/api-extension/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Custom Resources <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/api-extension/custom-resources/"></a>

		
	
		
			

<a class="item" data-title="通过聚合层扩展 Kubernetes API" href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/"></a>

		
	

	</div>
</div>

		
	
		
			

<a class="item" data-title="Operator 模式" href="/zh/docs/concepts/extend-kubernetes/operator/"></a>

		
	
		
			
<div class="item" data-title="计算、存储和网络扩展">
	<div class="container">
		
		
		
		<a class="item" data-title="计算、存储和网络扩展" href="/zh/docs/concepts/extend-kubernetes/compute-storage-net/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="网络插件" href="/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Device Plugins <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/"></a>

		
	

	</div>
</div>

		
	
		
			

<a class="item" data-title="服务目录" href="/zh/docs/concepts/extend-kubernetes/service-catalog/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Poseidon-Firmament Scheduler <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/poseidon-firmament-alternate-scheduler/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="容器">
	<div class="container">
		
		
		
		<a class="item" data-title="容器" href="/zh/docs/concepts/containers/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Containers overview <small>(EN)</small>" href="/docs/concepts/containers/overview/"></a>

		
	
		
			

<a class="item" data-title="镜像" href="/zh/docs/concepts/containers/images/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Container Environment <small>(EN)</small>" href="/docs/concepts/containers/container-environment/"></a>

		
	
		
			

<a class="item" data-title="容器运行时类(Runtime Class)" href="/zh/docs/concepts/containers/runtime-class/"></a>

		
	
		
			

<a class="item" data-title="容器生命周期钩子" href="/zh/docs/concepts/containers/container-lifecycle-hooks/"></a>

		
	
		
			

<a class="item" data-title="容器环境变量" href="/zh/docs/concepts/containers/container-environment-variables/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="工作负载">
	<div class="container">
		
		
		
		<a class="item" data-title="工作负载" href="/zh/docs/concepts/workloads/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="Pods">
	<div class="container">
		
		
		
		<a class="item" data-title="Pods" href="/zh/docs/concepts/workloads/pods/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Pod 概览" href="/zh/docs/concepts/workloads/pods/pod-overview/"></a>

		
	
		
			

<a class="item" data-title="Pods" href="/zh/docs/concepts/workloads/pods/pod/"></a>

		
	
		
			

<a class="item" data-title="Pod Preset" href="/zh/docs/concepts/workloads/pods/podpreset/"></a>

		
	
		
			

<a class="item" data-title="Pod 拓扑扩展约束" href="/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/"></a>

		
	
		
			

<a class="item" data-title="干扰" href="/zh/docs/concepts/workloads/pods/disruptions/"></a>

		
	
		
			

<a class="item" data-title="临时容器" href="/zh/docs/concepts/workloads/pods/ephemeral-containers/"></a>

		
	
		
			

<a class="item" data-title="Init 容器" href="/zh/docs/concepts/workloads/pods/init-containers/"></a>

		
	
		
			

<a class="item" data-title="Pod 的生命周期" href="/zh/docs/concepts/workloads/pods/pod-lifecycle/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="控制器">
	<div class="container">
		
		
		
		<a class="item" data-title="控制器" href="/zh/docs/concepts/workloads/controllers/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="ReplicaSet" href="/zh/docs/concepts/workloads/controllers/replicaset/"></a>

		
	
		
			

<a class="item" data-title="ReplicationController" href="/zh/docs/concepts/workloads/controllers/replicationcontroller/"></a>

		
	
		
			

<a class="item" data-title="Deployments" href="/zh/docs/concepts/workloads/controllers/deployment/"></a>

		
	
		
			

<a class="item" data-title="StatefulSets" href="/zh/docs/concepts/workloads/controllers/statefulset/"></a>

		
	
		
			

<a class="item" data-title="DaemonSet" href="/zh/docs/concepts/workloads/controllers/daemonset/"></a>

		
	
		
			

<a class="item" data-title="垃圾收集" href="/zh/docs/concepts/workloads/controllers/garbage-collection/"></a>

		
	
		
			

<a class="item" data-title="已完成资源的 TTL 控制器" href="/zh/docs/concepts/workloads/controllers/ttlafterfinished/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Jobs - Run to Completion <small>(EN)</small>" href="/docs/concepts/workloads/controllers/jobs-run-to-completion/"></a>

		
	
		
			

<a class="item" data-title="CronJob" href="/zh/docs/concepts/workloads/controllers/cron-jobs/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="存储">
	<div class="container">
		
		
		
		<a class="item" data-title="存储" href="/zh/docs/concepts/storage/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Volumes" href="/zh/docs/concepts/storage/volumes/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Persistent Volumes <small>(EN)</small>" href="/docs/concepts/storage/persistent-volumes/"></a>

		
	
		
			

<a class="item" data-title="卷快照" href="/zh/docs/concepts/storage/volume-snapshots/"></a>

		
	
		
			

<a class="item" data-title="CSI 卷克隆" href="/zh/docs/concepts/storage/volume-pvc-datasource/"></a>

		
	
		
			

<a class="item" data-title="Storage Classes" href="/zh/docs/concepts/storage/storage-classes/"></a>

		
	
		
			

<a class="item" data-title="卷快照类" href="/zh/docs/concepts/storage/volume-snapshot-classes/"></a>

		
	
		
			

<a class="item" data-title="动态卷供应" href="/zh/docs/concepts/storage/dynamic-provisioning/"></a>

		
	
		
			

<a class="item" data-title="特定于节点的卷数限制" href="/zh/docs/concepts/storage/storage-limits/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="配置">
	<div class="container">
		
		
		
		<a class="item" data-title="配置" href="/zh/docs/concepts/configuration/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="扩展资源的资源箱打包" href="/zh/docs/concepts/configuration/resource-bin-packing/"></a>

		
	
		
			

<a class="item" data-title="配置最佳实践" href="/zh/docs/concepts/configuration/overview/"></a>

		
	
		
			

<a class="item" data-title="Pod 开销" href="/zh/docs/concepts/configuration/pod-overhead/"></a>

		
	
		
			

<a class="item" data-title="为容器管理计算资源" href="/zh/docs/concepts/configuration/manage-compute-resources-container/"></a>

		
	
		
			

<a class="item" data-title="将 Pod 分配给节点" href="/zh/docs/concepts/configuration/assign-pod-node/"></a>

		
	
		
			

<a class="item" data-title="Taint 和 Toleration" href="/zh/docs/concepts/configuration/taint-and-toleration/"></a>

		
	
		
			

<a class="item" data-title="Secret" href="/zh/docs/concepts/configuration/secret/"></a>

		
	
		
			

<a class="item" data-title="使用 kubeconfig 文件组织集群访问" href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Priority and Preemption <small>(EN)</small>" href="/docs/concepts/configuration/pod-priority-preemption/"></a>

		
	
		
			

<a class="item" data-title="调度框架" href="/zh/docs/concepts/configuration/scheduling-framework/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="服务、负载均衡和联网">
	<div class="container">
		
		
		
		<a class="item" data-title="服务、负载均衡和联网" href="/zh/docs/concepts/services-networking/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Endpoint Slices" href="/zh/docs/concepts/services-networking/endpoint-slices/"></a>

		
	
		
			

<a class="item" data-title="Service 拓扑" href="/zh/docs/concepts/services-networking/service-topology/"></a>

		
	
		
			

<a class="item" data-title="Services" href="/zh/docs/concepts/services-networking/service/"></a>

		
	
		
			

<a class="item" data-title="Pod 与 Service 的 DNS" href="/zh/docs/concepts/services-networking/dns-pod-service/"></a>

		
	
		
			

<a class="item" data-title="应用连接到 Service" href="/zh/docs/concepts/services-networking/connect-applications-service/"></a>

		
	
		
			

<a class="item" data-title="Ingress" href="/zh/docs/concepts/services-networking/ingress/"></a>

		
	
		
			

<a class="item" data-title="Ingress 控制器" href="/zh/docs/concepts/services-networking/ingress-controllers/"></a>

		
	
		
			

<a class="item" data-title="网络策略" href="/zh/docs/concepts/services-networking/network-policies/"></a>

		
	
		
			

<a class="item" data-title="使用 HostAliases 向 Pod /etc/hosts 文件添加条目" href="/zh/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/"></a>

		
	
		
			

<a class="item" data-title="IPv4/IPv6 双协议栈" href="/zh/docs/concepts/services-networking/dual-stack/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="安全">
	<div class="container">
		
		
		
		<a class="item" data-title="安全" href="/zh/docs/concepts/security/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Overview of Cloud Native Security <small>(EN)</small>" href="/docs/concepts/security/overview/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="调度">
	<div class="container">
		
		
		
		<a class="item" data-title="调度" href="/zh/docs/concepts/scheduling/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Kubernetes 调度器" href="/zh/docs/concepts/scheduling/kube-scheduler/"></a>

		
	
		
			

<a class="item" data-title="调度器性能调优" href="/zh/docs/concepts/scheduling/scheduler-perf-tuning/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="策略">
	<div class="container">
		
		
		
		<a class="item" data-title="策略" href="/zh/docs/concepts/policy/"></a>
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Limit Ranges <small>(EN)</small>" href="/docs/concepts/policy/limit-range/"></a>

		
	
		
			

<a class="item" data-title="Pod 安全策略" href="/zh/docs/concepts/policy/pod-security-policy/"></a>

		
	
		
			

<a class="item" data-title="资源配额" href="/zh/docs/concepts/policy/resource-quotas/"></a>

		
	

	</div>
</div>

		
	





     </div> 
    <button class="push-menu-close-button" onclick="kub.toggleToc()"></button>
</div> 


          <div id="docsContent">
            

<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/zh/docs/concepts/containers/images.md" id="editPageButton" target="_blank">
    Edit This Page
  </a>
</p>

<h1>镜像</h1>



<!--
You create your Docker image and push it to a registry before referring to it in a Kubernetes pod.

The `image` property of a container supports the same syntax as the `docker` command does, including private registries and tags.
-->

<p>创建 Docker 镜像并将其推送到仓库，然后在 Kubernetes pod 中引用它。</p>

<p>容器的 <code>image</code> 属性支持与 <code>docker</code> 命令相同的语法，包括私有仓库和标签。</p>









<ul id="markdown-toc">










<li><a href="#%e5%8d%87%e7%ba%a7%e9%95%9c%e5%83%8f">升级镜像</a></li>




<li><a href="#%e4%bd%bf%e7%94%a8%e6%b8%85%e5%8d%95-manifest-%e6%9e%84%e5%bb%ba%e5%a4%9a%e6%9e%b6%e6%9e%84%e9%95%9c%e5%83%8f">使用清单（manifest）构建多架构镜像</a></li>




<li><a href="#%e4%bd%bf%e7%94%a8%e7%a7%81%e6%9c%89%e4%bb%93%e5%ba%93">使用私有仓库</a></li>



















</ul>


<!--
## Updating Images
-->

<h2 id="升级镜像">升级镜像</h2>

<!--
The default pull policy is `IfNotPresent` which causes the Kubelet to skip
pulling an image if it already exists. If you would like to always force a pull,
you can do one of the following:
-->

<p>默认的镜像拉取策略是 <code>IfNotPresent</code>，在镜像已经存在的情况下，kubelet 将不再去拉取镜像。如果总是想要拉取镜像，您可以执行以下操作：</p>

<!--
- set the `imagePullPolicy` of the container to `Always`.
- omit the `imagePullPolicy` and use `:latest` as the tag for the image to use.
- omit the `imagePullPolicy` and the tag for the image to use.
- enable the [AlwaysPullImages](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) admission controller.
-->

<ul>
<li>设置容器的 <code>imagePullPolicy</code> 为 <code>Always</code>。</li>
<li>省略 <code>imagePullPolicy</code>，并使用 <code>:latest</code> 作为要使用的镜像的标签。</li>
<li>省略 <code>imagePullPolicy</code> 和要使用的镜像标签。</li>
<li>启用 <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages</a> 准入控制器（admission controller）。</li>
</ul>

<!--
Note that you should avoid using `:latest` tag, see [Best Practices for Configuration](/docs/concepts/configuration/overview/#container-images) for more information.
-->

<p>注意应避免使用 <code>:latest</code> 标签，参见<a href="/docs/concepts/configuration/overview/#container-images">配置镜像最佳实践</a> 获取更多信息。</p>

<!--
## Building Multi-architecture Images with Manifests
-->

<h2 id="使用清单-manifest-构建多架构镜像">使用清单（manifest）构建多架构镜像</h2>

<!--
Docker CLI now supports the following command `docker manifest` with sub commands like `create`, `annotate` and `push`. These commands can be used to build and push the manifests. You can use `docker manifest inspect` to view the manifest.
-->

<p>Docker CLI 现在支持以下命令 <code>docker manifest</code> 以及 <code>create</code>、<code>annotate</code>、<code>push</code> 等子命令。这些命令可用于构建和推送清单。您可以使用 <code>docker manifest inspect</code> 来查看清单。</p>

<!--
Please see docker documentation here:
https://docs.docker.com/edge/engine/reference/commandline/manifest/
-->

<p>请在此处查看 docker 清单文档：
<a href="https://docs.docker.com/edge/engine/reference/commandline/manifest/" target="_blank">https://docs.docker.com/edge/engine/reference/commandline/manifest/</a></p>

<!--
See examples on how we use this in our build harness:
https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=
-->

<p>查看有关如何在构建工具中使用清单的示例：
<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&amp;i=nope&amp;files=&amp;repos=" target="_blank">https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&amp;i=nope&amp;files=&amp;repos=</a></p>

<!--
These commands rely on and are implemented purely on the Docker CLI. You will need to either edit the `$HOME/.docker/config.json` and set `experimental` key to `enabled` or you can just set `DOCKER_CLI_EXPERIMENTAL` environment variable to `enabled` when you call the CLI commands.
-->

<p>这些命令依赖于 Docker CLI 并仅在 Docker CLI 上实现。需要编辑 <code>$HOME/.docker/config.json</code> 并将 <code>experimental</code> 设置为 <code>enabled</code>，或者仅在调用 CLI 命令时将 <code>DOCKER_CLI_EXPERIMENTAL</code> 环境变量设置为 <code>enabled</code>。</p>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
Please use Docker *18.06 or above*, versions below that either have bugs or do not support the experimental command line option. Example https://github.com/docker/cli/issues/1135 causes problems under containerd.
-->

<p>请使用 Docker *18.06 或更高版本*，低版本存在错误或不支持实验性命令行选项。导致容器问题示例 <a href="https://github.com/docker/cli/issues/1135。" target="_blank">https://github.com/docker/cli/issues/1135。</a></div>
</blockquote>

<!--
If you run into trouble with uploading stale manifests, just clean up the older manifests in `$HOME/.docker/manifests` to start fresh.
-->

<p>如果在上传旧清单时遇到麻烦，只需删除 <code>$HOME/.docker/manifests</code> 中旧的清单即可重新开始。</p>

<!--
For Kubernetes, we have typically used images with suffix `-$(ARCH)`. For backward compatibility, please generate the older images with suffixes. The idea is to generate say `pause` image which has the manifest for all the arch(es) and say `pause-amd64` which is backwards compatible for older configurations or YAML files which may have hard coded the images with suffixes.
-->

<p>对于 Kubernetes，通常使用带有后缀 <code>-$(ARCH)</code> 的镜像。为了向后兼容，请生成带有后缀的旧镜像。想法是生成具有所有 arch(es) 清单的 <code>pause</code> 镜像，并生成 <code>pause-amd64</code> 镜像，该镜像向后兼容较早的配置或者可能已对带有后缀的镜像进行硬编码的 YAML 文件。</p>

<!--
## Using a Private Registry
-->

<h2 id="使用私有仓库">使用私有仓库</h2>

<!--
Private registries may require keys to read images from them.
Credentials can be provided in several ways:
-->

<p>从私有仓库读取镜像时可能需要密钥。
凭证可以用以下方式提供:</p>

<p><!--
  - Using Google Container Registry
    - Per-cluster
    - automatically configured on Google Compute Engine or Google Kubernetes Engine
    - all pods can read the project's private registry
  - Using Amazon Elastic Container Registry (ECR)
    - use IAM roles and policies to control access to ECR repositories
    - automatically refreshes ECR login credentials
  - Using Oracle Cloud Infrastructure Registry (OCIR)
    - use IAM roles and policies to control access to OCIR repositories
  - Using Azure Container Registry (ACR)
  - Using IBM Cloud Container Registry
  - Configuring Nodes to Authenticate to a Private Registry
    - all pods can read any configured private registries
    - requires node configuration by cluster administrator
  - Pre-pulled Images
    - all pods can use any images cached on a node
    - requires root access to all nodes to setup
  - Specifying ImagePullSecrets on a Pod
    - only pods which provide own keys can access the private registry
  -->
  - 使用 Google Container Registry
    - 每个集群
    - 在 Google Compute Engine 或 Google Kubernetes Engine 上自动配置
    - 所有 Pod 均可读取项目的私有仓库
  - 使用 Amazon Elastic Container Registry（ECR）
    - 使用 IAM 角色和策略来控制对 ECR 仓库的访问
    - 自动刷新 ECR 登录凭据
  - 使用 Oracle Cloud Infrastructure Registry（OCIR）
    - 使用 IAM 角色和策略来控制对 OCIR 仓库的访问
  - 使用 Azure Container Registry (ACR)
  - 使用 IBM Cloud Container Registry
  - 配置节点用于私有仓库进行身份验证
    - 所有 Pod 均可读取任何已配置的私有仓库
    - 需要集群管理员配置节点
  - 预拉镜像
    - 所有 Pod 都可以使用节点上缓存的任何镜像
    - 需要所有节点的 root 访问权限才能进行设置
  - 在 Pod 上指定 ImagePullSecrets
    - 只有提供自己密钥的 Pod 才能访问私有仓库</p>

<!--
Each option is described in more detail below.
-->

<p>下面将详细描述每一项。</p>

<!--
### Using Google Container Registry
-->

<h3 id="使用-google-container-registry">使用 Google Container Registry</h3>

<!--
Kubernetes has native support for the [Google Container
Registry (GCR)](https://cloud.google.com/tools/container-registry/), when running on Google Compute
Engine (GCE).  If you are running your cluster on GCE or Google Kubernetes Engine, simply
use the full image name (e.g. gcr.io/my_project/image:tag).
-->

<p>Kuberetes 运行在 Google Compute Engine (GCE) 时原生支持 <a href="https://cloud.google.com/tools/container-registry/" target="_blank">Google Container
Registry (GCR)</a>。如果 kubernetes 集群运行在 GCE 或者 Google Kubernetes Engine，使用镜像全名(例如 gcr.io/my_project/image:tag) 即可。</p>

<!--
All pods in a cluster will have read access to images in this registry.
-->

<p>集群中所有 pod 都会有读取这个仓库镜像的权限。</p>

<!--
The kubelet will authenticate to GCR using the instance's
Google service account.  The service account on the instance
will have a `https://www.googleapis.com/auth/devstorage.read_only`,
so it can pull from the project's GCR, but not push.
-->

<p>kubelet 将使用实例的 Google service account 向 GCR 认证。实例的 Google service account 拥有 <code>https://www.googleapis.com/auth/devstorage.read_only</code>，所以它可以从项目的 GCR 拉取，但不能推送。</p>

<!--
### Using Amazon Elastic Container Registry
-->

<h3 id="使用-amazon-elastic-container-registry">使用 Amazon Elastic Container Registry</h3>

<!--
Kubernetes has native support for the [Amazon Elastic Container Registry](https://aws.amazon.com/ecr/), when nodes are AWS EC2 instances.

Simply use the full image name (e.g. `ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag`)
in the Pod definition.
-->

<p>当 Node 是 AWS EC2 实例时，Kubernetes 原生支持 <a href="https://aws.amazon.com/ecr/" target="_blank">Amazon Elastic Container Registry</a>。</p>

<p>在 pod 定义中，使用镜像全名即可 (例如 <code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>)</p>

<!--
All users of the cluster who can create pods will be able to run pods that use any of the
images in the ECR registry.

The kubelet will fetch and periodically refresh ECR credentials.  It needs the following permissions to do this:
-->

<p>集群中所有可以创建 Pod 的用户都将能够运行使用 ECR 仓库中任何镜像的 Pod。</p>

<p>kubelet 将获取并定期刷新 ECR 凭据。它需要以下权限才能执行此操作：</p>

<ul>
<li><code>ecr:GetAuthorizationToken</code></li>
<li><code>ecr:BatchCheckLayerAvailability</code></li>
<li><code>ecr:GetDownloadUrlForLayer</code></li>
<li><code>ecr:GetRepositoryPolicy</code></li>
<li><code>ecr:DescribeRepositories</code></li>
<li><code>ecr:ListImages</code></li>
<li><code>ecr:BatchGetImage</code></li>
</ul>

<!--
Requirements:

- You must be using kubelet version `v1.2.0` or newer.  (e.g. run `/usr/bin/kubelet --version=true`).
- If your nodes are in region A and your registry is in a different region B, you need version `v1.3.0` or newer.
- ECR must be offered in your region
-->

<p>要求：</p>

<ul>
<li>必须使用 kubelet <code>v1.2.0</code> 及以上版本。（例如 运行 <code>/usr/bin/kubelet --version=true</code>）。</li>
<li>如果 Node 在区域 A，而镜像仓库在另一个区域 B，需要 <code>v1.3.0</code> 及以上版本。</li>
<li>区域中必须提供 ECR。</li>
</ul>

<!--
Troubleshooting:

- Verify all requirements above.
- Get $REGION (e.g. `us-west-2`) credentials on your workstation. SSH into the host and run Docker manually with those creds. Does it work?
- Verify kubelet is running with `--cloud-provider=aws`.
- Check kubelet logs (e.g. `journalctl -u kubelet`) for log lines like:
  - `plugins.go:56] Registering credential provider: aws-ecr-key`
  - `provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider`
-->

<p>故障排除：</p>

<ul>
<li>验证是否满足以上要求。</li>
<li>获取工作站的 $REGION (例如 <code>us-west-2</code>) 凭证，使用凭证 SSH 到主机手动运行 Docker。它行得通吗？</li>
<li>验证 kubelet 是否使用参数 <code>--cloud-provider=aws</code> 运行。</li>
<li>检查 kubelet 日志(例如 <code>journalctl -u kubelet</code>)是否有类似的行：

<ul>
<li><code>plugins.go:56] Registering credential provider: aws-ecr-key</code></li>
<li><code>provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider</code></li>
</ul></li>
</ul>

<!--
### Using Azure Container Registry (ACR)
-->

<h3 id="使用-azure-container-registry-acr">使用 Azure Container Registry (ACR)</h3>

<!--
When using [Azure Container Registry](https://azure.microsoft.com/en-us/services/container-registry/)
you can authenticate using either an admin user or a service principal.
In either case, authentication is done via standard Docker authentication.  These instructions assume the
[azure-cli](https://github.com/azure/azure-cli) command line tool.
-->

<p>当使用 <a href="https://azure.microsoft.com/en-us/services/container-registry/" target="_blank">Azure Container Registry</a> 时，可以使用管理员用户或者 service principal 进行身份验证。任何一种情况，认证都通过标准的 Docker 授权完成。本指南假设使用 <a href="https://github.com/azure/azure-cli" target="_blank">azure-cli</a> 命令行工具。</p>

<!--
You first need to create a registry and generate credentials, complete documentation for this can be found in
the [Azure container registry documentation](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli).
-->

<p>首先，需要创建仓库并获取凭证，完整的文档请参考 <a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli" target="_blank">Azure container registry 文档</a>。</p>

<!--
Once you have created your container registry, you will use the following credentials to login:

   * `DOCKER_USER` : service principal, or admin username
   * `DOCKER_PASSWORD`: service principal password, or admin user password
   * `DOCKER_REGISTRY_SERVER`: `${some-registry-name}.azurecr.io`
   * `DOCKER_EMAIL`: `${some-email-address}`
-->

<p>创建好容器仓库后，可以使用以下凭证登录：</p>

<ul>
<li><code>DOCKER_USER</code> : service principal，或管理员用户名称</li>
<li><code>DOCKER_PASSWORD</code>: service principal 密码，或管理员用户密码</li>
<li><code>DOCKER_REGISTRY_SERVER</code>: <code>${some-registry-name}.azurecr.io</code></li>
<li><code>DOCKER_EMAIL</code>: <code>${some-email-address}</code></li>
</ul>

<!--
Once you have those variables filled in you can
[configure a Kubernetes Secret and use it to deploy a Pod](/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod).
-->

<p>填写以上变量后，就可以
<a href="/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod">配置 Kubernetes Secret 并使用它来部署 Pod</a>。</p>

<!--
### Using IBM Cloud Container Registry
IBM Cloud Container Registry provides a multi-tenant private image registry that you can use to safely store and share your Docker images. By default, images in your private registry are scanned by the integrated Vulnerability Advisor to detect security issues and potential vulnerabilities. Users in your IBM Cloud account can access your images, or you can create a token to grant access to registry namespaces.
-->

<h3 id="使用-ibm-cloud-container-registry">使用 IBM Cloud Container Registry</h3>

<p>IBM Cloud Container Registry 提供了一个多租户私有镜像仓库，可以使用它来安全地存储和共享 Docker 仓库。默认情况下，集成的 Vulnerability Advisor 会扫描私有仓库中的镜像，以检测安全问题和潜在的漏洞。IBM Cloud 帐户中的用户可以访问您的镜像，也可以创建令牌来授予对仓库命名空间的访问权限。</p>

<!--
To install the IBM Cloud Container Registry CLI plug-in and create a namespace for your images, see [Getting started with IBM Cloud Container Registry](https://cloud.ibm.com/docs/services/Registry?topic=registry-index#index).
-->

<p>要安装 IBM Cloud Container Registry CLI 插件并为镜像创建命名空间，请参阅 <a href="https://cloud.ibm.com/docs/services/Registry?topic=registry-index#index" target="_blank">IBM Cloud Container Registry 入门</a>。</p>

<!--
You can use the IBM Cloud Container Registry to deploy containers from [IBM Cloud public images](https://cloud.ibm.com/docs/services/Registry?topic=registry-public_images#public_images) and your private images into the `default` namespace of your IBM Cloud Kubernetes Service cluster. To deploy a container into other namespaces, or to use an image from a different IBM Cloud Container Registry region or IBM Cloud account, create a Kubernetes `imagePullSecret`. For more information, see [Building containers from images](https://cloud.ibm.com/docs/containers?topic=containers-images#images).
-->

<p>可以使用 IBM Cloud Container Registry 将容器从 <a href="https://cloud.ibm.com/docs/services/Registry?topic=registry-public_images#public_images" target="_blank">IBM Cloud 公共镜像</a> 和私有镜像部署到 IBM Cloud Kubernetes Service 集群的默认命名空间。要将容器部署到其他命名空间，或使用来自其他 IBM Cloud Container 的仓库区域或 IBM Cloud 帐户的镜像，请创建 Kubernetes <code>imagePullSecret</code>。有关更多信息，请参阅<a href="https://cloud.ibm.com/docs/containers?topic=containers-images#images" target="_blank">从镜像构建容器</a>。</p>

<!--
### Configuring Nodes to Authenticate to a Private Registry
-->

<h3 id="配置-node-对私有仓库认证">配置 Node 对私有仓库认证</h3>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
If you are running on Google Kubernetes Engine, there will already be a `.dockercfg` on each node with credentials for Google Container Registry.  You cannot use this approach.
-->

<p>如果在 Google Kubernetes Engine 上运行集群，每个节点上都会有 <code>.dockercfg</code> 文件，它包含 Google Container Registry 的凭证。不需要使用以下方法。</div>
</blockquote>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
If you are running on AWS EC2 and are using the EC2 Container Registry (ECR), the kubelet on each node will
manage and update the ECR login credentials. You cannot use this approach.
-->

<p>如果在 AWS EC2 上运行集群且准备使用 EC2 Container Registry (ECR)，每个 node 上的 kubelet 会管理和更新 ECR 的登录凭证。不需要使用以下方法。</div>
</blockquote>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
This approach is suitable if you can control node configuration.  It
will not work reliably on GCE, and any other cloud provider that does automatic
node replacement.
-->

<p>该方法适用于能够对节点进行配置的情况。该方法在 GCE 及在其它能自动配置节点的云平台上并不适合。</div>
</blockquote>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
Kubernetes as of now only supports the `auths` and `HttpHeaders` section of docker config. This means credential helpers (`credHelpers` or `credsStore`) are not supported.
-->

<p>截至目前，Kubernetes 仅支持 docker config 的 <code>auths</code> 和 <code>HttpHeaders</code> 部分。这意味着不支持凭据助手（<code>credHelpers</code> 或 <code>credsStore</code>）。</div>
</blockquote>

<!--
Docker stores keys for private registries in the `$HOME/.dockercfg` or `$HOME/.docker/config.json` file.  If you put the same file
in the search paths list below, kubelet uses it as the credential provider when pulling images.

*   `{--root-dir:-/var/lib/kubelet}/config.json`
*   `{cwd of kubelet}/config.json`
*   `${HOME}/.docker/config.json`
*   `/.docker/config.json`
*   `{--root-dir:-/var/lib/kubelet}/.dockercfg`
*   `{cwd of kubelet}/.dockercfg`
*   `${HOME}/.dockercfg`
*   `/.dockercfg`
-->

<p>Docker 将私有仓库的密钥存放在 <code>$HOME/.dockercfg</code> 或 <code>$HOME/.docker/config.json</code> 文件中。Kubelet 上，docker 会使用 root 用户 <code>$HOME</code> 路径下的密钥。</p>

<ul>
<li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li>
<li><code>{cwd of kubelet}/config.json</code></li>
<li><code>${HOME}/.docker/config.json</code></li>
<li><code>/.docker/config.json</code></li>
<li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li>
<li><code>{cwd of kubelet}/.dockercfg</code></li>
<li><code>${HOME}/.dockercfg</code></li>
<li><code>/.dockercfg</code></li>
</ul>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
You may have to set `HOME=/root` explicitly in your environment file for kubelet.
-->

<p>可能必须在环境变量文件中为 kubelet 显式设置 <code>HOME=/root</code>。</div>
</blockquote>

<!--
Here are the recommended steps to configuring your nodes to use a private registry.  In this
example, run these on your desktop/laptop:

   1. Run `docker login [server]` for each set of credentials you want to use.  This updates `$HOME/.docker/config.json`.
   1. View `$HOME/.docker/config.json` in an editor to ensure it contains just the credentials you want to use.
   1. Get a list of your nodes, for example:
      - if you want the names: `nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')`
      - if you want to get the IPs: `nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')`
   1. Copy your local `.docker/config.json` to one of the search paths list above.
      - for example: `for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done`
-->

<p>推荐如下步骤来为 node 配置私有仓库。以下示例在 PC 或笔记本电脑中操作：</p>

<ol>
<li>对于想要使用的每一种凭证，运行 <code>docker login [server]</code>，它会更新 <code>$HOME/.docker/config.json</code>。</li>
<li>使用编辑器查看 <code>$HOME/.docker/config.json</code>，保证文件中包含了想要使用的凭证。</li>
<li>获取 node 列表，例如

<ul>
<li>如果想要 node 名称，<code>nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code></li>
<li>如果想要 node IP ，<code>nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type==&quot;ExternalIP&quot;)]}{.address} {end}')</code></li>
</ul></li>
<li>将本地的 <code>.docker/config.json</code> 拷贝到每个节点 root 用户目录下

<ul>
<li>例如： <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/root/.docker/config.json; done</code></li>
</ul></li>
</ol>

<!--
Verify by creating a pod that uses a private image, e.g.:
-->

<p>创建使用私有仓库的 pod 来验证，例如：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kubectl<span style="color:#bbb"> </span>apply<span style="color:#bbb"> </span>-f<span style="color:#bbb"> </span>-<span style="color:#bbb"> </span>&lt;&lt;EOF<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>kind:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>private-image-test<span style="color:#666">-1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>containers:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>uses-private-image<span style="color:#bbb">
</span><span style="color:#bbb">      </span>image:<span style="color:#bbb"> </span>$PRIVATE_IMAGE_NAME<span style="color:#bbb">
</span><span style="color:#bbb">      </span>imagePullPolicy:<span style="color:#bbb"> </span>Always<span style="color:#bbb">
</span><span style="color:#bbb">      </span>command:<span style="color:#bbb"> </span>[<span style="color:#bbb"> </span><span style="color:#b44">&#34;echo&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;SUCCESS&#34;</span><span style="color:#bbb"> </span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>EOF<span style="color:#bbb">
</span><span style="color:#bbb"></span>pod/private-image-test<span style="color:#666">-1</span><span style="color:#bbb"> </span>created</code></pre></div>
<!--
If everything is working, then, after a few moments, you should see:
-->

<p>如果一切正常，一段时间后，可以看到:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs private-image-test-1
SUCCESS</code></pre></div>
<!--
If it failed, then you will see:
-->

<p>如果失败，则可以看到：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe pods/private-image-test-1 | grep <span style="color:#b44">&#34;Failed&#34;</span>
  Fri, <span style="color:#666">26</span> Jun <span style="color:#666">2015</span> <span style="color:#666">15</span>:36:13 -0700    Fri, <span style="color:#666">26</span> Jun <span style="color:#666">2015</span> <span style="color:#666">15</span>:39:13 -0700    <span style="color:#666">19</span>    <span style="color:#666">{</span>kubelet node-i2hq<span style="color:#666">}</span>    spec.containers<span style="color:#666">{</span>uses-private-image<span style="color:#666">}</span>    failed        Failed to pull image <span style="color:#b44">&#34;user/privaterepo:v1&#34;</span>: Error: image user/privaterepo:v1 not found</code></pre></div>
<!--
You must ensure all nodes in the cluster have the same `.docker/config.json`.  Otherwise, pods will run on
some nodes and fail to run on others.  For example, if you use node autoscaling, then each instance
template needs to include the `.docker/config.json` or mount a drive that contains it.
-->

<p>必须保证集群中所有的节点都有相同的 <code>.docker/config.json</code> 文件。否则, pod 会在一些节点上正常运行而在另一些节点上无法启动。例如，如果使用 node 自动缩放，那么每个实例模板都需要包含 <code>.docker/config.json</code>，或者挂载一个包含这个文件的驱动器。</p>

<!--
All pods will have read access to images in any private registry once private
registry keys are added to the `.docker/config.json`.
-->

<p>在 <code>.docker/config.json</code> 中配置了私有仓库密钥后，所有 pod 都会能读取私有仓库中的镜像。</p>

<!--
### Pre-pulled Images
-->

<h3 id="提前拉取镜像">提前拉取镜像</h3>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
If you are running on Google Kubernetes Engine, there will already be a `.dockercfg` on each node with credentials for Google Container Registry.  You cannot use this approach.
-->

<p>如果在 Google Kubernetes Engine 上运行集群，每个节点上都会有 <code>.dockercfg</code> 文件，它包含 Google Container Registry 的凭证。不需要使用以下方法。</div>
</blockquote>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
This approach is suitable if you can control node configuration.  It
will not work reliably on GCE, and any other cloud provider that does automatic
node replacement.
-->

<p>该方法适用于能够对节点进行配置的情况。该方法在 GCE 及在其它能自动配置节点的云平台上并不适合。</div>
</blockquote>

<!--
By default, the kubelet will try to pull each image from the specified registry.
However, if the `imagePullPolicy` property of the container is set to `IfNotPresent` or `Never`,
then a local image is used (preferentially or exclusively, respectively).
-->

<p>默认情况下，kubelet 会尝试从指定的仓库拉取每一个镜像。但是，如果容器属性 <code>imagePullPolicy</code> 设置为 <code>IfNotPresent</code>或者 <code>Never</code>，则会使用本地镜像（优先、唯一、分别）。</p>

<!--
If you want to rely on pre-pulled images as a substitute for registry authentication,
you must ensure all nodes in the cluster have the same pre-pulled images.

This can be used to preload certain images for speed or as an alternative to authenticating to a private registry.

All pods will have read access to any pre-pulled images.
-->

<p>如果依赖提前拉取镜像代替仓库认证，必须保证集群所有的节点提前拉取的镜像是相同的。</p>

<p>可以用于提前载入指定的镜像以提高速度，或者作为私有仓库认证的一种替代方案。</p>

<p>所有的 pod 都可以使用 node 上缓存的镜像。</p>

<!--
### Specifying ImagePullSecrets on a Pod
-->

<h3 id="在-pod-上指定-imagepullsecrets">在 pod 上指定 ImagePullSecrets</h3>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
This approach is currently the recommended approach for Google Kubernetes Engine, GCE, and any cloud-providers
where node creation is automated.
-->

<p>Google Kubernetes Engine、GCE 及其他自动创建 node 的云平台上，推荐使用本方法。</div>
</blockquote>

<!--
Kubernetes supports specifying registry keys on a pod.
-->

<p>Kubernetes 支持在 pod 中指定仓库密钥。</p>

<!--
#### Creating a Secret with a Docker Config
-->

<h4 id="使用-docker-config-创建-secret">使用 Docker Config 创建 Secret</h4>

<!--
Run the following command, substituting the appropriate uppercase values:
-->

<p>运行以下命令，将大写字母代替为合适的值：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create secret docker-registry &lt;name&gt; --docker-server<span style="color:#666">=</span>DOCKER_REGISTRY_SERVER --docker-username<span style="color:#666">=</span>DOCKER_USER --docker-password<span style="color:#666">=</span>DOCKER_PASSWORD --docker-email<span style="color:#666">=</span>DOCKER_EMAIL</code></pre></div>
<!--
If you already have a Docker credentials file then, rather than using the above
command, you can import the credentials file as a Kubernetes secret.
[Create a Secret based on existing Docker credentials](/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials) explains how to set this up.
This is particularly useful if you are using multiple private container
registries, as `kubectl create secret docker-registry` creates a Secret that will
only work with a single private registry.
-->

<p>如果已经有 Docker 凭证文件，则可以将凭证文件作为 Kubernetes secret 导入而不是使用上面的命令。<a href="/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials">根据现有 Docker 凭证创建 Secret</a> 解释了如何安装。如果使用多个私有容器仓库，这将特别有用，因为 <code>kubectl create secret docker-registry</code> 创建了一个仅适用于单个私有仓库的 Secret。</p>

<blockquote class="note">
  <div><strong>注意：</strong> <!--
Pods can only reference image pull secrets in their own namespace,
so this process needs to be done one time per namespace.
-->

<p>Pod 只能引用和它相同命名空间的 ImagePullSecrets，所以需要为每一个命名空间做配置。</div>
</blockquote>

<!--
#### Referring to an imagePullSecrets on a Pod
-->

<h4 id="引用-pod-上的-imagepullsecrets">引用 Pod 上的 imagePullSecrets</h4>

<!--
Now, you can create pods which reference that secret by adding an `imagePullSecrets`
section to a pod definition.
-->

<p>现在，在创建 pod 时，可以在 pod 定义中增加 <code>imagePullSecrets</code> 部分来引用 secret。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF &gt; pod.yaml
</span><span style="color:#b44">apiVersion: v1
</span><span style="color:#b44">kind: Pod
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: foo
</span><span style="color:#b44">  namespace: awesomeapps
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  containers:
</span><span style="color:#b44">    - name: foo
</span><span style="color:#b44">      image: janedoe/awesomeapp:v1
</span><span style="color:#b44">  imagePullSecrets:
</span><span style="color:#b44">    - name: myregistrykey
</span><span style="color:#b44">EOF</span>

cat <span style="color:#b44">&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span><span style="color:#b44">resources:
</span><span style="color:#b44">- pod.yaml
</span><span style="color:#b44">EOF</span></code></pre></div>
<!--
This needs to be done for each pod that is using a private registry.

However, setting of this field can be automated by setting the imagePullSecrets
in a [serviceAccount](/docs/user-guide/service-accounts) resource.
Check [Add ImagePullSecrets to a Service Account](/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account) for detailed instructions.
-->

<p>对每一个使用私有仓库的 pod，都需要做以上操作。</p>

<p>但是，可以通过在 <a href="/docs/user-guide/service-accounts">serviceAccount</a> 资源中设置 imagePullSecrets 来自动设置 <code>imagePullSecrets</code>。检查 <a href="/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account">将 ImagePullSecrets 添加 Service Account</a> 以获取详细说明。</p>

<!--
You can use this in conjunction with a per-node `.docker/config.json`.  The credentials
will be merged.  This approach will work on Google Kubernetes Engine.
-->

<p>可以将其与每个节点 <code>.docker/config.json</code> 结合使用。凭据将被合并。这种方法适用于 Google Kubernetes Engine。</p>

<!--
### Use Cases
-->

<h3 id="使用场景">使用场景</h3>

<!--
There are a number of solutions for configuring private registries.  Here are some
common use cases and suggested solutions.
-->

<p>配置私有仓库有多种方案，以下是一些常用场景和建议的解决方案。</p>

<!--
1. Cluster running only non-proprietary (e.g. open-source) images.  No need to hide images.
   - Use public images on the Docker hub.
     - No configuration required.
     - On GCE/Google Kubernetes Engine, a local mirror is automatically used for improved speed and availability.
-->

<ol>
<li>集群运行非专有（例如 开源镜像）镜像。镜像不需要隐藏。

<ul>
<li>使用 Docker hub 上的公有镜像</li>
<li>无需配置</li>
<li>在 GCE/GKE 上会自动使用高稳定性和高速的 Docker hub 的本地 mirror</li>
</ul></li>
</ol>

<!--
1. Cluster running some proprietary images which should be hidden to those outside the company, but
   visible to all cluster users.
   - Use a hosted private [Docker registry](https://docs.docker.com/registry/).
     - It may be hosted on the [Docker Hub](https://hub.docker.com/signup), or elsewhere.
     - Manually configure .docker/config.json on each node as described above.
   - Or, run an internal private registry behind your firewall with open read access.
     - No Kubernetes configuration is required.
   - Or, when on GCE/Google Kubernetes Engine, use the project's Google Container Registry.
     - It will work better with cluster autoscaling than manual node configuration.
   - Or, on a cluster where changing the node configuration is inconvenient, use `imagePullSecrets`.
-->

<ol>
<li>集群运行一些专有镜像，这些镜像对外部公司需要隐藏，对集群用户可见

<ul>
<li>使用自主的私有 <a href="https://docs.docker.com/registry/" target="_blank">Docker registry</a>。

<ul>
<li>可以放置在 <a href="https://hub.docker.com/account/signup/" target="_blank">Docker Hub</a>,或者其他地方。</li>
<li>按照上面的描述，在每个节点手动配置 .docker/config.json。</li>
</ul></li>
<li>或者，在防火墙内运行一个内置的私有仓库，并开放读取权限。

<ul>
<li>不需要配置 Kubenretes。</li>
</ul></li>
<li>或者，在 GCE/GKE 上时，使用项目的 Google Container Registry。

<ul>
<li>使用集群自动伸缩比手动配置 node 工作的更好。</li>
</ul></li>
<li>或者，在更改集群 node 配置不方便时，使用 <code>imagePullSecrets</code>。</li>
</ul></li>
</ol>

<!--
3. Cluster with proprietary images, a few of which require stricter access control.
   - Ensure [AlwaysPullImages admission controller](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) is active. Otherwise, all Pods potentially have access to all images.
   - Move sensitive data into a "Secret" resource, instead of packaging it in an image.
-->

<ol>
<li>使用专有镜像的集群，有更严格的访问控制。

<ul>
<li>保证开启 <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages admission controller</a>。否则，所有的 pod 都可以使用镜像。</li>
<li>将敏感数据存储在 &ldquo;Secret&rdquo; 资源中，而不是打包在镜像里。</li>
</ul></li>
</ol>

<!--
4. A multi-tenant cluster where each tenant needs own private registry.
   - Ensure [AlwaysPullImages admission controller](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) is active. Otherwise, all Pods of all tenants potentially have access to all images.
   - Run a private registry with authorization required.
   - Generate registry credential for each tenant, put into secret, and populate secret to each tenant namespace.
   - The tenant adds that secret to imagePullSecrets of each namespace.
-->

<ol>
<li>多租户集群下，每个租户需要自己的私有仓库。

<ul>
<li>开启保证 <a href="/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages admission controller</a>。否则，所有租户的所有的 pod 都可以使用镜像。</li>
<li>私有仓库开启认证。</li>
<li>为每个租户获取仓库凭证，放置在 secret 中，并发布到每个租户的命名空间下。</li>
<li>租户将 secret 增加到每个命名空间下的 imagePullSecrets 中。</li>
</ul></li>
</ol>



<!--
---
reviewers:
- erictune
- thockin
title: Images
content_template: templates/concept
weight: 10
---
-->





<!--
If you need access to multiple registries, you can create one secret for each registry.
Kubelet will merge any `imagePullSecrets` into a single virtual `.docker/config.json`
-->

<p>如果需要访问多个仓库，则可以为每个仓库创建一个 secret。Kubelet 将任何 <code>imagePullSecrets</code> 合并为单个虚拟 <code>.docker/config.json</code> 文件。</p>









    
            
  <h2>反馈</h2>
  <p class="feedback--prompt">此页是否对您有帮助？ </p>
  <button class="button feedback--yes">是</button>
  <button class="button feedback--no">否</button>
  <p class="feedback--response feedback--response__hidden">
    感谢反馈。如果您有一个关于如何使用 Kubernetes 的特定的、需要答案的问题，可以访问
    <a target="_blank" rel="noopener"
      href="https://stackoverflow.com/questions/tagged/kubernetes">
      Stack Overflow</a>.
    在 GitHub 仓库上登记新的问题
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Issue%20with%20k8s.io">
      报告问题</a>
    或者
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Improvement%20for%20k8s.io">
      提出改进建议</a>.
  </p>
  <script>
    const yes = document.querySelector('.feedback--yes');
    const no = document.querySelector('.feedback--no');
    document.querySelectorAll('.feedback--link').forEach(link => {
      link.href = link.href + window.location.pathname;
    });
    const sendFeedback = (value) => {
      if (!gtag) { console.log('!gtag'); }
      gtag('event', 'click', {
        'event_category': 'Helpful',
        'event_label': window.location.pathname,
        value
      });
    };
    const disableButtons = () => {
      yes.disabled = true;
      yes.classList.add('feedback--button__disabled');
      no.disabled = true;
      no.classList.add('feedback--button__disabled');
    };
    yes.addEventListener('click', () => {
      sendFeedback(1);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
    no.addEventListener('click', () => {
      sendFeedback(0);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
  </script>


    
            <div id="pre-footer"> 
  <hr />

  <div class="issue-button-container">
    <p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/concepts/containers/images.md?pixel" alt="Analytics" /></a></p>
    
    
    <script type="text/javascript">
    PDRTJS_settings_8345992 = {
    "id" : "8345992",
    "unique_id" : "\/zh\/docs\/concepts\/containers\/images\/",
    "title" : "镜像",
    "permalink" : "https:\/\/kubernetes.io\/zh\/docs\/concepts\/containers\/images\/"
    };
    (function(d,c,j){if(!document.getElementById(j)){var pd=d.createElement(c),s;pd.id=j;pd.src=('https:'==document.location.protocol)?'https://polldaddy.com/js/rating/rating.js':'http://i0.poll.fm/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd,s);}}(document,'script','pd-rating-js'));
    </script>
    <a href="" onclick="window.open('https://github.com/kubernetes/website/issues/new?template=bug-report.md&title=Issue%20with%20' +
    'k8s.io'+window.location.pathname)" class="button issue">报告 GitHub 问题</a>
    
    
    
    <a href="https://github.com/kubernetes/website/edit/master/content/zh/docs/concepts/containers/images.md" class="button issue">修改本页面</a>
    
  </div>
  

  <div id="lastedit" class="lastedit issue-button-container">
    页面最后一次修改于 February 15, 2020 at 2:31 PM PST 由：
    <a href="https://github.com/kubernetes/website/commit/57cdc4cbabee2dd710a606c23c4115394359ee49/">hidden original annotation (#19126)</a> (<a href="https://github.com/kubernetes/website/commits/master/content/en/docs/concepts/containers/images.md">页面历史</a>)
  </div>
  
</div>

          </div>
        </section>
    </main>
		<footer>
    <div class="light-text main-section">
        <nav>
            
            
            
            <a href="/zh/docs/home/">主页</a>
            
            <a href="/zh/blog/">博客</a>
            
            
            
            <a href="/zh/partners/">合作伙伴</a>
            
            <a href="/zh/community/">社区</a>
            
            <a href="/zh/case-studies/">案例分析</a>
            
        </nav>
        <div class="social" role="region" aria-label="Social hyperlinks">
            <div>
                <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                <a href="https://slack.k8s.io/" class="slack"><span>Slack</span></a>
            </div>
            <div>
                <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                <a href="https://discuss.kubernetes.io" class="mailing-list"><span>论坛</span></a>
                <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>事件日历</span></a>
            </div>
            <div>
                
                <a href="https://git.k8s.io/community/contributors/guide" class="button">贡献</a>
            </div>
        </div>
        <div class="miceType center">
            &copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a> 授权许可</a>
        </div>
        <div class="miceType center">
            Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">商标使用页面</a>
        </div>
        <div class="miceType center">
            ICP license: 京ICP备17074266号-3
        </div>
    </div>
</footer>

		<button class="flyout-button" onclick="kub.toggleToc()" aria-label="Toggle table of contents visibility"></button>

<script>

(function () {
    window.addEventListener('DOMContentLoaded', init)

        
        function init() {
            window.removeEventListener('DOMContentLoaded', init)
                hideNav()
        }

    function hideNav(toc){
        if (!toc) toc = document.querySelector('#docsToc')
        if (!toc) return
            var container = toc.querySelector('.container')

                
                if (container) {
                    if (container.childElementCount === 0 || toc.querySelectorAll('a.item').length === 1) {
                        toc.style.display = 'none'
                            document.getElementById('docsContent').style.width = '100%'
                    }
                } else {
                    requestAnimationFrame(function () {
                        hideNav(toc)
                    })
                }
    }
})();
</script>



    <script language="application/javascript">
      
      (function addHeadingLinks(){
        var article = document.getElementById('docsContent');
        var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(function(heading){
          if(heading.id){
            var a = document.createElement('a');
            a.innerHTML = heading.innerHTML;
            a.href = '#'+heading.id;
            a.classList.add('inpage_heading');
            heading.innerHTML = '';
            heading.appendChild(a);
          }
        });
      })();
    </script>
	</body>
</html>
