<!DOCTYPE html>
<html id="docs" lang="id" class="">
	<head>
	

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>
<meta charset="utf-8">
<title>Services, Load Balancing, dan Jaringan - Kubernetes</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#326ce5">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">









<link rel="stylesheet" href="/css/style.b7b8403eb5b1fddd0a2da2a8383d5b53e6ef81c23e4b0e292e6103bd91f9502d.css" integrity="sha256-t7hAPrWx/d0KLaKoOD1bU&#43;bvgcI&#43;Sw4pLmEDvZH5UC0=">


<link rel="stylesheet" href="/css/base_fonts.css">
<link rel="stylesheet" href="/css/jquery-ui.min.css">
<link rel="stylesheet" href="/css/callouts.css">
<link rel="stylesheet" href="/css/custom-jekyll/tags.css">



<meta name="description" content="">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:url" content="https://kubernetes.io/id/docs/concepts/services-networking/">
<meta property="og:title" content="Services, Load Balancing, dan Jaringan">
<meta name="twitter:title" content="Services, Load Balancing, dan Jaringan">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">
<script src="/js/anchor-4.1.1.min.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>
<script src="/js/jquery-ui-1.12.1.min.js"></script>
<script src="/js/bootstrap-4.3.1.min.js"></script>
<script src="/js/sweetalert-2.1.2.min.js"></script>

<script src="/js/script.js"></script>
<script src="/js/custom-jekyll/tags.js"></script>


	</head>
	<body>
		<div id="cellophane" onclick="kub.toggleMenu()"></div>

<header>
    <a href="/id/" class="logo" title="Orkestrasi Kontainer dengan Skala Produksi - Kubernetes" aria-label="Kubernetes website"></a>

    <div class="nav-buttons" data-auto-burger="primary">
        <ul class="global-nav">
            
            
            <li><a href="/id/docs/" class="active">Dokumentasi</a></li>
            
            
            
            
            
            
            
            <li><a href="/id/community/">Komunitas</a></li>
            
            <li><a href="/id/case-studies/">Studi kasus</a></li>
            
            
            
             <li>
                <a href="#">
                    Bahasa Indonesia <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="/docs/concepts/services-networking/">English</a></li>
                
                    <li><a href="/zh/docs/concepts/services-networking/">中文 Chinese</a></li>
                
                    <li><a href="/ko/docs/concepts/services-networking/">한국어 Korean</a></li>
                
                    <li><a href="/ja/docs/concepts/services-networking/">日本語 Japanese</a></li>
                
                    <li><a href="/fr/docs/concepts/services-networking/">Français</a></li>
                
                    <li><a href="/de/docs/concepts/services-networking/">Deutsch</a></li>
                
                    <li><a href="/es/docs/concepts/services-networking/">Español</a></li>
                
                </ul>
            </li>

            <li>
                <a href="#">
                    v1.17 <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    <li><a href="https://kubernetes.io/id/docs/concepts/services-networking/">v1.21</a></li>
                
                    <li><a href="https://v1-20.docs.kubernetes.io/id/docs/concepts/services-networking/">v1.20</a></li>
                
                    <li><a href="https://v1-19.docs.kubernetes.io/id/docs/concepts/services-networking/">v1.19</a></li>
                
                    <li><a href="https://v1-18.docs.kubernetes.io/id/docs/concepts/services-networking/">v1.18</a></li>
                
                    <li><a href="https://v1-17.docs.kubernetes.io/id/docs/concepts/services-networking/">v1.17</a></li>
                
                </ul>
            </li>
        </ul>
        
        <a href="/id/docs/tutorials/kubernetes-basics/" class="button" id="tryKubernetes" data-auto-burger-exclude>Mempelajari Panduan Dasar Kubernetes</a>
        

        <button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
    </div>

    <nav id="mainNav">
        <div class="main-section" data-auto-burger="primary">
         
           <div class="nav-box">
            <h3><a href="/id/docs/tutorials/hello-minikube/">Mulai</a></h3>
           <p>Siap untuk mengotori tanganmu? Yuk kita buat klaster Kubernetes sederhana yang menjalankan Node.js aplikasi "Halo Dunia".</p>

            </div>
         
           <div class="nav-box">
            <h3><a href="/id/docs/home/">Dokumentasi</a></h3>
           <p>Mengerti penggunaan Kubernetes dengan belajar konsep, tutorial, dan referensinya. Kamupun bisa <a href="/editdocs/" data-auto-burger-exclude>bantu kami perbaiki dan lengkapi dokumentasinya</a>, yuk kontribusi!</p>

            </div>
         
        </div>
        <div class="main-section" data-auto-burger="primary">
            <div class="left">
                <h5 class="github-invite">Tertarik untuk ulik kode dari Kubernetes?</h5>
                <a href="https://github.com/kubernetes/kubernetes" class="button" data-auto-burger-exclude>Lihat di GitHub</a>
            </div>

            <div class="right">
                <h5 class="github-invite">Jelajahi komunitasnya</h5>
                <div class="social">
                    <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                    <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                    <a href="http://slack.k8s.io/" class="slack"><span>Slack Slack</span></a>
                    <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                    <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                    <a href="https://discuss.kubernetes.io" class="mailing-list"><span>Forum</span></a>
                    <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>Kalender acara</span></a>
                </div>
            </div>
            <div class="clear" style="clear: both"></div>
        </div>
    </nav>
</header>

		
		
		<section id="hero" class="light-text no-sub">
			









<h1>Konsep</h1>
<h5></h5>






<div id="vendorStrip" class="light-text">
	<ul>
		
		
		<li><a href="/id/docs/home/">HOME</a></li>
		
		
		<li><a href="/id/docs/setup/">PERSIAPAN</a></li>
		
		
		<li><a href="/id/docs/concepts/" class="YAH">KONSEP</a></li>
		
		
		<li><a href="/id/docs/tutorials/">TUTORIALS</a></li>
		
		
		<li><a href="/id/docs/contribute/">BERKONTRIBUSI</a></li>
		
	</ul>
	<form id="searchBox" action="/docs/search/" role="search">
		<input type="text" id="search" name="q" placeholder="Cari" aria-label="Search">
	</form>
</div>

		</section>
		
    
		
<section id="deprecationWarning">
  <main>
    <div class="content deprecation-warning">
      <h3>
	 Kubernetes v1.17
	  dokumentasi sudah tidak dirawat lagi. Versi yang kamu lihat ini hanyalah snapshot statis. Untuk dokumentasi terkini, lihat 
	 <a href="https://kubernetes.io/docs/home/">versi terkini.</a>
      </h3>
    </div>
  </main>
</section>


    <main>
        <section id="encyclopedia">
          
<div id="docsToc">
     <div class="pi-accordion">
    	
        
        
        
        
        
         
             
                 
             
         
             
                 
             
         
             
                 
                          
                          
                 
             
         
             
         
             
         
         
        
        <a class="item" data-title="Konsep" href="/id/docs/concepts/"></a>

	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="Ikhtisar">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Apa itu Kubernetes?" href="/id/docs/concepts/overview/what-is-kubernetes/"></a>

		
	
		
			

<a class="item" data-title="Komponen-Komponen Kubernetes" href="/id/docs/concepts/overview/components/"></a>

		
	
		
			

<a class="item" data-title="API Kubernetes" href="/id/docs/concepts/overview/kubernetes-api/"></a>

		
	
		
			
<div class="item" data-title="Menggunakan Objek-Objek Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Memahami Konsep Objek-Objek yang ada pada Kubernetes" href="/id/docs/concepts/overview/working-with-objects/kubernetes-objects/"></a>

		
	
		
			

<a class="item" data-title="Pengaturan Objek Kubernetes" href="/id/docs/concepts/overview/working-with-objects/object-management/"></a>

		
	
		
			

<a class="item" data-title="Nama" href="/id/docs/concepts/overview/working-with-objects/names/"></a>

		
	
		
			

<a class="item" data-title="Namespace" href="/id/docs/concepts/overview/working-with-objects/namespaces/"></a>

		
	
		
			

<a class="item" data-title="Label dan Selektor" href="/id/docs/concepts/overview/working-with-objects/labels/"></a>

		
	
		
			

<a class="item" data-title="Anotasi" href="/id/docs/concepts/overview/working-with-objects/annotations/"></a>

		
	
		
			

<a class="item" data-title="Selektor Field" href="/id/docs/concepts/overview/working-with-objects/field-selectors/"></a>

		
	
		
			

<a class="item" data-title="Label yang Disarankan" href="/id/docs/concepts/overview/working-with-objects/common-labels/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Pengelolaan Objek dengan kubectl">
	<div class="container">
		
		
	
	
			
			
		
	
	
	
		
			

<a class="item" data-title="Pengelolaan Objek Kubernetes dengan Perintah Imperatif" href="/id/docs/concepts/overview/object-management-kubectl/imperative-command/"></a>

		
	
		
			

<a class="item" data-title="Penglolaan Objek Kubernetes Secara Imperatif dengan Menggunakan File Konfigurasi" href="/id/docs/concepts/overview/object-management-kubectl/imperative-config/"></a>

		
	
		
			

<a class="item" data-title="Pengelolaan Objek Kubernetes secara Deklaratif dengan Menggunakan File Konfigurasi" href="/id/docs/concepts/overview/object-management-kubectl/declarative-config/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Arsitektur Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Node" href="/id/docs/concepts/architecture/nodes/"></a>

		
	
		
			

<a class="item" data-title="Komunikasi Master-Node" href="/id/docs/concepts/architecture/master-node-communication/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Controllers <small>(EN)</small>" href="/docs/concepts/architecture/controller/"></a>

		
	
		
			

<a class="item" data-title="Konsep-konsep di balik Controller Manager" href="/id/docs/concepts/architecture/cloud-controller/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Kontainer">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Containers overview <small>(EN)</small>" href="/docs/concepts/containers/overview/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Images <small>(EN)</small>" href="/docs/concepts/containers/images/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Container Environment <small>(EN)</small>" href="/docs/concepts/containers/container-environment/"></a>

		
	
		
			

<a class="item" data-title="Runtime Class" href="/id/docs/concepts/containers/runtime-class/"></a>

		
	
		
			

<a class="item" data-title="Variabel Environment Kontainer" href="/id/docs/concepts/containers/container-environment-variables/"></a>

		
	
		
			

<a class="item" data-title="Lifecyle Hook pada Kontainer" href="/id/docs/concepts/containers/container-lifecycle-hooks/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Workloads">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			
<div class="item" data-title="Pods">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Pengenalan Pod" href="/id/docs/concepts/workloads/pods/pod-overview/"></a>

		
	
		
			

<a class="item" data-title="Pod" href="/id/docs/concepts/workloads/pods/pod/"></a>

		
	
		
			

<a class="item" data-title="Siklus Hidup Pod" href="/id/docs/concepts/workloads/pods/pod-lifecycle/"></a>

		
	
		
			

<a class="item" data-title="Init Container" href="/id/docs/concepts/workloads/pods/init-containers/"></a>

		
	
		
			

<a class="item" data-title="Pod Preset" href="/id/docs/concepts/workloads/pods/podpreset/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Pod Topology Spread Constraints <small>(EN)</small>" href="/docs/concepts/workloads/pods/pod-topology-spread-constraints/"></a>

		
	
		
			

<a class="item" data-title="Disrupsi" href="/id/docs/concepts/workloads/pods/disruptions/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Ephemeral Containers <small>(EN)</small>" href="/docs/concepts/workloads/pods/ephemeral-containers/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Controllers">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="ReplicaSet" href="/id/docs/concepts/workloads/controllers/replicaset/"></a>

		
	
		
			

<a class="item" data-title="ReplicationController" href="/id/docs/concepts/workloads/controllers/replicationcontroller/"></a>

		
	
		
			

<a class="item" data-title="Deployment" href="/id/docs/concepts/workloads/controllers/deployment/"></a>

		
	
		
			

<a class="item" data-title="StatefulSet" href="/id/docs/concepts/workloads/controllers/statefulset/"></a>

		
	
		
			

<a class="item" data-title="DaemonSet" href="/id/docs/concepts/workloads/controllers/daemonset/"></a>

		
	
		
			

<a class="item" data-title="Garbage Collection" href="/id/docs/concepts/workloads/controllers/garbage-collection/"></a>

		
	
		
			

<a class="item" data-title="Pengendali TTL untuk Sumber Daya yang Telah Selesai Digunakan" href="/id/docs/concepts/workloads/controllers/ttlafterfinished/"></a>

		
	
		
			

<a class="item" data-title="Job - Dijalankan Hingga Selesai" href="/id/docs/concepts/workloads/controllers/jobs-run-to-completion/"></a>

		
	
		
			

<a class="item" data-title="CronJob" href="/id/docs/concepts/workloads/controllers/cron-jobs/"></a>

		
	

	</div>
</div>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Services, Load Balancing, dan Jaringan">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="EndpointSlices <small>(EN)</small>" href="/docs/concepts/services-networking/endpoint-slices/"></a>

		
	
		
			

<a class="item" data-title="Service" href="/id/docs/concepts/services-networking/service/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Service Topology <small>(EN)</small>" href="/docs/concepts/services-networking/service-topology/"></a>

		
	
		
			

<a class="item" data-title="DNS untuk Service dan Pod" href="/id/docs/concepts/services-networking/dns-pod-service/"></a>

		
	
		
			

<a class="item" data-title="Menghubungkan aplikasi dengan Service" href="/id/docs/concepts/services-networking/connect-applications-service/"></a>

		
	
		
			

<a class="item" data-title="Ingress" href="/id/docs/concepts/services-networking/ingress/"></a>

		
	
		
			

<a class="item" data-title="Kontroler Ingress" href="/id/docs/concepts/services-networking/ingress-controllers/"></a>

		
	
		
			

<a class="item" data-title="NetworkPolicy" href="/id/docs/concepts/services-networking/network-policies/"></a>

		
	
		
			

<a class="item" data-title="Menambahkan Entry pada /etc/hosts Pod dengan HostAliases" href="/id/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="IPv4/IPv6 dual-stack <small>(EN)</small>" href="/docs/concepts/services-networking/dual-stack/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Storage">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Volume" href="/id/docs/concepts/storage/volumes/"></a>

		
	
		
			

<a class="item" data-title="Persistent Volume" href="/id/docs/concepts/storage/persistent-volumes/"></a>

		
	
		
			

<a class="item" data-title="VolumeSnapshot" href="/id/docs/concepts/storage/volume-snapshots/"></a>

		
	
		
			

<a class="item" data-title="Pengklonaan Volume CSI" href="/id/docs/concepts/storage/volume-pvc-datasource/"></a>

		
	
		
			

<a class="item" data-title="StorageClass" href="/id/docs/concepts/storage/storage-classes/"></a>

		
	
		
			

<a class="item" data-title="VolumeSnapshotClass" href="/id/docs/concepts/storage/volume-snapshot-classes/"></a>

		
	
		
			

<a class="item" data-title="Penyediaan Volume Dinamis" href="/id/docs/concepts/storage/dynamic-provisioning/"></a>

		
	
		
			

<a class="item" data-title="Limit Volume yang Spesifik terhadap Node" href="/id/docs/concepts/storage/storage-limits/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Konfigurasi">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Konfigurasi dan Penerapan Konsep" href="/id/docs/concepts/configuration/overview/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Resource Bin Packing for Extended Resources <small>(EN)</small>" href="/docs/concepts/configuration/resource-bin-packing/"></a>

		
	
		
			

<a class="item" data-title="Mengatur Sumber Daya Komputasi untuk Container" href="/id/docs/concepts/configuration/manage-compute-resources-container/"></a>

		
	
		
			

<a class="item" data-title="Overhead Pod" href="/id/docs/concepts/configuration/pod-overhead/"></a>

		
	
		
			

<a class="item" data-title="Menetapkan Pod ke Node" href="/id/docs/concepts/configuration/assign-pod-node/"></a>

		
	
		
			

<a class="item" data-title="Taint dan Toleration" href="/id/docs/concepts/configuration/taint-and-toleration/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Secrets <small>(EN)</small>" href="/docs/concepts/configuration/secret/"></a>

		
	
		
			

<a class="item" data-title="Mengatur Akses Klaster Menggunakan Berkas kubeconfig" href="/id/docs/concepts/configuration/organize-cluster-access-kubeconfig/"></a>

		
	
		
			

<a class="item" data-title="Prioritas dan Pemindahan Pod" href="/id/docs/concepts/configuration/pod-priority-preemption/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Scheduling Framework <small>(EN)</small>" href="/docs/concepts/configuration/scheduling-framework/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Keamanan">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Ikhtisar Keamanan _Cloud Native_" href="/id/docs/concepts/security/overview/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Policies">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Limit Ranges <small>(EN)</small>" href="/docs/concepts/policy/limit-range/"></a>

		
	
		
			

<a class="item" data-title="Resource Quota" href="/id/docs/concepts/policy/resource-quotas/"></a>

		
	
		
			

<a class="item" data-title="Pod Security Policy" href="/id/docs/concepts/policy/pod-security-policy/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Scheduling">
	<div class="container">
		
		
	
	
			
			
		
	
	
	
		
			

<a class="item" target="_blank" data-title="Kubernetes Scheduler <small>(EN)</small>" href="/docs/concepts/scheduling/kube-scheduler/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Scheduler Performance Tuning <small>(EN)</small>" href="/docs/concepts/scheduling/scheduler-perf-tuning/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Administrasi Klaster">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Ikhtisar Administrasi Klaster" href="/id/docs/concepts/cluster-administration/cluster-administration-overview/"></a>

		
	
		
			

<a class="item" data-title="Sertifikat" href="/id/docs/concepts/cluster-administration/certificates/"></a>

		
	
		
			

<a class="item" data-title="Penyedia Layanan Cloud" href="/id/docs/concepts/cluster-administration/cloud-providers/"></a>

		
	
		
			

<a class="item" data-title="Mengelola Resource" href="/id/docs/concepts/cluster-administration/manage-deployment/"></a>

		
	
		
			

<a class="item" data-title="Jaringan Kluster" href="/id/docs/concepts/cluster-administration/networking/"></a>

		
	
		
			

<a class="item" data-title="Arsitektur Logging" href="/id/docs/concepts/cluster-administration/logging/"></a>

		
	
		
			

<a class="item" target="_blank" data-title="Metrics For The Kubernetes Control Plane <small>(EN)</small>" href="/docs/concepts/cluster-administration/monitoring/"></a>

		
	
		
			

<a class="item" data-title="Konfigurasi Garbage Collection pada kubelet" href="/id/docs/concepts/cluster-administration/kubelet-garbage-collection/"></a>

		
	
		
			

<a class="item" data-title="Federation" href="/id/docs/concepts/cluster-administration/federation/"></a>

		
	
		
			

<a class="item" data-title="Berbagai Proxy di Kubernetes" href="/id/docs/concepts/cluster-administration/proxies/"></a>

		
	
		
			

<a class="item" data-title="Metrik controller manager" href="/id/docs/concepts/cluster-administration/controller-metrics/"></a>

		
	
		
			

<a class="item" data-title="Instalasi Add-ons" href="/id/docs/concepts/cluster-administration/addons/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Memperluas Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Memperluas Klaster Kubernetes Kamu" href="/id/docs/concepts/extend-kubernetes/extend-cluster/"></a>

		
	
		
			
<div class="item" data-title="Memperluas API Kubernetes">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Memperluas Kubernetes API dengan Lapisan Agregasi" href="/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/"></a>

		
	
		
			

<a class="item" data-title="Custom Resource" href="/id/docs/concepts/extend-kubernetes/api-extension/custom-resources/"></a>

		
	

	</div>
</div>

		
	
		
			
<div class="item" data-title="Ekstensi Komputasi, Penyimpanan, dan Jaringan">
	<div class="container">
		
		
	
	
			
			
			
			
			
		
	
	
	
		
			

<a class="item" data-title="Plugin Jaringan" href="/id/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/"></a>

		
	
		
			

<a class="item" data-title="Plugin Perangkat" href="/id/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/"></a>

		
	

	</div>
</div>

		
	
		
			

<a class="item" target="_blank" data-title="Operator pattern <small>(EN)</small>" href="/docs/concepts/extend-kubernetes/operator/"></a>

		
	
		
			

<a class="item" data-title="Service Catalog" href="/id/docs/concepts/extend-kubernetes/service-catalog/"></a>

		
	
		
			

<a class="item" data-title="Poseidon-Firmament - Sebuah Penjadwal Alternatif" href="/id/docs/concepts/extend-kubernetes/poseidon-firmament-alternate-scheduler/"></a>

		
	

	</div>
</div>

		
	





     </div> 
    <button class="push-menu-close-button" onclick="kub.toggleToc()"></button>
</div> 


          <div id="docsContent">
            
    
    
    
    
    
    
	 
    
    
    
<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/id/docs/concepts/services-networking/service.md" id="editPageButton" target="_blank">
    Edit This Page
  </a>
</p>

<h1>Service</h1>



<p><a href="/docs/concepts/workloads/pods/pod/"><code>Pod</code></a> pada Kubernetes bersifat <em>mortal</em>.
Artinya apabila <em>pod-pod</em> tersebut dibuat dan kemudian mati, <em>pod-pod</em> tersebut
tidak akan dihidupkan kembali. <a href="/docs/concepts/workloads/controllers/replicaset/"><code>ReplicaSets</code></a> secara
khusus bertugas membuat dan menghapus <code>Pod</code> secara dinamsi (misalnya, pada proses <em>scaling out</em> atau <em>scaling in</em>).
Meskipun setiap <code>Pod</code> memiliki alamat IP-nya masing-masing, kamu tidak dapat mengandalkan alamat IP
yang diberikan pada <em>pod-pod</em> tersebut, karena alamat IP yang diberikan tidak stabil.
Hal ini kemudian menimbulkan pertanyaan baru: apabila sebuah sekumpulan <code>Pod</code> (yang selanjutnya kita sebut <em>backend</em>)
menyediakan <em>service</em> bagi sebuah sekumpulan <code>Pod</code> lain (yang selanjutnya kita sebut <em>frontend</em>) di dalam
klaster Kubernetes, bagaimana cara <em>frontend</em> menemukan <em>backend</em> mana yang digunakan?</p>

<p>Inilah alasan kenapa <code>Service</code> ada.</p>

<p>Sebuah <code>Service</code> pada Kubernetes adalah sebuah abstraksi yang memberikan definisi
set logis yang terdiri beberapa <code>Pod</code> serta <em>policy</em> bagaimana cara kamu mengakses sekumpulan <code>Pod</code> tadi - seringkali disebut sebagai <em>microservices</em>.
Set <code>Pod</code> yang dirujuk oleh suatu <code>Service</code> (biasanya) ditentukan oleh sebuah <a href="/docs/concepts/overview/working-with-objects/labels/#label-selectors"><code>Label Selector</code></a>
(lihat penjelasan di bawah untuk mengetahui alasan kenapa kamu mungkin saja membutuhkan <code>Service</code> tanpa
sebuah <em>selector</em>).</p>

<p>Sebagai contoh, misalnya terdapat sebuah <em>backend</em> yang menyediakan fungsionalitas <em>image-processing</em>
yang memiliki 3 buah <em>replica</em>. <em>Replica-replica</em> tadi sifatnya sepadan - dengan kata lain <em>frontend</em>
tidak peduli <em>backend</em> manakah yang digunakan. Meskipun <code>Pod</code> penyusun sekumpulan <em>backend</em> bisa berubah,
<em>frontend</em> tidak perlu peduli bagaimana proses ini dijalankan atau menyimpan <em>list</em> dari <em>backend-backend</em>
yang ada saat itu. <code>Service</code> memiliki tujuan untuk <em>decouple</em> mekanisme ini.</p>

<p>Untuk aplikasi yang dijalankan di atas Kubernetes, Kubernetes menyediakan API <em>endpoint</em> sederhana
yang terus diubah apabila <em>state</em> sebuah sekumpulan <code>Pod</code> di dalam suatu <code>Service</code> berubah. Untuk
aplikasi <em>non-native</em>, Kubernetes menyediakan <em>bridge</em> yang berbasis <em>virtual-IP</em> bagi <code>Service</code>
yang diarahkan pada <code>Pod</code> <em>backend</em>.</p>









<ul id="markdown-toc">










<li><a href="#mendefinisikan-sebuah-service">Mendefinisikan sebuah <code>Service</code></a></li>




<li><a href="#ip-virtual-dan-proxy-service">IP Virtual dan <em>proxy</em> <code>Service</code></a></li>




<li><a href="#multi-port-services"><em>Multi-Port Services</em></a></li>




<li><a href="#memilih-sendiri-alamat-ip-yang-kamu-inginkan">Memilih sendiri alamat IP yang kamu inginkan</a></li>




<li><a href="#discovering-services"><em>Discovering services</em></a></li>




<li><a href="#service-headless"><code>Service</code> <em>headless</em></a></li>




<li><a href="#mekanisme-publish-service-jenis-jenis-service">Mekanisme <em>publish</em> <code>Service</code> - jenis-jenis <code>Service</code></a></li>




<li><a href="#kekurangan">Kekurangan</a></li>




<li><a href="#pengerjaan-lebih-lanjut">Pengerjaan lebih lanjut</a></li>




<li><a href="#detail-mendalam-mengenai-ip-virtual">Detail mendalam mengenai IP virtual</a></li>




<li><a href="#objek-api">Objek API</a></li>




<li><a href="#protokol-yang-tersedia">Protokol yang didukung</a></li>




















<li><a href="#selanjutnya">Selanjutnya</a></li>



</ul>


<h2 id="mendefinisikan-sebuah-service">Mendefinisikan sebuah <code>Service</code></h2>

<p>Sebuah <code>Service</code> di Kubernetes adalah sebuah objek REST, layaknya sebuah <code>Pod</code>. Seperti semua
objek <em>REST</em>, definisi <code>Service</code> dapat dikirim dengan <em>method POST</em> pada <em>apiserver</em> untuk membuat
sebuah instans baru. Sebagai contoh, misalnya saja kamu memiliki satu sekumpulan <code>Pod</code> yang mengekspos <em>port</em>
9376 dan memiliki <em>label</em> <code>&quot;app=MyApp&quot;</code>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre></div>
<p>Spesifikasi ini akan ditranslasikan sebagai sebuah objek <code>Service</code> baru dengan nama <code>&quot;my-service&quot;</code>
dengan <em>target port</em> 9376 pada setiap <code>Pod</code> yang memiliki <em>label</em> <code>&quot;app=MyApp&quot;</code>. <code>Service</code> ini
juga akan memiliki alamat IP tersendiri (yang terkadang disebut sebagai <em>&ldquo;cluster IP&rdquo;</em>), yang nantinya
akan digunakan oleh <em>service proxy</em> (lihat di bagian bawah). <em>Selector</em> pada <code>Service</code> akan selalu dievaluasi
dan hasilnya akan kembali dikirim dengan menggunakan <em>method POST</em> ke objek <code>Endpoints</code>
yang juga disebut <code>&quot;my-service&quot;</code>.</p>

<p>Perhatikan bahwa sebuah <code>Service</code> dapat melakukan pemetaan setiap <em>incoming port</em> pada <code>targetPort</code>
mana pun. Secara <em>default</em>, <em>field</em> <code>targetPort</code> akan memiliki <em>value</em> yang sama dengan <em>value</em> dari <em>field</em> <code>port</code>.
Hal menarik lainnya adalah <em>value</em> dari <code>targetPort</code> bisa saja berupa string yang merujuk pada nama
dari <em>port</em> yang didefinisikan pada <code>Pod</code> <em>backend</em>. Nomor <em>port</em> yang diberikan pada <em>port</em> dengan nama
tadi bisa saja memiliki nilai yang berbeda di setiap <code>Pod</code> <em>backend</em>. Hal ini memberikan fleksibilitas
pada saat kamu melakukan <em>deploy</em> atau melakukan perubahan terhadap <code>Service</code>. Misalnya saja suatu saat
kamu ingin mengubah nomor <em>port</em> yang ada pada <code>Pod</code> <em>backend</em> pada rilis selanjutnya tanpa menyebabkan
permasalahan pada sisi klien.</p>

<p>Secara <em>default</em>, protokol yang digunakan pada <em>service</em> adalah <code>TCP</code>, tapi kamu bisa saja menggunakan
<a href="#protokol-yang-tersedia">protokol yang tersedia</a>. Karena banyak <code>Service</code> memiliki kebutuhan untuk
mengekspos lebih dari sebuah <em>port</em>, Kubernetes menawarkan definisi <em>multiple</em> <em>port</em> pada sebuah objek
<em>Service</em>. Setiap definisi <em>port</em> dapat memiliki protokol yang berbeda.</p>

<h3 id="service-tanpa-selector"><code>Service</code> tanpa <em>selector</em></h3>

<p>Secara umum, <code>Service</code> memberikan abstraksi mekanisme yang dilakukan untuk mengakses <code>Pod</code>, tapi
mereka juga melakukan abstraksi bagi <em>backend</em> lainnya. Misalnya saja:</p>

<ul>
<li>Kamu ingin memiliki sebuah basis data eksternal di <em>environment</em> <em>production</em> tapi pada tahap <em>test</em>,
kamu ingin menggunakan basis datamu sendiri.</li>
<li>Kamu ingin merujuk <em>service</em> kamu pada <em>service</em> lainnya yang berada pada
<a href="/docs/concepts/overview/working-with-objects/namespaces/"><em>Namespace</em></a> yang berbeda atau bahkan klaster yang berbeda.</li>
<li>Kamu melakukan migrasi <em>workloads</em> ke Kubernetes dan beberapa <em>backend</em> yang kamu miliki masih
berada di luar klaster Kubernetes.</li>
</ul>

<p>Berdasarkan skenario-skenario di atas, kamu dapat membuat sebuah <code>Service</code> tanpa <em>selector</em>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre></div>
<p>Karena <code>Service</code> ini tidak memiliki <em>selector</em>, objek <code>Endpoints</code> bagi <code>Service</code> ini tidak akan dibuat.
Dengan demikian, kamu bisa membuat <code>Endpoints</code> yang kamu inginkan:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Endpoints<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>subsets:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>addresses:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>ip:<span style="color:#bbb"> </span><span style="color:#666">1.2.3.4</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>port:<span style="color:#bbb"> </span><span style="color:#666">9376</span></code></pre></div>
<blockquote class="note">
  <div><strong>Catatan:</strong> Perhatikan bahwa alamat IP yang kamu buat untuk <code>Endpoints</code> tidak boleh berupa
<em>loopback</em> (127.0.0.0/8), <em>link-local</em> (169.254.0.0/16), atau <em>link-local multicast</em> (224.0.0.0/24).
Alamat IP tersebut juga tidak boleh berupa <em>cluster IP</em> dari <code>Service</code> Kubernetes lainnya,
karena <code>kube-proxy</code> belum menyediakan dukungan IP virtual sebagai <em>destination</em>.</div>
</blockquote>

<p>Cara mengakses suatu <code>Service</code> tanpa <em>selector</em> sama saja dengan mengakses suatu <code>Service</code>
dengan <em>selector</em>. Trafik yang ada akan di-<em>route</em> ke <code>Endpoints</code> yang dispesifikasikan oleh
pengguna (dalam contoh kali ini adalah <code>1.2.3.4:9376</code>).</p>

<p>Sebuah <code>ExternalName</code> <code>Service</code> merupakan kasus spesial dari <code>Service</code>
dimana <code>Service</code> tidak memiliki <em>selector</em> dan menggunakan penamaan <em>DNS</em>. Untuk
informasi lebih lanjut silahkan baca bagian <a href="#externalname">ExternalName</a>.</p>

<h2 id="ip-virtual-dan-proxy-service">IP Virtual dan <em>proxy</em> <code>Service</code></h2>

<p>Setiap <em>node</em> di klaster Kubernetes menjalankan <code>kube-proxy</code>. <code>kube-proxy</code>
bertanggung jawab terhadap implementasi IP virtual bagi <em>Services</em> dengan tipe
selain <a href="#externalname"><code>ExternalName</code></a>.</p>

<p>Pada Kubernetes versi v1.0, <em>Services</em> adalah &ldquo;layer 4&rdquo; (TCP/UDP pada IP), <em>proxy</em>
yang digunakan murni berada pada <em>userspace</em>. Pada Kubernetes v1.1, API <code>Ingress</code>
ditambahkan untuk merepresentasikan &ldquo;layer 7&rdquo;(HTTP), <em>proxy</em> <code>iptables</code> juga ditambahkan
dan menjadi mode operasi <em>default</em> sejak Kubernetes v1.2. Pada Kubernetes v1.8.0-beta.0,
<em>proxy</em> <em>ipvs</em> juga ditambahkan.</p>

<h3 id="mode-proxy-userspace">Mode <em>Proxy</em>: <em>userspace</em></h3>

<p>Pada mode ini, <code>kube-proxy</code> mengamati master Kubernetes apabila terjadi penambahan
atau penghapusan objek <code>Service</code> dan <code>Endpoints</code>. Untuk setiap <code>Service</code>, <code>kube-proxy</code>
akan membuka sebuah <em>port</em> (yang dipilih secara acak) pada <em>node</em> lokal. Koneksi
pada <em>&ldquo;proxy port&rdquo;</em> ini akan dihubungkan pada salah satu <code>Pod</code> <em>backend</em> dari <code>Service</code>
(yang tercatat pada <code>Endpoints</code>). <code>Pod</code> <em>backend</em> yang akan digunakan akan diputuskan berdasarkan
<code>SessionAffinity</code> pada <code>Service</code>. Langkah terakhir yang dilakukan oleh <code>kube-proxy</code>
adalah melakukan instalasi <em>rules</em> <code>iptables</code> yang akan mengarahkan trafik yang ada pada
<code>clusterIP</code> (IP virtual) dan <em>port</em> dari <code>Service</code> serta melakukan <em>redirect</em> trafik ke <em>proxy</em>
yang memproksikan <code>Pod</code> <em>backend</em>. Secara <em>default</em>, mekanisme <em>routing</em> yang dipakai adalah
<em>round robin</em>.</p>

<p><img src="/images/docs/services-userspace-overview.svg" alt="Ikhtisar diagram _Services_ pada _proxy_ _userspace_" /></p>

<h3 id="mode-proxy-iptables">Mode <em>Proxy</em>: iptables</h3>

<p>Pada mode ini, <code>kube-proxy</code> mengamati master Kubernetes apabila terjadi penambahan
atau penghapusan objek <code>Service</code> dan <code>Endpoints</code>. Untuk setiap <code>Service</code>,
<code>kube-proxy</code> akan melakukan instalasi <em>rules</em> <code>iptables</code> yang akan mengarahkan
trafik ke <code>clusterIP</code> (IP virtual) dan <em>port</em> dari <code>Service</code>. Untuk setiap objek <code>Endpoints</code>,
<code>kube-proxy</code> akan melakukan instalasi <em>rules</em> <code>iptables</code> yang akan memilih satu buah <code>Pod</code>
<em>backend</em>. Secara <em>default</em>, pemilihan <em>backend</em> ini dilakukan secara acak.</p>

<p>Tentu saja, <code>iptables</code> yang digunakan tidak boleh melakukan <em>switching</em>
antara <em>userspace</em> dan <em>kernelspace</em>, mekanisme ini harus lebih kokoh dan lebih cepat
dibandingkan dengan <em>userspace</em> <em>proxy</em>. Meskipun begitu, berbeda dengan mekanisme
<em>proxy</em> <em>userspace</em>, <em>proxy</em> <code>iptables</code> tidak bisa secara langsung menjalankan mekanisme
<em>retry</em> ke <code>Pod</code> lain apabila <code>Pod</code> yang sudah dipilih sebelumnya tidak memberikan respons,
dengan kata lain hal ini akan sangat bergantung pada
<a href="/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#defining-readiness-probes">readiness probes</a>.</p>

<p><img src="/images/docs/services-iptables-overview.svg" alt="Ikhtisar diagram _Services_ pada _proxy_ `iptables`" /></p>

<h3 id="mode-proxy-ipvs">Mode <em>Proxy</em>: ipvs</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.9</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>beta</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="beta">
Fitur ini berada dalam tingkatan beta, yang artinya:</p>

<ul>
<li>Nama dari versi ini mengandung string <code>beta</code> (misalnya <code>v2beta3</code>).</li>
<li>Kode yang ada sudah melalui mekanisme <em>testing</em> yang cukup baik. Menggunakan fitur ini dianggap cukup aman. Fitur ini diekspos secara <em>default</em>.</li>
<li>Ketersediaan untuk fitur secara menyeluruh tidak akan dihapus, meskipun begitu detail untuk suatu fitur bisa saja berubah.</li>
<li>Skema dan/atau semantik dari suatu obyek mungkin saja berubah tanpa memerhatikan kompatibilitas pada rilis <em>beta</em> selanjutnya.
Jika hal ini terjadi, kami akan menyediakan suatu instruksi untuk melakukan migrasi di versi rilis selanjutnya. Hal ini bisa saja terdiri dari penghapusan, pengubahan, ataupun pembuatan
obyek API. Proses pengubahan mungkin saja membutuhkan pemikiran yang matang. Dampak proses ini bisa saja menyebabkan <em>downtime</em> aplikasi yang bergantung pada fitur ini.</li>
<li><strong>Kami mohon untuk mencoba versi <em>beta</em> yang kami sediakan dan berikan masukan terhadap fitur yang kamu pakai! Apabila fitur tersebut sudah tidak lagi berada di dalam tingkatan <em>beta</em> perubahan yang kami buat terhadap fitur tersebut bisa jadi tidak lagi dapat digunakan</strong></li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Pada mode ini, <code>kube-proxy</code> mengamati <em>Services</em> dan <code>Endpoints</code>, kemudian memanggil
<em>interface</em> <em>netlink</em> untuk membuat <em>rules</em> <em>ipvs</em> yang sesuai serta melakukan sinkronisasi
<em>rules</em> <em>ipvs</em> dengan <em>Services</em> dan <code>Endpoints</code> Kubernetes secara periodik, untuk memastikan
status <em>ipvs</em> konsisten dengan apa yang diharapkan. Ketika sebuah <em>Services</em> diakses,
trafik yang ada akan diarahkan ke salah satu <code>Pod</code> <em>backend</em>.</p>

<p>Sama halnya dengan <code>iptables</code>, <em>ipvs</em> juga berdasarkan pada fungsi <em>hook</em> <em>netfilter</em>,
bedanya adalah <em>ipvs</em> menggunakan struktur data <em>hash table</em> dan bekerja di <em>kernelspace</em>.
Dengan kata lain <em>ipvs</em> melakukan <em>redirect</em> trafik dengan lebih cepat dan dengan performa yang lebih
baik ketika melakukan sinkronisasi <em>rules</em> <em>proxy</em>. Selain itu, <em>ipvs</em> juga menyediakan
lebih banyak opsi algoritma <em>load balancing</em>:</p>

<ul>
<li><code>rr</code>: round-robin</li>
<li><code>lc</code>: least connection</li>
<li><code>dh</code>: destination hashing</li>
<li><code>sh</code>: source hashing</li>
<li><code>sed</code>: shortest expected delay</li>
<li><code>nq</code>: never queue</li>
</ul>

<blockquote class="note">
  <div><strong>Catatan:</strong> Mode <em>ipvs</em> menggunakan <em>module</em> <em>IPVS</em> <em>kernel</em> yang diinstal pada <em>node</em>
sebelum <code>kube-proxy</code> dijalankan. Ketika <code>kube-proxy</code> dijalankan dengan mode <em>proxy</em> <em>ipvs</em>,
<code>kube-proxy</code> akan melakukan proses validasi, apakah <em>module</em> <em>IPVS</em> sudah diinstal di <em>node</em>,
jika <em>module</em> tersebut belum diinstal, maka <code>kube-proxy</code> akan menggunakan mode <code>iptables</code>.</div>
</blockquote>

<p><img src="/images/docs/services-ipvs-overview.svg" alt="Ikhtisar diagram _Services_ pada _proxy_ _ipvs_" /></p>

<p>Dari sekian model <em>proxy</em> yang ada, trafik <em>inbound</em> apa pun yang ada diterima oleh <em>IP:Port</em> pada <code>Service</code>
akan dilanjutkan melalui <em>proxy</em> pada <em>backend</em> yang sesuai, dan klien tidak perlu mengetahui
apa informasi mendetail soal Kubernetes, <code>Service</code>, atau <code>Pod</code>. afinitas <em>session</em> (<em>session affinity</em>) berbasis
<em>Client-IP</em> dapat dipilih dengan cara menerapkan nilai <em>&ldquo;ClientIP&rdquo;</em> pada <code>service.spec.sessionAffinity</code>
(nilai <em>default</em> untuk hal ini adalah <em>&ldquo;None&rdquo;</em>), kamu juga dapat mengatur nilai maximum <em>session</em>
<em>timeout</em> yang ada dengan mengatur opsi <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> jika
sebelumnya kamu sudah menerapkan nilai <em>&ldquo;ClusterIP&rdquo;</em> pada <code>service.spec.sessionAffinity</code>
(nilai <em>default</em> untuk opsi ini adalah <em>&ldquo;10800&rdquo;</em>).</p>

<h2 id="multi-port-services"><em>Multi-Port Services</em></h2>

<p>Banyak <em>Services</em> dengan kebutuhan untuk mengekspos lebih dari satu <em>port</em>.
Untuk kebutuhan inilah, Kubernetes mendukung <em>multiple</em> <em>port</em> <em>definitions</em> pada objek <code>Service</code>.
Ketika menggunakan <em>multiple</em> <em>port</em>, kamu harus memberikan nama pada setiap <em>port</em> yang didefinisikan,
sehingga <em>Endpoint</em> yang dibentuk tidak ambigu. Contoh:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">    </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>https<span style="color:#bbb">
</span><span style="color:#bbb">    </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span>port:<span style="color:#bbb"> </span><span style="color:#666">443</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9377</span></code></pre></div>
<p>Perhatikan bahwa penamaan <em>port</em> hanya boleh terdiri dari karakter <em>alphanumeric</em> <em>lowercase</em>
dan <em>-</em>, serta harus dimulai dan diakhiri dengan karakter <em>alphanumeric</em>, misalnya saja <code>123-abc</code> dan <code>web</code>
merupakan penamaan yang valid, tapi <code>123_abc</code> dan <code>-web</code> bukan merupakan penamaan yang valid.</p>

<h2 id="memilih-sendiri-alamat-ip-yang-kamu-inginkan">Memilih sendiri alamat IP yang kamu inginkan</h2>

<p>Kamu dapat memberikan spesifikasi alamat <em>cluster IP</em> yang kamu inginkan
sebagai bagian dari <em>request</em> pembuatan objek <code>Service</code>. Untuk melakukan hal ini,
kamu harus mengisi <em>fields</em> <code>.spec.clusterIP</code> field. Contoh penggunaannya adalah sebagai berikut,
misalnya saja kamu sudah memiliki <em>entry</em> DNS yang ingin kamu gunakan kembali,
atau sebuah sistem <em>legacy</em> yang sudah diatur pada alamat IP spesifik
dan sulit untuk diubah. Alamat IP yang ingin digunakan pengguna haruslah merupakan alamat IP
yang valid dan berada di dalam <em>range</em> <em>CIDR</em> <code>service-cluster-ip-range</code> yang dispesifikasikan di dalam
penanda yang diberikan <em>apiserver</em>. Jika <em>value</em> yang diberikan tidak valid, <em>apiserver</em> akan
mengembalikan <em>response</em> <em>code</em> HTTP <em>422</em> yang mengindikasikan <em>value</em> yang diberikan tidak valid.</p>

<h3 id="mengapa-tidak-menggunakan-dns-round-robin">Mengapa tidak menggunakan DNS <em>round-robin</em>?</h3>

<p>Pertanyaan yang selalu muncul adalah kenapa kita menggunakan IP virtual dan bukan
DNS <em>round-robin</em> standar? Terdapat beberapa alasan dibalik semua itu:</p>

<ul>
<li>Terdapat sejarah panjang dimana <em>library</em> DNS tidak mengikuti <em>TTL</em> DNS dan
 melakukan <em>caching</em> hasil dari <em>lookup</em> yang dilakukan.</li>
<li>Banyak aplikasi yang melakukan <em>lookup</em> DNS hanya sekali dan kemudian melakukan <em>cache</em> hasil yang diperoleh.</li>
<li>Bahkan apabila aplikasi dan <em>library</em> melakukan resolusi ulang yang <em>proper</em>, <em>load</em> dari setiap
 klien yang melakukan resolusi ulang DNS akan sulit untuk di <em>manage</em>.</li>
</ul>

<p>Kami berusaha untuk mengurangi ketertarikan pengguna untuk melakukan yang mungkin akan menyusahkan pengguna.
Dengan demikian, apabila terdapat justifikasi yang cukup kuat, kami mungkin saja memberikan implementasi
alternatif yang ada.</p>

<h2 id="discovering-services"><em>Discovering services</em></h2>

<p>Kubernetes mendukung 2 buah mode primer untuk melakukan <code>Service</code> - variabel <em>environment</em> dan DNS.</p>

<h3 id="variabel-environment">Variabel <em>Environment</em></h3>

<p>Ketika sebuah <code>Pod</code> dijalankan pada <em>node</em>, <em>kubelet</em> menambahkan seperangkat variabel <em>environment</em>
untuk setiap <code>Service</code> yang aktif. <em>Environment</em> yang didukung adalah <a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank">Docker links compatible</a> variabel (perhatikan
<a href="http://releases.k8s.io/v1.17.17/pkg/kubelet/envvars/envvars.go#L49" target="_blank">makeLinkVariables</a>)
dan variabel <code>{SVCNAME}_SERVICE_HOST</code> dan <code>{SVCNAME}_SERVICE_PORT</code>, dinama nama <code>Service</code> akan diubah
menjadi huruf kapital dan tanda <em>minus</em>  akan diubah menjadi <em>underscore</em>.</p>

<p>Sebagai contoh, <code>Service</code> <code>&quot;redis-master&quot;</code> yang mengekspos <em>port</em> TCP 6379 serta <em>alamat</em>
<em>cluster IP</em> <em>10.0.0.11</em> akan memiliki <em>environment</em> sebagai berikut:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">REDIS_MASTER_SERVICE_HOST</span><span style="color:#666">=</span><span style="color:#666">10</span>.0.0.11
<span style="color:#b8860b">REDIS_MASTER_SERVICE_PORT</span><span style="color:#666">=</span><span style="color:#666">6379</span>
<span style="color:#b8860b">REDIS_MASTER_PORT</span><span style="color:#666">=</span>tcp://10.0.0.11:6379
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP</span><span style="color:#666">=</span>tcp://10.0.0.11:6379
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style="color:#666">=</span>tcp
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_PORT</span><span style="color:#666">=</span><span style="color:#666">6379</span>
<span style="color:#b8860b">REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style="color:#666">=</span><span style="color:#666">10</span>.0.0.11</code></pre></div>
<p>Hal ini merupakan kebutuhan yang urutannya harus diperhatikan - <code>Service</code> apa pun yang
akan diakses oleh sebuah <code>Pod</code> harus dibuat sebelum <code>Pod</code> tersebut dibuat,
jika tidak variabel <em>environment</em> tidak akan diinisiasi.
Meskipun begitu, DNS tidak memiliki keterbatasan ini.</p>

<h3 id="dns">DNS</h3>

<p>Salah satu <a href="/docs/concepts/cluster-administration/addons/"><em>add-on</em></a> opsional
(meskipun sangat dianjurkan) adalah server DNS. Server DNS bertugas untuk mengamati apakah
terdapat objek <code>Service</code> baru yang dibuat dan kemudian bertugas menyediakan DNS baru untuk
<em>Service</em> tersebut. Jika DNS ini diaktifkan untuk seluruh klaster, maka semua <code>Pod</code> akan secara otomatis
dapat melakukan resolusi DNS.</p>

<p>Sebagai contoh, apabila kamu memiliki sebuah <code>Service</code> dengan nama <code>&quot;my-service&quot;</code> pada <em>Namespace</em>
<em>&ldquo;my-ns&rdquo;</em>, maka <em>record</em> DNS <code>&quot;my-service.my-ns&quot;</code> akan dibuat. <code>Pod</code> yang berada di dalam
<em>Namespace</em> <em>&ldquo;my-ns&rdquo;</em> dapat langsung melakukan <em>lookup</em> dengan hanya menggunakan <code>&quot;my-service&quot;</code>.
Sedangkan <code>Pod</code> yang berada di luar <em>Namespace</em> <em>my-ns&rdquo;</em> harus menggunakan <code>&quot;my-service.my-ns&quot;</code>.
Hasil dari resolusi ini menrupakan <em>cluster IP</em>.</p>

<p>Kubernetes juga menyediakan <em>record</em> DNS SRV (service) untuk <em>named ports</em>.  Jika
<em>Service</em> <code>&quot;my-service.my-ns&quot;</code> memiliki <em>port</em> dengan nama <code>&quot;http&quot;</code> dengan protokol <code>TCP</code>,
kamu dapat melakukan <em>query</em> DNS SRV untuk <code>&quot;_http._tcp.my-service.my-ns&quot;</code> untuk mengetahui
nomor <em>port</em> yang digunakan oleh <em>http</em>.</p>

<p>Server DNS Kubernetes adalah satu-satunya cara untuk mengakses
<em>Service</em> dengan tipe <code>ExternalName</code>. Informasi lebih lanjut tersedia di
<a href="/docs/concepts/services-networking/dns-pod-service/">DNS <em>Pods</em> dan <em>Services</em></a>.</p>

<h2 id="service-headless"><code>Service</code> <em>headless</em></h2>

<p>Terkadang kamu tidak membutuhkan mekanisme <em>load-balancing</em> dan sebuah <em>single</em> IP <em>Sevice</em>.
Dalam kasus ini, kamu dapat membuat <em>&ldquo;headless&rdquo;</em> <code>Service</code> dengan cara memberikan spesifikasi
<em>None</em> pada <em>cluster IP</em> (<code>.spec.clusterIP</code>).</p>

<p>Opsi ini memungkinkan pengguna mengurangi ketergantungan terhadap sistem Kubernetes
dengan cara memberikan kebebasan untuk mekanisme <em>service discovery</em>. Aplikasi akan
tetap membutuhkan mekanisme <em>self-registration</em> dan <em>adapter service discovery</em>
lain yang dapat digunakan berdasarkan API ini.</p>

<p>Untuk <code>Service</code> <em>&ldquo;headless&rdquo;</em> alokasi <em>cluster IP</em> tidak dilakukan dan <code>kube-proxy</code>
tidak me-<em>manage</em> <em>Service-Service</em>, serta tidak terdapat mekanisme <em>load balancing</em>
yang dilakukan. Bagaimana konfigurasi otomatis bagi DNS dilakukan bergantung pada
apakah <code>Service</code> tersebut memiliki <em>selector</em> yang dispesifikasikan.</p>

<h3 id="dengan-selector">Dengan <em>selector</em></h3>

<p>Untuk <code>Service</code> <em>&ldquo;headless&rdquo;</em> dengan <em>selector</em>, kontroler <code>Endpoints</code> akan membuat suatu
<em>record</em> <code>Endpoints</code> di API, serta melakukan modifikasi konfigurasi DNS untuk mengembalikan
<em>A records (alamat)</em> yang merujuk secara langsung pada <code>Pod</code> <em>backend</em>.</p>

<h3 id="tanpa-selector">Tanpa <em>selector</em></h3>

<p>Untuk <code>Service</code> <em>&ldquo;headless&rdquo;</em> tanpa  <em>selector</em>, kontroler <code>Endpoints</code>
tidak akan membuat <em>record</em> <em>Enpoints</em>. Meskipun demikian,
sistem DNS tetap melakukan konfigurasi salah satu dari:</p>

<ul>
<li><em>record</em> CNAME untuk <a href="#externalname"><code>ExternalName</code></a>-tipe services.</li>
<li><em>record</em> untuk semua <code>Endpoints</code> yang memiliki nama <code>Service</code> yang sama, untuk
tipe lainnya.</li>
</ul>

<h2 id="mekanisme-publish-service-jenis-jenis-service">Mekanisme <em>publish</em> <code>Service</code> - jenis-jenis <code>Service</code></h2>

<p>Untuk beberapa bagian dari aplikasi yang kamu miliki (misalnya saja, <em>frontend</em>),
bisa saja kamu memiliki kebutuhan untuk mengekspos <code>Service</code> yang kamu miliki
ke alamat IP eksternal (di luar klaster Kubernetes).</p>

<p><code>ServiceTypes</code> yang ada pada Kubernetes memungkinkan kamu untuk menentukan
jenis <code>Service</code> apakah yang kamu butuhkan. Secara <em>default</em>, jenis <code>Service</code>
yang diberikan adalah <code>ClusterIP</code>.</p>

<p><em>Value</em> dan perilaku dari tipe <code>Service</code> dijelaskan sebagai berikut:</p>

<ul>
<li><code>ClusterIP</code>: Mengekspos <code>Service</code> ke <em>range</em> alamat IP di dalam klaster. Apabila kamu memilih <em>value</em> ini
 <code>Service</code> yang kamu miliki hanya dapat diakses secara internal. tipe ini adalah
 <em>default</em> <em>value</em> dari <em>ServiceType</em>.</li>
<li><a href="#nodeport"><code>NodePort</code></a>: Mengekspos <code>Service</code> pada setiap IP <em>node</em> pada <em>port</em> statis
 atau <em>port</em> yang sama. Sebuah <code>Service</code> <code>ClusterIP</code>, yang mana <code>Service</code> <code>NodePort</code> akan di-<em>route</em>
 , dibuat secara otomatis. Kamu dapat mengakses <code>Service</code> dengan tipe ini,
 dari luar klaster melalui <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>.</li>
<li><a href="#loadbalancer"><code>LoadBalancer</code></a>: Mengekspos <code>Service</code> secara eksternal dengan menggunakan <code>LoadBalancer</code>
 yang disediakan oleh penyedia layanan <em>cloud</em>. <code>Service</code> dengan tipe <code>NodePort</code> dan <code>ClusterIP</code>,
 dimana trafik akan di-<em>route</em>, akan dibuat secara otomatis.</li>
<li><a href="#externalname"><code>ExternalName</code></a>: Melakukan pemetaan <code>Service</code> ke konten
  dari <em>field</em> <code>externalName</code> (misalnya: <code>foo.bar.example.com</code>), dengan cara mengembalikan
  catatan <code>CNAME</code> beserta <em>value</em>-nya. Tidak ada metode <em>proxy</em> apa pun yang diaktifkan. Mekanisme ini
  setidaknya membutuhkan <code>kube-dns</code> versi 1.7.</li>
</ul>

<h3 id="nodeport">Type NodePort</h3>

<p>Jika kamu menerapkan <em>value</em> <code>NodePort</code> pada <em>field</em> <em>type</em>, master Kubernetes akan mengalokasikan
<em>port</em> dari <em>range</em> yang dispesifikasikan oleh penanda <code>--service-node-port-range</code> (secara <em>default</em>, 30000-32767)
dan setiap <em>Node</em> akan memproksikan <em>port</em> tersebut (setiap <em>Node</em> akan memiliki nomor <em>port</em> yang sama) ke <code>Service</code>
yang kamu miliki. <code>Port</code> tersebut akan dilaporkan pada <em>field</em> <code>.spec.ports[*].nodePort</code> di <code>Service</code> kamu.</p>

<p>Jika kamu ingin memberikan spesifikasi IP tertentu untuk melakukan <em>poxy</em> pada <em>port</em>.
kamu dapat mengatur penanda <code>--nodeport-addresses</code> pada <code>kube-proxy</code> untuk <em>range</em> alamat IP
tertentu (mekanisme ini didukung sejak v1.10). Sebuah daftar yang dipisahkan koma (misalnya, <em>10.0.0.0/8</em>, <em>1.2.3.4/32</em>)
digunakan untuk mem-<em>filter</em> alamat IP lokal ke <em>node</em> ini. Misalnya saja kamu memulai <code>kube-proxy</code> dengan penanda
<code>--nodeport-addresses=127.0.0.0/8</code>, maka <code>kube-proxy</code> hanya akan memilih <em>interface</em> <em>loopback</em> untuk <code>Service</code> dengan tipe
<code>NodePort</code>. Penanda <code>--nodeport-addresses</code> memiliki nilai <em>default</em> kosong (<code>[]</code>), yang artinya akan memilih semua <em>interface</em> yang ada
dan sesuai dengan perilaku <code>NodePort</code> <em>default</em>.</p>

<p>Jika kamu menginginkan nomor <em>port</em> yang berbeda, kamu dapat memberikan spesifikasi
<em>value</em> dari <em>field</em> <em>nodePort</em>, dan sistem yang ada akan mengalokasikan <em>port</em> tersebut untuk kamu,
jika <em>port</em> tersebut belum digunakan (perhatikan bahwa jika kamu menggunakan teknik ini, kamu perlu
mempertimbangkan <em>collision</em> yang mungkin terjadi dan bagaimana cara mengatasi hal tersebut)
atau transaksi API yang dilakukan akan gagal.</p>

<p>Hal ini memberikan kebebasan bagi pengembang untuk memilih <em>load balancer</em> yang akan digunakan, terutama apabila
<em>load balancer</em> yang ingin digunakan belum didukung sepenuhnya oleh Kubernetes.</p>

<p>Perhatikan bahwa <code>Service</code> dapat diakses baik dengan menggunakan <code>&lt;NodeIP&gt;:spec.ports[*].nodePort</code>
atau <code>.spec.clusterIP:spec.ports[*].port</code>. (Jika penanda <code>--nodeport-addresses</code> diterapkan, <NodeIP> dapat di-<em>filter</em> dengan salah satu atau lebih <em>NodeIP</em>.)</p>

<h3 id="loadbalancer">Type LoadBalancer</h3>

<p>Pada penyedia layanan <em>cloud</em> yang menyediakan pilihan <em>load balancer</em> eksternal, pengaturan <em>field</em> <em>type</em>
ke <code>LoadBalancer</code> akan secara otomatis melakukan proses <em>provision</em> <em>load balancer</em> untuk <code>Service</code> yang kamu buat.
Informasi mengenai <em>load balancer</em> yang dibuat akan ditampilkan pada <em>field</em> <code>.status.loadBalancer</code>
pada <code>Service</code> kamu. Contohnya:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>clusterIP:<span style="color:#bbb"> </span><span style="color:#666">10.0.171.239</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>loadBalancerIP:<span style="color:#bbb"> </span><span style="color:#666">78.11.24.19</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>type:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span><span style="color:#bbb"></span>status:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>loadBalancer:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>ingress:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>ip:<span style="color:#bbb"> </span><span style="color:#666">146.148.47.155</span></code></pre></div>
<p>Trafik dari <em>load balancer</em> eksternal akan diarahkan pada <code>Pod</code> <em>backend</em>, meskipun mekanisme
bagaimana hal ini dilakukan bergantung pada penyedia layanan <em>cloud</em>. Beberapa penyedia layanan
<em>cloud</em> mengizinkan konfigurasi untuk <em>value</em> <code>loadBalancerIP</code>. Dalam kasus tersebut, <em>load balancer</em> akan dibuat
dengan <em>loadbalancerIP</em> yang dispesifikasikan. Jika <em>value</em> dari <code>loadBalancerIP</code> tidak dispesifikasikan.
sebuah IP sementara akan diberikan  pada <em>loadBalancer</em>. Jika <code>loadBalancerIP</code> dispesifikasikan,
tetapi penyedia layanan <em>cloud</em> tidak mendukung hal ini, maka <em>field</em> yang ada akan diabaikan.</p>

<p><strong>Catatan Khusus untuk Azure</strong>: Untuk spesifikasi <code>loadBalancerIP</code> publik yang didefinisikan oleh pengguna,
sebuah alamat IP statis publik akan disediakan terlebih dahulu, dan alamat IP tersebut harus berada di
<em>resource group</em> dari <em>resource</em> yang secara otomatis dibuat oleh klaster. Misalnya saja, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.
Berikan spesifikasi alamat IP sebagai <code>loadBalancerIP</code>. Pastikan kamu sudah melakukan <em>update</em> pada
<em>securityGroupName</em> pada <em>file</em> konfigurasi penyedia layanan <em>cloud</em>.
Untuk informasi lebih lanjut mengenai <em>permission</em> untuk <code>CreatingLoadBalancerFailed</code> kamu dapat membaca <em>troubleshooting</em> untuk
<a href="https://docs.microsoft.com/en-us/azure/aks/static-ip" target="_blank">Penggunaan alamat IP statis pada <em>load balancer</em> Azure Kubernetes Service (AKS)</a> atau
<a href="https://github.com/Azure/AKS/issues/357" target="_blank"><em>CreatingLoadBalancerFailed</em> pada klaster AKS dengan <em>advanced networking</em></a>.</p>

<blockquote class="note">
  <div><strong>Catatan:</strong> Dukungan untuk SCTP <em>load balancer</em> dari penyedia layanan <em>cloud</em> bergantung pada
implementasi <em>load balancer</em> yang disediakan oleh penyedia layanan <em>cloud</em> tersebut.
Jika SCTP tidak didukung oleh <em>load balancer</em> penyedia layanan publik maka <em>request</em> pembuatan <code>Service</code>
akan tetap diterima, meskipun proses pembuatan <em>load balancer</em> itu sendiri gagal.</div>
</blockquote>

<h4 id="load-balancer-internal"><em>Load balancer</em> internal</h4>

<p>Di dalam <em>environment</em>, terkadang terdapat kebutuhan untuk melakukan <em>route</em> trafik antar
<em>Service</em> yang berada di dalam satu VPC.</p>

<p>Di dalam <em>environment</em> <em>split-horizon DNS</em> kamu akan membutuhkan dua <em>service</em> yang mampu
melakukan mekanisme <em>route</em> trafik eskternal maupun internal ke <em>endpoints</em> yang kamu miliki.</p>

<p>Hal ini dapat diraih dengan cara menambahkan anotasi berikut untuk <em>service</em> yang disediakan oleh
penyedia layanan <em>cloud</em>.</p>

<div id="service-tabs">
<ul>
    
      
  <li><a href="#service-tabs-0">Default</a></li>

      
  <li><a href="#service-tabs-1">GCP</a></li>

      
  <li><a href="#service-tabs-2">AWS</a></li>

      
  <li><a href="#service-tabs-3">Azure</a></li>

      
  <li><a href="#service-tabs-4">OpenStack</a></li>

      
  <li><a href="#service-tabs-5">Baidu Cloud</a></li>

</ul>


<div id="service-tabs-0">
    
        <p>Pilih salah satu <em>tab</em>.</p>

    
</div>

<div id="service-tabs-1">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>cloud.google.com/load-balancer-type:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Internal&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
<p>Gunakan <em>cloud.google.com/load-balancer-type: &ldquo;internal&rdquo;</em> untuk master dengan versi 1.7.0 to 1.7.3.
Untuk informasi lebih lanjut, dilahkan baca <a href="https://cloud.google.com/kubernetes-engine/docs/internal-load-balancing" target="_blank">dokumentasi</a>.</p>

    
</div>

<div id="service-tabs-2">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-internal:<span style="color:#bbb"> </span><span style="color:#666">0.0.0.0</span>/<span style="color:#666">0</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-3">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/azure-load-balancer-internal:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-4">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/openstack-internal-load-balancer:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<div id="service-tabs-5">
    
        <div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">[...]<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/cce-load-balancer-internal-vpc:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>[...]</code></pre></div>
    

<p></div></p>

<p></div></p>

<script>$(function(){$("#service-tabs").tabs();});</script>

<h4 id="dukungan-untuk-ssl-di-aws">Dukungan untuk SSL di AWS</h4>

<p>Dukungan parsial untuk SSL bagi klaster yang dijalankan di AWS mulai diterapkan,
mulai versi 1.3 terdapat 3 anotasi yang dapat ditambahkan pada <code>Service</code> dengan tipe
<code>LoadBalancer</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>service.beta.kubernetes.io/aws-load-balancer-ssl-cert:<span style="color:#bbb"> </span>arn:aws:acm:us-east<span style="color:#666">-1</span>:<span style="color:#666">123456789012</span>:certificate/<span style="color:#666">12345678-1234-1234-1234-123456789012</span></code></pre></div>
<p>Anotasi pertama memberikan spesifikasi ARN dari sertifikat yang akan digunakan.
Sertifikat yang digunakan bisa saja berasal dari <em>third party</em> yang diunggah ke IAM atau
sertifikat yang dibuat secara langsung dengan menggunakan sertifikat manajer AWS.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>service.beta.kubernetes.io/aws-load-balancer-backend-protocol:<span style="color:#bbb"> </span>(https|http|ssl|tcp)</code></pre></div>
<p>Anotasi kedua memberikan spesifikasi bagi protokol yang digunakan oleh <code>Pod</code> untuk saling berkomunikasi.
Untuk HTTPS dan SSL, ELB membutuhkan <code>Pod</code> untuk melakukan autentikasi terhadap dirinya sendiri melalui
koneksi yang dienkripsi.</p>

<p>Protokol HTTP dan HTTPS akan memilih mekanisme <em>proxy</em> di tingkatan ke-7:
ELB akan melakukan terminasi koneksi dengan pengguna, melakukan proses <em>parsing</em> <em>headers</em>, serta
memasukkan <em>value</em> bagi <em>header</em> <code>X-Forwarded-For</code> dengan alamat IP pengguna (<em>Pod</em> hanya dapat melihat
alamat IP dari ELB pada akhir koneksi yang diberikan) ketika melakukan <em>forwarding</em> suatu <em>request</em>.</p>

<p>Protokol TCP dan SSL akan memilih mekanisme <em>proxy</em> pada tingkatan 4: ELB akan melakukan <em>forwarding</em> trafik
tanpa melakukan modifikasi <em>headers</em>.</p>

<p>Pada <em>environment</em> campuran dimana beberapa <em>port</em> diamankan sementara <em>port</em> lainnya dalam kondisi tidak dienkripsi,
anotasi-anotasi berikut dapat digunakan:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-backend-protocol:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-ssl-ports:<span style="color:#bbb"> </span><span style="color:#b44">&#34;443,8443&#34;</span></code></pre></div>
<p>Pada contoh di atas, jika <code>Service</code> memiliki 3 buah <em>port</em>, yaitu: <code>80</code>, <code>443</code>, dan
<code>8443</code>, maka <code>443</code> adan <code>8443</code> akan menggunakan sertifikat SSL, tetapi <code>80</code> hanya akan
di-<em>proxy</em> menggunakan protokol HTTP.</p>

<p>Mulai versi 1.9, <code>Service</code> juga dapat menggunakan <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html" target="_blank"><em>predefined</em> <em>policy</em></a>
untuk HTTPS atau <em>listener</em> SSL. Untuk melihat <em>policy</em> apa saja yang dapat digunakan, kamu dapat menjalankan perintah <em>awscli</em>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">aws elb describe-load-balancer-policies --query <span style="color:#b44">&#39;PolicyDescriptions[].PolicyName&#39;</span></code></pre></div>
<p><em>Policy</em> ini kemudian dapat dispesifikasikan menggunakan anotasi
&ldquo;<em>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</em>&rdquo;, contohnya:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy:<span style="color:#bbb"> </span><span style="color:#b44">&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span></code></pre></div>
<h4 id="protokol-proxy-pada-aws">Protokol PROXY pada AWS</h4>

<p>Untuk mengaktifkan dukungan <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" target="_blank">protokol PROXY</a>
untuk klaster yang dijalankan di AWS, kamu dapat menggunakan anotasi di bawah ini:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span></code></pre></div>
<p>Sejak versi 1.3.0, penggunaan anotasi berlaku untuk semua <em>port</em> yang diproksi oleh ELB
dan tidak dapat diatur sebaliknya.</p>

<h4 id="akses-log-elb-pada-aws">Akses <em>Log</em> ELB pada AWS</h4>

<p>Terdapat beberapa anotasi yang digunakan untuk melakukan manajemen
akses <em>log</em> untuk ELB pada AWS.</p>

<p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>
mengatur akses <em>log</em> mana sajakah yang diaktifkan.</p>

<p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>
mengatur interval (dalam menit) publikasi akses <em>log</em>. Kamu dapat memberikan spesifikasi interval
diantara <em>range</em> 5-60 menit.</p>

<p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>
mengatur nama <em>bucket</em> Amazon S3 dimana akses <em>log</em> <em>load balancer</em> disimpan.</p>

<p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>
memberikan spesifikasi hierarki logis yang kamu buat untuk <em>bucket</em> Amazon S3 yang kamu buat.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies whether access logs are enabled for the load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The interval for publishing the access logs. You can specify an interval of either 5 or 60 (minutes).</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name:<span style="color:#bbb"> </span><span style="color:#b44">&#34;my-bucket&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The name of the Amazon S3 bucket where the access logs are stored</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix:<span style="color:#bbb"> </span><span style="color:#b44">&#34;my-bucket-prefix/prod&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The logical hierarchy you created for your Amazon S3 bucket, for example _my-bucket-prefix/prod_</span></code></pre></div>
<h4 id="mekanisme-draining-koneksi-pada-aws">Mekanisme <em>Draining</em> Koneksi pada AWS</h4>

<p>Mekanisme <em>draining</em> untuk ELB klasik dapat dilakukan dengan menggunakan anotasi
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code> serta mengatur
<em>value</em>-nya menjadi <code>&quot;true&quot;</code>. Anotasi
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code> juga
dapat digunakan untuk mengatur <em>maximum time</em> (dalam detik), untuk menjaga koneksi yang ada
agar selalu terbuka sebelum melakukan <em>deregistering</em> <em>instance</em>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span></code></pre></div>
<h4 id="anotasi-elb-lainnya">Anotasi ELB lainnya</h4>

<p>Terdapat beberapa anotasi lain yang dapat digunakan untuk mengatur ELB klasik
sebagaimana dijelaskan seperti di bawah ini:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout:<span style="color:#bbb"> </span><span style="color:#b44">&#34;60&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># Specifies whether cross-zone load balancing is enabled for the load balancer</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags:<span style="color:#bbb"> </span><span style="color:#b44">&#34;environment=prod,owner=devops&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># A comma-separated list of key-value pairs which will be recorded as</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># additional tags in the ELB.</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The number of successive successful health checks required for a backend to</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># be considered healthy for traffic. Defaults to 2, must be between 2 and 10</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold:<span style="color:#bbb"> </span><span style="color:#b44">&#34;3&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The number of unsuccessful health checks required for a backend to be</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># considered unhealthy for traffic. Defaults to 6, must be between 2 and 10</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval:<span style="color:#bbb"> </span><span style="color:#b44">&#34;20&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The approximate interval, in seconds, between health checks of an</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># individual instance. Defaults to 10, must be between 5 and 300</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># The amount of time, in seconds, during which no response means a failed</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># health check. This value must be less than the service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># value. Defaults to 5, must be between 2 and 60</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups:<span style="color:#bbb"> </span><span style="color:#b44">&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># A list of additional security groups to be added to ELB</span></code></pre></div>
<h4 id="dukungan-network-load-balancer-nlb-pada-aws-alpha">Dukungan <em>Network Load Balancer</em> (NLB) pada AWS [alpha]</h4>

<blockquote class="warning">
  <div><strong>Peringatan:</strong> Ini merupakan tingkatan <em>alpha</em> dan tidak direkomendasikan untuk digunakan pada <em>environment</em> <em>production</em>.</div>
</blockquote>

<p>Sejak versi 1.9.0, Kubernetes mendukung <em>Network Load Balancer</em> (NLB). Untuk
menggunakan NLB pada AWS, gunakan anotasi <code>service.beta.kubernetes.io/aws-load-balancer-type</code>
dan atur <em>value</em>-nya dengan <code>nlb</code>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">      </span>annotations:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>service.beta.kubernetes.io/aws-load-balancer-type:<span style="color:#bbb"> </span><span style="color:#b44">&#34;nlb&#34;</span></code></pre></div>
<p>Tidak seperti ELB klasik, NLB, melakukan <em>forwarding</em> IP klien melalui <em>node</em>.
Jika <em>field</em> <code>.spec.externalTrafficPolicy</code> diatur <em>value</em>-nya menjadi <code>Cluster</code>, maka
alamat IP klien tidak akan diteruskan pada <code>Pod</code>.</p>

<p>Dengan mengatur <em>value</em> dari <em>field</em> <code>.spec.externalTrafficPolicy</code> ke <code>Local</code>,
alamat IP klien akan diteruskan ke <code>Pod</code>, tapi hal ini bisa menyebabkan distribusi trafik
yang tidak merata. <em>Node</em> yang tidak memiliki <code>Pod</code> untuk <code>Service</code> dengan tipe <code>LoadBalancer</code>
akan menyebabkan kegagalan <em>health check</em> <em>NLB Target</em> pada tahapan <em>auto-assigned</em> <code>.spec.healthCheckNodePort</code>
dan tidak akan menerima trafik apa pun.</p>

<p>Untuk menghasilkan distribusi trafik yang merata, kamu dapat menggunakan
<em>DaemonSet</em> atau melakukan spesifikasi
<a href="/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity-beta-feature">pod anti-affinity</a>
agar <code>Pod</code> tidak di-<em>assign</em> ke <em>node</em> yang sama.</p>

<p>NLB juga dapat digunakan dengan anotasi <a href="/docs/concepts/services-networking/service/#internal-load-balancer">internal load balancer</a>.</p>

<p>Agar trafik klien berhasil mencapai <em>instances</em> dibelakang ELB,
<em>security group</em> dari <em>node</em> akan diberikan <em>rules</em> IP sebagai berikut:</p>

<table>
<thead>
<tr>
<th><em>Rule</em></th>
<th>Protokol</th>
<th><code>Port</code></th>
<th><em>IpRange(s)</em></th>
<th>Deskripsi <em>IpRange</em></th>
</tr>
</thead>

<tbody>
<tr>
<td><em>Health Check</em></td>
<td>TCP</td>
<td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <em>.spec.externalTrafficPolicy = Local</em>)</td>
<td>VPC CIDR</td>
<td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName&gt;</td>
</tr>

<tr>
<td><em>Client Traffic</em></td>
<td>TCP</td>
<td>NodePort(s)</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName&gt;</td>
</tr>

<tr>
<td><em>MTU Discovery</em></td>
<td>ICMP</td>
<td>3,4</td>
<td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName&gt;</td>
</tr>
</tbody>
</table>

<p>Perhatikan bahwa jika <code>.spec.loadBalancerSourceRanges</code> tidak dispesifikasikan,
Kubernetes akan mengizinkan trafik dari <code>0.0.0.0/0</code> ke <em>Node Security Group</em>.
Jika <em>node</em> memiliki akses publik, maka kamu harus memperhatikan tersebut karena trafik yang tidak berasal
dari NLB juga dapat mengakses semua <em>instance</em> di <em>security group</em> tersebut.</p>

<p>Untuk membatasi klien IP mana yang dapat mengakses NLB,
kamu harus memberikan spesifikasi <em>loadBalancerSourceRanges</em>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>loadBalancerSourceRanges:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span><span style="color:#b44">&#34;143.231.0.0/16&#34;</span></code></pre></div>
<blockquote class="note">
  <div><strong>Catatan:</strong> NLB hanya dapat digunakan dengan beberapa kelas <em>instance</em> tertentu baca <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets" target="_blank">dokumentasi AWS</a>
untuk mengetahui lebih lanjut <em>intance</em> apa saja yang didukung.</div>
</blockquote>

<h3 id="externalname">Tipe ExternalName</h3>

<p>Service dengan tipe <code>ExternalName</code> melakukan pemetaan antara <code>Service</code> dan DNS, dan bukan
ke <em>selector</em> seperti <code>my-service</code> atau <code>cassandra</code>. Kamu memberikan spesifikasi <code>spec.externalName</code>
pada <code>Service</code> tersebut.</p>

<p>Definisi <code>Service</code> ini, sebagai contoh, melaukan pemetaan
<code>Service</code> <code>my-service</code> pada <em>namespace</em> <code>prod</code> ke DNS <code>my.database.example.com</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span>namespace:<span style="color:#bbb"> </span>prod<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>type:<span style="color:#bbb"> </span>ExternalName<span style="color:#bbb">
</span><span style="color:#bbb">  </span>externalName:<span style="color:#bbb"> </span>my.database.example.com</code></pre></div>
<blockquote class="note">
  <div><strong>Catatan:</strong> <code>ExternalName</code> menerima alamat IPv4 dalam bentuk string,
tapi karena DNS tersusun atas angka dan bukan sebagai alamat IP.
<code>ExternalName</code> yang menyerupai alamat IPv4 tidak bisa di-<em>resolve</em> oleh <em>CoreDNS</em>
atau <em>ingress-nginx</em> karena <code>ExternalName</code> memang ditujukan bagi penamaan <em>canonical</em> DNS.
Untuk melakukan <em>hardcode</em> alamat IP, kamu dapat menggunakan <em>headless</em> <code>Service</code> sebagai alternatif.</div>
</blockquote>

<p>Ketika melakukan pencarian <em>host</em> <code>my-service.prod.svc.cluster.local</code>,
servis DNS klaster akan mengembalikan <em>record</em> <code>CNAME</code> dengan <em>value</em> <code>my.database.example.com</code>.
Mekanisme akses pada <code>my-service</code> bekerja dengan cara yang sama dengan
<code>Service</code> pada umumnya, perbedaan yang krusial untuk hal ini adalah mekanisme <em>redirection</em>
terjadi pada tingkatan DNS dan bukan melalui <em>proxy forward</em>. Apabila kamu berniat memindahkan basis data
yang kamu pakai ke dalam klaster, kamu hanya perlu mengganti instans basis data kamu dan menjalankannya
di dalam <code>Pod</code>, menambahkan <em>selector</em> atau <em>endpoint</em> yang sesuai, serta mengupah <em>type</em> dari
<em>Service</em> yang kamu gunakan.</p>

<blockquote class="note">
  <div><strong>Catatan:</strong> Bagian ini berasal dari tulisan <a href="https://akomljen.com/kubernetes-tips-part-1/" target="_blank">Tips Kubernetes - Bagian
1</a> oleh <a href="https://akomljen.com/" target="_blank">Alen Komljen</a>.</div>
</blockquote>

<h3 id="ip-eksternal">IP Eksternal</h3>

<p>Jika terdapat sebuah alamat IP eksternal yang melakukan mekanisme <em>route</em> ke satu atau lebih <em>node</em> yang ada di klaster, <code>Service</code> Kubernetes dapat diekspos
dengan menggunakan <code>externalIP</code>. Trafik yang diarahkan ke klaster dengan IP eksternal
(sebagai destinasi IP), pada <em>port</em> <code>Service</code> akan di-<em>route</em> ke salah satu <em>endpoint</em> <code>Service</code>.
<em>Value</em> dari <code>externalIP</code> tidak diatur oleh Kubernetes dan merupakan tanggung jawab
dari administrator klaster.</p>

<p>Pada <em>ServiceSpec</em>, kamu dapat memberikan spesifikasi <code>externalIP</code> dan <code>ServiceTypes</code>.
Pada contoh di bawah ini. <code>&quot;my-service&quot;</code> dapat diakses oleh klien pada &ldquo;<code>80.11.12.10:80</code>&rdquo; (<code>externalIP:port</code>).</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">kind:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span>apiVersion:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span>metadata:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>name:<span style="color:#bbb"> </span>my-service<span style="color:#bbb">
</span><span style="color:#bbb"></span>spec:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>selector:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>app:<span style="color:#bbb"> </span>MyApp<span style="color:#bbb">
</span><span style="color:#bbb">  </span>ports:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">    </span>protocol:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span>port:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>targetPort:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>externalIPs:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>-<span style="color:#bbb"> </span><span style="color:#666">80.11.12.10</span></code></pre></div>
<h2 id="kekurangan">Kekurangan</h2>

<p>Penggunaan <em>proxy</em> <em>userspace</em> untuk VIP dapat digunakan untuk skala kecil hingga menengah,
meski begitu hal ini tidak <em>scalable</em> untuk klaster yang sangat besar dan memiliki ribuan <code>Service</code>.
Perhatikan <a href="http://issue.k8s.io/1107" target="_blank">Desain proposal orisinil untuk <em>portal</em></a> untuk informasi
lebih lanjut.</p>

<p>Penggunaan <em>proxy</em> <em>userspace</em> menghilangkan <em>source-IP</em> dari <em>packet</em> yang mengakses
sebuah <code>Service</code>. Hal ini membuat mekanisme <em>firewall</em> menjadi sulit untuk diterapkan.
<em>Proxy</em> <code>iptables</code> tidak menghilangkan <em>source IP</em> yang berasal dari dalam klaster,
meski begitu, hal ini masih berimbas pada klien yang berasal dari <code>Service</code> dengan tipe
<em>load-balancer</em> atau <em>node-port</em>.</p>

<p><em>Field</em> tipe didesain sebagai fungsionalitas yang berantai - setiap tingkatan
menambahkan tambahan pada tingkatansebelumnya. Hal ini tidak selalu berlaku bagi
semua penyedia layanan <em>cloud</em> (misalnya saja Google Compute Engine tidak perlu
melakukan alokasi <code>NodePort</code> untuk membuat <code>LoadBalancer</code> bekerja sebagaimana mestinya,
hal ini berbeda dengan AWS yang memerlukan hal ini, setidaknya untuk API yang mereka miliki
saat ini).</p>

<h2 id="pengerjaan-lebih-lanjut">Pengerjaan lebih lanjut</h2>

<p>Di masa mendatang, kami berencana untuk membuat <em>policy</em> <em>proxy</em> menjadi lebih
bervariasi dan bukan hanya <em>round robin</em>, misalnya saja <em>master-elected</em> atau <em>sharded</em>.
Kami juga berharap bahwa beberapa <code>Service</code> bisa saja memiliki <em>load balancer</em> yang sebenarnya,
suatu kasus dimana VIP akan secara langsung mengantarkan paket.</p>

<p>Kami ingin meningkatkan dukungan lebih lanjut untuk <code>Service</code> dengan tingkatan <code>Service</code> L7(HTTP).</p>

<p>Kami ingin memiliki mode <em>ingress</em> yang lebih fleksibel untuk <code>Service</code> yang
mencakup mode <code>ClusterIP</code>, <code>NodePort</code>, dan <code>LoadBalancer</code> dan banyak lagi.</p>

<h2 id="detail-mendalam-mengenai-ip-virtual">Detail mendalam mengenai IP virtual</h2>

<p>Informasi sebelumnya sudah cukup bagi sebagian orang yang hanya ingin menggunakan
<em>Service</em>. Meskipun begitu, terdapat banyak hal yang sebenarnya terjadi dan akan
sangat bermanfaat untuk dipelajari lebih lanjut.</p>

<h3 id="menghindari-collison">Menghindari <em>collison</em></h3>

<p>Salah satu filosofi Kubernetes adalah pengguna tidak mungkin menghadapi situasi
dimana apa yang mereka mengalami kegagalan tanpa adanya alasan yang jelas. Dalam kasus ini,
kita akan coba memahami lebih lanjut mengenai <em>network port</em> - pengguna tidak seharusnya memilih
nomor <em>port</em> jika hal itu memungkinkan terjadinya <em>collision</em> dengan pengguna lainnya. Hal ini
merupakan mekanisme isolasi kegagalan.</p>

<p>Agar pengguna dapat menentukan nomor <em>port</em> bagi <code>Service</code> mereka, kita harus
memastikan bahwa tidak ada dua <code>Service</code> yang mengalami <em>collision</em>. Kita melakukan
hal tersebut dengan cara melakukan alokasi alamat IP pada setiap <code>Service</code>.</p>

<p>Untuk memastikan setiap <code>Service</code> memiliki alamat IP yang unik, sebuah <em>allocator</em>
internal akan secara atomik melakukan pemetaan alokasi global di dalam <em>etcd</em> ketika
membuat sebuah <code>Service</code> baru. Pemetaan objek harus tersedia pada <em>registry</em> <code>Service</code>
dimana <code>Service</code> akan diberikan sebuah IP, jika tidak, proses pembuatan <code>Service</code> akan gagal
dan sebuah pesan akan memberikan informasi bahwa alamat IP tidak dapat dialokasikan.
Sebuah <em>backgroud</em> <em>controller</em> bertanggung jawab terhadap mekanisme pemetaan tersebut (migrasi
dari versi Kubernetes yang digunakan dalam <em>memory locking</em>) sekaligus melakukan pengecekan
terhadap <em>assignment</em> yang tidak valid yang terjadi akibat intervensi administrator dan melakukan
penghapusan daftar IP yang dialokasikan tapi tidak digunakan oleh <code>Service</code> mana pun.</p>

<h3 id="ip-dan-vip">IP dan VIP</h3>

<p>Tidak seperti alamat IP <code>Pod</code>, yang akan di <em>route</em> ke destinasi yang &ldquo;pasti&rdquo;,
IP <code>Service</code> tidak mengarahkan <em>request</em> hanya pada satu <em>host</em>.  Sebagai gantinya,
kita mneggunakan <code>iptables</code> (logika pemrosesan paket pada Linux) untuk melakukan definisi
alamat IP virtual yang secara transparan akan diarahkan sesuai kebutuhan. Ketika klien
dihubungkan pada VIP, trafik yang ada akan secara otomatis dialihkan pada <em>endpoint</em> yang sesuai.
Variabel <em>environment</em> dan DNS untuk <code>Service</code> terdiri dalam bentuk VIP dan <em>port</em>.</p>

<p>Kami mendukung tiga jenis mode <em>proxy</em> - <em>userspace</em>, <code>iptables</code>, dan <em>ipvs</em> yang memiliki
perbedaan cara kerja satu sama lainnya.</p>

<h4 id="userspace"><em>Userspace</em></h4>

<p>Sebagai contoh, anggaplah kita memiliki aplikasi <em>image processing</em> seperti yang sudah
disebutkan di atas. Ketika <code>Service</code> <em>backend</em> dibuat, <em>master</em> Kubernetes akan mengalokasikan
sebuah alamat IP virtual, misalnya 10.0.0.1. Dengan asumsi <em>port</em> dari <code>Service</code> tersebut adalah <em>1234</em>,
maka <code>Service</code> tersebut akan diamati oleh semua <em>instance</em> <code>kube-proxy</code> yang ada di klaster.
Ketika sebuah <em>proxy</em> mendapati sebuah <code>Service</code> baru, <em>proxy</em> tersebut akan membuka sebuah <em>port</em>
<em>acak</em>, menyediakan <code>iptables</code> yang mengarahkan VIP pada <em>port</em> yang baru saja dibuat, dan mulai
koneksi pada <em>port</em> tersebut.</p>

<p>Ketika sebuah klien terhubung ke VIP dan terdapat <em>rules</em> <code>iptables</code>
yang diterapkan, paket akan diarahkan ke <em>port</em> dari <em>proxy</em> <code>Service</code> itu sendiri.
<em>Proxy</em> <code>Service</code> akan memilih sebuah <em>backend</em>, dan mulai melakukan mekanisme <em>proxy</em>
trafik dari klien ke <em>backend</em>.</p>

<p>Dengan demikian, pemilik <code>Service</code> dapat memilih <em>port</em> mana pun yang dia inginkan
tanpa adanya kemungkinan terjadinya <em>collision</em>. Klien dapat dengan mudah mengakses IP dan <em>port</em>,
tanpa harus mengetahui <code>Pod</code> mana yang sebenarnya diakses.</p>

<h4 id="iptables"><em>Iptables</em></h4>

<p>Kembali, bayangkan apabila kita memiliki aplikasi <em>image processing</em> seperti yang sudah
disebutkan di atas. Ketika <code>Service</code> <em>backend</em> dibuat, <em>master</em> Kubernetes akan mengalokasikan
sebuah alamat IP virtual, misalnya 10.0.0.1. Dengan asumsi <em>port</em> dari <code>Service</code> tersebut adalah <em>1234</em>,
maka <code>Service</code> tersebut akan diamati oleh semua <em>instance</em> <code>kube-proxy</code> yang ada di klaster.
Ketika sebuah <em>proxy</em> mendapati sebuah <code>Service</code> baru, <em>proxy</em> tersebut akan melakukan instalasi
serangkaian <em>rules</em> <code>iptables</code> yang akan melakukan <em>redirect</em> VIP ke <em>rules</em> tiap <code>Service</code>. <em>Rules</em>
untuk tiap <code>Service</code> ini terkait dengan <em>rules</em> tiap <code>Endpoints</code> yang mengarahkan (destinasi NAT)
ke <em>backend</em>.</p>

<p>Ketika sebuah klien terhubung ke VIP dan terdapat _rules _iptables
yang diterapkan. Sebuah <em>backend</em> akan dipilih (hal ini dapat dilakukan berdasarkan <em>session affinity</em>
maupun secara <em>acak</em>) dan paket-paket yang ada akan diarahkan ke <em>backend</em>. Tidak seperti mekanisme
yang terjadi di <em>userspace</em>, paket-paket yang ada tidak pernah disalin ke <em>userspace</em>, <code>kube-proxy</code>
tidak harus aktif untuk menjamin kerja VIP, serta IP klien juga tidak perlu diubah.</p>

<p>Tahapan yang dijalankan sama dengan tahapan yang dijalankan ketika trafik masuk melalui sebuah <em>node-port</em>
atau <em>load-balancer</em>, meskipun pada dua kasus di atas klien IP tidak akan mengalami perubahan.</p>

<h4 id="ipvs"><em>Ipvs</em></h4>

<p>Operasi <code>iptables</code> berlangsung secara lambat pada klaster dengan skala besar (lebih dari 10.000 <code>Service</code>).
<em>IPVS</em> didesain untuk mekanisme <em>load balance</em> dan berbasis pada <em>hash tables</em> yang berada di dalam <em>kernel</em>.
Dengan demikian kita dapat mendapatkan performa yang konsisten pada jumlah <code>Service</code> yang cukup besar dengan
menggunakan <code>kube-proxy</code> berbasis <em>ipvs</em>. Sementara itu, <code>kube-proxy</code> berbasis <em>ipvs</em> memiliki algoritma
<em>load balance</em> yang lebih bervariasi (misalnya saja <em>least conns</em>, <em>locality</em>, <em>weighted</em>, <em>persistence</em>).</p>

<h2 id="objek-api">Objek API</h2>

<p><em>Service</em> merupakan <em>resource</em> <em>top-level</em> pada API Kubernetes.
Penjelasan lebih lanjut mengenai objek API dapat ditemukan pada:
<a href="/docs/reference/generated/kubernetes-api/v1.17/#service-v1-core">objek API <code>Service</code></a>.</p>

<h2 id="protokol-yang-tersedia">Protokol yang didukung</h2>

<h3 id="tcp">TCP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.0</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
This feature is <em>stable</em>, meaning:</p>

<ul>
<li>The version name is vX where X is an integer.</li>
<li>Stable versions of features will appear in released software for many subsequent versions.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Kamu dapat menggunakan TCP untuk <code>Service</code> dengan <em>type</em> apa pun, dan protokol ini merupakan
protokol <em>default</em> yang digunakan.</p>

<h3 id="udp">UDP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.0</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
This feature is <em>stable</em>, meaning:</p>

<ul>
<li>The version name is vX where X is an integer.</li>
<li>Stable versions of features will appear in released software for many subsequent versions.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Kamu dapat menggunakan UDP untuk sebagian besar <code>Service</code>.
Untuk <code>Service</code> dengan <em>type=LoadBalancer</em>, dukungan terhadap UDP
bergantung pada penyedia layanan <em>cloud</em> yang kamu gunakan.</p>

<h3 id="http">HTTP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.1</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
This feature is <em>stable</em>, meaning:</p>

<ul>
<li>The version name is vX where X is an integer.</li>
<li>Stable versions of features will appear in released software for many subsequent versions.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Apabila penyedia layanan <em>cloud</em> yang kamu gunakan mendukung, kamu dapat menggunakan
<em>Service</em> dengan <em>type</em> <code>LoadBalancer</code> untuk melakukan mekanisme <em>reverse</em> <em>proxy</em>
bagi HTTP/HTTPS, dan melakukan <em>forwarding</em> ke <code>Endpoints</code> dari _Service.</p>

<blockquote class="note">
  <div><strong>Catatan:</strong> Kamu juga dapat menggunakan <a class='glossary-tooltip' href='/docs/concepts/services-networking/ingress/' target='_blank'>Ingress<span class='tooltip-text'>Sebuah obyek API yang mengatur akses eksternal terhadap Service yang ada di dalam klaster, biasanya dalam bentuk request HTTP.</span>
</a> sebagai salah satu
alternatif penggunaan <code>Service</code> untuk HTTP/HTTPS.</div>
</blockquote>

<h3 id="protokol-proxy">Protokol PROXY</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.1</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>stable</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="stable">
This feature is <em>stable</em>, meaning:</p>

<ul>
<li>The version name is vX where X is an integer.</li>
<li>Stable versions of features will appear in released software for many subsequent versions.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Apabila penyedia layanan <em>cloud</em> yang kamu gunakan mendukung, (misalnya saja, <a href="/docs/concepts/cluster-administration/cloud-providers/#aws">AWS</a>),
<em>Service</em> dengan <em>type</em> <code>LoadBalancer</code> untuk melakukan konfigurasi <em>load balancer</em>
di luar Kubernetes sendiri, serta akan melakukan <em>forwarding</em> koneksi yang memiliki prefiks
<a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" target="_blank">protokol PROXY</a>.</p>

<p><em>Load balancer</em> akan melakukan serangkaian inisiasi <em>octet</em> yang memberikan
deskripsi koneksi yang datang, dengan bentuk yang menyerupai:</p>

<pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre>

<p>yang kemudian diikuti data dari klien.</p>

<h3 id="sctp">SCTP</h3>

<div style="margin-top: 10px; margin-bottom: 10px;">



<b>FEATURE STATE:</b> <code>Kubernetes v1.12</code>




    
    
    
    
    
<a href="#" id="feature-state-dialog-link" class="ui-state-default ui-corner-all"><span class="ui-icon ui-icon-newwin"></span>alpha</a>
<div id="feature-state-dialog" class="ui-dialog-content" title="alpha">
Fitur ini berada di dalam tingkatan <em>Alpha</em>, yang artinya:</p>

<ul>
<li>Nama dari versi ini mengandung string <code>alpha</code> (misalnya, <code>v1alpha1</code>).</li>
<li>Bisa jadi terdapat <em>bug</em>. Secara <em>default</em> fitur ini tidak diekspos.</li>
<li>Ketersediaan untuk fitur yang ada bisa saja dihilangkan pada suatu waktu tanpa pemberitahuan sebelumnya.</li>
<li>API yang ada mungkin saja berubah tanpa memperhatikan kompatibilitas dengan versi perangkat lunak sebelumnya.</li>
<li>Hanya direkomendasikan untuk klaster yang digunakan untuk tujuan <em>testing</em>.</li>
</ul>
</div>
<script>
$(function(){
    
    $( "#feature-state-dialog" ).dialog({
        autoOpen: false,
        width: "600",
        buttons: [
            {
                text: "Ok",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });

    
    $( "#feature-state-dialog-link" ).click(function( event ) {
        $( "#feature-state-dialog" ).dialog( "open" );
        event.preventDefault();
    });

});
</script>

    

</div>

<p>Kubernetes memberikan dukungan bagi SCTP sebagai <em>value</em> dari <em>definition</em> yang ada pada
<em>Service</em>, <code>Endpoints</code>, <code>NetworkPolicy</code> dan <code>Pod</code> sebagai fitur <em>alpha</em>. Untuk mengaktifkan fitur ini,
administrator klaster harus mengaktifkan <em>feature gate</em> <em>SCTPSupport</em> pada <em>apiserver</em>, contohnya
<code>“--feature-gates=SCTPSupport=true,...”</code>. Ketika <em>fature gate</em> ini diaktifkan, pengguna dapat
memberikan <em>value</em> SCTP pada <em>field</em> <em>protocol</em> <code>Service</code>, <code>Endpoints</code>, <code>NetworkPolicy</code> dan <code>Pod</code>.
Kubernetes kemudian akan melakukan pengaturan agar jaringan yang digunakan agar jaringan tersebut menggunakan SCTP,
seperti halnya Kubernetes mengatur jaringan agar menggunakan TCP.</p>

<h4 id="kelemahan-penggunaan-sctp">Perhatian</h4>

<h5 id="kelemahan-sctp-multihomed">Dukungan untuk asoasiasi <em>multihomed</em> SCTP</h5>

<p>Dukungan untuk asosiasi <em>multihomed</em> SCTP membutuhkan <em>plugin</em> CNI yang dapat memberikan
pengalokasian <em>multiple interface</em> serta alamat IP pada sebuah <code>Pod</code>.</p>

<p>NAT untuk asosiasi <em>multihomed</em> SCTP membutuhkan logika khusus pada modul kernel terkait.</p>

<h5 id="kelemahan-sctp-loadbalancer-service-type"><code>Service</code> dengan <em>type=LoadBalancer</em></h5>

<p>Sebuah <code>Service</code> dengan <em>type</em> <code>LoadBalancer</code> dan protokol SCTP dapat dibuat
hanya jika implementasi <em>load balancer</em> penyedia layanan <em>cloud</em> menyediakan dukungan
bagi protokol SCTP. Apabila hal ini tidak terpenuhi, maka <em>request</em> pembuatan <em>Servixe</em> ini akan ditolak.
<em>Load balancer</em> yang disediakan oleh penyedia layanan <em>cloud</em> yang ada saat ini (<em>Azure</em>, <em>AWS</em>, <em>CloudStack</em>, <em>GCE</em>, <em>OpenStack</em>) tidak mendukung SCTP.</p>

<h5 id="kelemahan-sctp-windows-os">Windows</h5>

<p>SCTP tidak didukung pada <em>node</em> berbasis Windows.</p>

<h5 id="kelemahan-sctp-kube-proxy-userspace"><em>Kube-proxy</em> <em>userspace</em></h5>

<p><em>Kube-proxy</em> tidak mendukung manajemen asosiasi SCTP ketika hal ini dilakukan pada mode
<em>userspace</em></p>












<h2 id="selanjutnya">Selanjutnya</h2>
<p>Baca <a href="/docs/tasks/access-application-cluster/connecting-frontend-backend/">Bagaimana cara menghubungkan <em>Front End</em> ke <em>Back End</em> menggunakan sebuah <code>Service</code></a>.</p>






    
    

    
            
  <h2>Masukan</h2>
  <p class="feedback--prompt">Apakah halaman ini berguna? </p>
  <button class="button feedback--yes">Ya</button>
  <button class="button feedback--no">Tidak</button>
  <p class="feedback--response feedback--response__hidden">
    Thanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on
    <a target="_blank" rel="noopener"
      href="https://stackoverflow.com/questions/tagged/kubernetes">
      Stack Overflow</a>.
    Open an issue in the GitHub repo if you want to 
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Issue%20with%20k8s.io">
      report a problem</a>
    or
    <a class="feedback--link" target="_blank" rel="noopener"
      href="https://github.com/kubernetes/website/issues/new?title=Improvement%20for%20k8s.io">
      suggest an improvement</a>.
  </p>
  <script>
    const yes = document.querySelector('.feedback--yes');
    const no = document.querySelector('.feedback--no');
    document.querySelectorAll('.feedback--link').forEach(link => {
      link.href = link.href + window.location.pathname;
    });
    const sendFeedback = (value) => {
      if (!gtag) { console.log('!gtag'); }
      gtag('event', 'click', {
        'event_category': 'Helpful',
        'event_label': window.location.pathname,
        value
      });
    };
    const disableButtons = () => {
      yes.disabled = true;
      yes.classList.add('feedback--button__disabled');
      no.disabled = true;
      no.classList.add('feedback--button__disabled');
    };
    yes.addEventListener('click', () => {
      sendFeedback(1);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
    no.addEventListener('click', () => {
      sendFeedback(0);
      disableButtons();
      document.querySelector('.feedback--response').classList.remove('feedback--response__hidden');
    });
  </script>


    
            <div id="pre-footer"> 
  <hr />

  <div class="issue-button-container">
    <p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/concepts/services-networking/_index.md?pixel" alt="Analytics" /></a></p>
    
    
    <script type="text/javascript">
    PDRTJS_settings_8345992 = {
    "id" : "8345992",
    "unique_id" : "\/id\/docs\/concepts\/services-networking\/",
    "title" : "Services, Load Balancing, dan Jaringan",
    "permalink" : "https:\/\/kubernetes.io\/id\/docs\/concepts\/services-networking\/"
    };
    (function(d,c,j){if(!document.getElementById(j)){var pd=d.createElement(c),s;pd.id=j;pd.src=('https:'==document.location.protocol)?'https://polldaddy.com/js/rating/rating.js':'http://i0.poll.fm/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd,s);}}(document,'script','pd-rating-js'));
    </script>
    <a href="" onclick="window.open('https://github.com/kubernetes/website/issues/new?template=bug-report.md&title=Issue%20with%20' +
    'k8s.io'+window.location.pathname)" class="button issue">Buat isu</a>
    
    
    
    <a href="https://github.com/kubernetes/website/edit/master/content/id/docs/concepts/services-networking/_index.md" class="button issue">Ubah halaman ini</a>
    
  </div>
  

  <div id="lastedit" class="lastedit issue-button-container">
    Halaman diubah terakhir kali pada April 23, 2019 at 10:30 PM PST oleh
    <a href="https://github.com/kubernetes/website/commit/3c4a42b19d601d513a471781b16811cab749ce2c/">Translate ingress for Bahasa Indonesia. (#13958)</a> (<a href="https://github.com/kubernetes/website/commits/master/content/en/docs/concepts/services-networking/_index.md">Riwayat halaman</a>)
  </div>
  
</div>

          </div>
        </section>
    </main>
		<footer>
    <div class="light-text main-section">
        <nav>
            
            
            
            <a href="/id/docs/home/">Home</a>
            
            
            
            
            
            
            
            <a href="/id/community/">Komunitas</a>
            
            <a href="/id/case-studies/">Studi kasus</a>
            
        </nav>
        <div class="social" role="region" aria-label="Social hyperlinks">
            <div>
                <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                <a href="https://github.com/kubernetes/kubernetes" class="github"><span>GitHub</span></a>
                <a href="https://slack.k8s.io/" class="slack"><span>Slack</span></a>
            </div>
            <div>
                <a href="https://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                <a href="https://www.youtube.com/kubernetescommunity" class="youtube"><span>YouTube</span></a>
                <a href="https://discuss.kubernetes.io" class="mailing-list"><span>Forum</span></a>
                <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>Kalender acara</span></a>
            </div>
            <div>
                
                <a href="https://git.k8s.io/community/contributors/guide" class="button">Kontribusi</a>
            </div>
        </div>
        <div class="miceType center">
            &copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan melalui <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></a>
        </div>
        <div class="miceType center">
            Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">halaman penggunaan merek dagang</a>
        </div>
        <div class="miceType center">
            ICP license: 京ICP备17074266号-3
        </div>
    </div>
</footer>

		<button class="flyout-button" onclick="kub.toggleToc()" aria-label="Toggle table of contents visibility"></button>

<script>

(function () {
    window.addEventListener('DOMContentLoaded', init)

        
        function init() {
            window.removeEventListener('DOMContentLoaded', init)
                hideNav()
        }

    function hideNav(toc){
        if (!toc) toc = document.querySelector('#docsToc')
        if (!toc) return
            var container = toc.querySelector('.container')

                
                if (container) {
                    if (container.childElementCount === 0 || toc.querySelectorAll('a.item').length === 1) {
                        toc.style.display = 'none'
                            document.getElementById('docsContent').style.width = '100%'
                    }
                } else {
                    requestAnimationFrame(function () {
                        hideNav(toc)
                    })
                }
    }
})();
</script>



    <script language="application/javascript">
      
      (function addHeadingLinks(){
        var article = document.getElementById('docsContent');
        var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(function(heading){
          if(heading.id){
            var a = document.createElement('a');
            a.innerHTML = heading.innerHTML;
            a.href = '#'+heading.id;
            a.classList.add('inpage_heading');
            heading.innerHTML = '';
            heading.appendChild(a);
          }
        });
      })();
    </script>
	</body>
</html>
